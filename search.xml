<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信号处理</title>
      <link href="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><p>在图形学中,通常要处理些连续变量的函数:图片是你见过的第一个例子，但是当你继续探索图形学的时候，你会遇到很多类似的情况.就其本质而言,计算机无法直接表达连续的函数,必须使用有限的位数表达他们- <strong>采样(将函数的值离散的存储起来,在需要时进行重建).</strong><br>本章首先用数字音频的具体一维例子来总结采样和重构。然后，我们继续介绍在一维和二维的采样和重构基础上的基本数学和算法。最后，我们深入频域观点的细节，它为这些算法的行为提供了许多见解。</p><h2 id="1-数字音频-一维采样"><a href="#1-数字音频-一维采样" class="headerlink" title="1. 数字音频: 一维采样"></a>1. 数字音频: 一维采样</h2><p>尽管采样在电信领域已经应用了很多年,但随着数字音频的使用增加，1982年cd的推出是采样在消费者中的第一次大规模应用.<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.jpg" alt="alt"><br>在录音过程中，麦克风将空气中以压力波形式存在的声音转换成时变的电压，这相当于在麦克风所在的位置测量空气压力的变化。这种电信号需要以某种方式储存起来，以便在以后的某个时间播放，并发送到扬声器中，通过与电压同步移动膜片，将电压转换回压力波.<br>录制音频的过程中使用了采样技术, 模数转换器 analog-to-digital converter (A/D converter, or ADC)每秒钟数千次测量电压,生成容易被存储下来的数据流(例如记录在计算机硬盘中).<br>在回放时,数据流以适当的速率被读取,并被发送到数模转换器 digital-to-analog converter (D/A converter, or DAC),DAC根据它接收到的数字产生一个电压，并且如果我们取足够多的样本来表示电压的变化，所得到的电信号，都是相同的输入信号.<br>事实证明，每秒钟需要多少样本来完成一次良好的录制，取决于我们试图记录的声音有多高。一个可以很好录制弦乐低音或者鼓的采样率，应用于录制短笛或铙钹，就会产生奇怪的结果;但这些声音在较高的采样率下被录制得很好。为了避免这些采样不足的影响，数字音频记录器对ADC的输入进行滤波，去除可能导致问题的高频。<br>另一种问题出现在输出端。DAC产生的电压在新采样进入时发生变化，但在下一个采样进入前保持不变，产生阶梯型的波形。这些楼梯就像噪音一样，增加了一种高频的、依赖于信号的嗡嗡声。为了消除这种重建带来的问题，数字音频播放器过滤DAC的输出以平滑波形.</p><h2 id="2-采样偏差与失真"><a href="#2-采样偏差与失真" class="headerlink" title="2. 采样偏差与失真"></a>2. 采样偏差与失真</h2><p>数字音频记录链可以作为采样和重建过程的具体模型，发生在图形中。同样的欠采样和重构伪影也会发生在图像或图形中的其他采样信号上，解决方法是一样的:采样前进行滤波，重构时再进行滤波.<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.png" alt="alt"><br>上图显示了一个由过低的采样频率导致的走样具体例子。在这里，我们用两种不同的采样频率对一个简单的正弦波进行采样:顶部的高频采样和底部的低频采样。高频采样显然能够更好的还原信号,但是由低采样率产生的样本与低频正弦波的样本是无法区分的.<br>一旦采样完成，就无法区分两个信号——快正弦波和慢正弦波——哪个是原始信号，因此没有单一的方法可以在这两种情况下正确地重建信号。因为高频信号可以“假装”成低频信号，这种现象被称为失真。<br>在图形领域,失真经常表现为: </p><ul><li>摩尔纹(moire patterns)  </li><li>边缘锯齿</li></ul><p>采样和重构的基本问题可以简单地根据特征太小或太大来理解，但一些更定量的问题很难回答:</p><ul><li>多高的采样率能够还原重建结果?</li><li>什么样的滤波器适合于采样和重建?</li><li>为了避免失真,需要多大程度的平滑过渡?</li></ul><h2 id="3-卷积-Convolution"><a href="#3-卷积-Convolution" class="headerlink" title="3. 卷积(Convolution)"></a>3. 卷积(Convolution)</h2><p>在讨论采样和重建相关算法之前,首先需要明确相关的基础数学概念-<strong>卷积</strong>.卷积是一个简单的数学概念，它构建了采样、滤波和重构的算法基础.<br>卷积是对函数的一种操作:它接受两个函数作为参数,生成一个新的函数.本书中采用星号(★)作为标记.对函数f和g应用卷积的结果为 f★g.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学相关</title>
      <link href="/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学数学基础知识"><a href="#计算机图形学数学基础知识" class="headerlink" title="计算机图形学数学基础知识"></a>计算机图形学数学基础知识</h1><h2 id="集合与映射-Sets-and-Mappings"><a href="#集合与映射-Sets-and-Mappings" class="headerlink" title="集合与映射(Sets and Mappings)"></a>集合与映射(Sets and Mappings)</h2><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p><img src="/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/1.jpg" alt="alt"></p><h3 id="对数-Logarithms"><a href="#对数-Logarithms" class="headerlink" title="对数(Logarithms)"></a>对数(Logarithms)</h3><p>时至今日，但对数在出现指数项方程的问题中经常有用。根据定义，每一个对数都有一个以a为底的对数</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - Context</title>
      <link href="/2021/11/22/Context/"/>
      <url>/2021/11/22/Context/</url>
      
        <content type="html"><![CDATA[<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>This solution means that you’d have to rewrite a special version of every existing function you want to use in a Maybe! This greatly limits the usefulness of tools such as Maybe. It turns out Haskell has a type class that solves this problem, called Functor.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>Maybe is a member of the Functor type class. The Functor type class requires only one definition: fmap.<br><img src="/2021/11/22/Context/1.jpg" alt="alt"><br><em><strong>fmap provides an adapter</strong></em>, Notice that we’re using &lt;$&gt;, which is a synonym for fmap (except it’s a binary operator rather than a function.<em><strong>This ability to transform the types of values inside a Maybe is the true power of the Functor type class.</strong></em><br><img src="/2021/11/22/Context/2.jpg" alt="alt"></p><p>Though fmap is the official function name, in practice the binary operator &lt;$&gt; is used much more frequently<br><img src="/2021/11/22/Context/3.png" alt="alt"></p><h1 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h1><p><em><strong>the Applicative type class allows you to use functions that are inside a context, such as Maybe or IO, Functor is a superclass of Applicative.</strong></em><br><img src="/2021/11/22/Context/4.jpg" alt="alt"><br><img src="/2021/11/22/Context/5.jpg" alt="alt"></p><h2 id="The-pure-method"><a href="#The-pure-method" class="headerlink" title="The pure method"></a>The pure method</h2><p>The pure method is a useful helper function for taking an ordinary value(also function) or function and putting it into a context.<br><img src="/2021/11/22/Context/7.png" alt="alt"></p><h2 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;*&gt;"></a>&lt;*&gt;</h2><p><img src="/2021/11/22/Context/6.png" alt="alt"></p><h2 id="Containers-vs-contexts"><a href="#Containers-vs-contexts" class="headerlink" title="Containers vs. contexts"></a>Containers vs. contexts</h2><ol><li>Parameterized types that represent a container are types that represent a data structure.</li><li>When a type is a context, extra information is implied about the type, beyond its structure.</li></ol><h2 id="List-as-a-context"><a href="#List-as-a-context" class="headerlink" title="List as a context"></a>List as a context</h2><p>The List type is both a container and a context.List as a container is easy to understand. List is basically a chain of buckets of whatever type of data you want to hold. But List is a member of Applicative,so there must be a way to view List as a context.<br><em><strong>List as a context is that it describes nondeterministic computation.</strong></em></p><p><img src="/2021/11/22/Context/8.png" alt="alt"><br>when you add values in the context of a list,you’re adding together all possible values from the two contexts.</p><ol><li>A list as a container is a sequence of values that can hold any type. Each item in the list points to the next one or to the empty list.</li><li>A list as a context represents a set of possibilities. Think of a list as a context as being a single variable that can contain many possible values.</li></ol><h1 id="MONAD"><a href="#MONAD" class="headerlink" title="MONAD"></a>MONAD</h1><h2 id="The-Monad-type-class"><a href="#The-Monad-type-class" class="headerlink" title="The Monad type class"></a>The Monad type class</h2><p><img src="/2021/11/22/Context/10.jpg" alt="alt"></p><p><img src="/2021/11/22/Context/11.png" alt="alt"></p><h3 id="The-bind-operator-gt-gt"><a href="#The-bind-operator-gt-gt" class="headerlink" title="The bind operator: &gt;&gt;="></a>The bind operator: &gt;&gt;=</h3><p><img src="/2021/11/22/Context/9.png" alt="alt"><br><em><strong>As you can see, &gt;&gt;= allows you to chain together a function of a type (a -&gt; m b)</strong></em></p><h2 id="the-list-Monad"><a href="#the-list-Monad" class="headerlink" title="the list Monad"></a>the list Monad</h2><p>when you assign your list to a variable using &lt;-, you get to treat it as though it were a single value. The rest of this code looks like it’s operating on one candidate, and yet the final result is the same as applying your logic to every candidate in a list.<br><img src="/2021/11/22/Context/12.png" alt="alt"></p><h3 id="Building-lists-with-the-list-monad"><a href="#Building-lists-with-the-list-monad" class="headerlink" title="Building lists with the list monad"></a>Building lists with the list monad</h3><p><img src="/2021/11/22/Context/13.png" alt="alt"></p><h3 id="The-guard-function"><a href="#The-guard-function" class="headerlink" title="The guard function"></a>The guard function</h3><p>Again you could use filter, but when working with monads, you’d like to be able to reason about a value outside its context. In Control.Monad, a function called guard allows you to filter your values in a list. You have to import Control.Monad to use guard.<br><img src="/2021/11/22/Context/14.png" alt="alt"></p><h3 id="list-comprehensions"><a href="#list-comprehensions" class="headerlink" title="list comprehensions"></a>list comprehensions</h3><p><img src="/2021/11/22/Context/15.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - IO</title>
      <link href="/2021/11/20/IO/"/>
      <url>/2021/11/20/IO/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-TYPES"><a href="#IO-TYPES" class="headerlink" title="IO TYPES"></a>IO TYPES</h1><p>Haskell has a special parameterized type called IO. Any value in an IO context must stay in this context. This prevents code that’s pure (meaning it upholds referential transparency and doesn’t change state) and code that’s necessarily impure from mixing.</p><h2 id="IO-types—dealing-with-an-impure-world"><a href="#IO-types—dealing-with-an-impure-world" class="headerlink" title="IO types—dealing with an impure world"></a>IO types—dealing with an impure world</h2><p>IO in Haskell is a parameterized type that’s similar to Maybe.The first thing they share in common is that they’re parameterized types of the same kind.The other thing that Maybe and IO have in common is that (unlike List or Map) they describe a context for their parameters rather than a container. The context for the IO type is that the value has come from an input/output operation.To keep Haskell code pure and predictable, you use the IO type to provide a context for data that may not behave the way all of the rest of your Haskell code does. IO actions aren’t functions.</p><h2 id="Examples-of-IO-actions"><a href="#Examples-of-IO-actions" class="headerlink" title="Examples of IO actions"></a>Examples of IO actions</h2><p>main doesn’t return any meaningful value; it simply performs an action. It turns out that main isn’t a function, because it breaks one of the fundamental rules of functions: it doesn’t return a value. Because of this, we refer to main as an IO action. IO actions work much like functions except they violate at least one of the three rules we established for functions early in the book. Some IO actions return no value, some take no input, and others don’t always return the same value given the same input.<br><img src="/2021/11/20/IO/1.png" alt="alt"></p><h2 id="Do-notation"><a href="#Do-notation" class="headerlink" title="Do-notation"></a>Do-notation</h2><p>This do-notation allows you to treat IO types as if they were regular types. This also explains why some variables use let and others use &lt;-. Variables assigned with &lt;- allow you to act as though a type IO a is just of type a. You use let statements whenever you create variables that aren’t IO types.</p><h3 id="lt"><a href="#lt" class="headerlink" title="&lt;-"></a>&lt;-</h3><p>Donotation allows you to assign an IO String variable by using &lt;-, to act like it’s an ordinary String, and then to pass it to functions that work with only regular Strings<br><img src="/2021/11/20/IO/2.png" alt="alt"></p><h1 id="LAZY-I-O"><a href="#LAZY-I-O" class="headerlink" title="LAZY I/O"></a>LAZY I/O</h1><h2 id="the-nonlazy-way"><a href="#the-nonlazy-way" class="headerlink" title="the nonlazy way"></a>the nonlazy way</h2><p><img src="/2021/11/20/IO/3.png" alt="alt"></p><p><img src="/2021/11/20/IO/4.png" alt="alt"></p><h2 id="lazy-way"><a href="#lazy-way" class="headerlink" title="lazy way"></a>lazy way</h2><p><img src="/2021/11/20/IO/5.png" alt="alt"></p><h3 id="do-notation-in-Maybe"><a href="#do-notation-in-Maybe" class="headerlink" title="do-notation in Maybe"></a>do-notation in Maybe</h3><p>IO can use do-notation because it’s a member of a powerful type class called Monad. We discuss Monad much more in unit 5. Do-notation has nothing to do with IO in particular and can be used by any member of Monad to perform computation in a context. </p><h1 id="TEXT-AND-UNICODE"><a href="#TEXT-AND-UNICODE" class="headerlink" title="TEXT AND UNICODE"></a>TEXT AND UNICODE</h1><h2 id="The-Text-type"><a href="#The-Text-type" class="headerlink" title="The Text type"></a>The Text type</h2><p>Unlike String, Text is implemented as an array under the hood. This makes many string operations faster and much more memory-efficient. Another major difference between Text and String is that Text doesn’t use lazy evaluation. Lazy evaluation proved to be helpful in the preceding lesson, but in many real-world cases it can lead to performance headaches. If you do need lazy text, you can use Data.Text.Lazy, which has the same interface as Data.Text.</p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell02 - types</title>
      <link href="/2021/11/18/types/"/>
      <url>/2021/11/18/types/</url>
      
        <content type="html"><![CDATA[<h1 id="01-TYPE-BASICS"><a href="#01-TYPE-BASICS" class="headerlink" title="01. TYPE BASICS"></a>01. TYPE BASICS</h1><p>in Haskell, you haven’t had to write down any information about the<br>type you’re using for any of your values. It turns out this is because Haskell has done it<br>for you! Haskell uses type inference to automatically determine the types of all values at<br>compile time based on the way they’re used! You don’t have to rely on Haskell to determine your types for you.</p><p><img src="/2021/11/18/types/1.png" alt="alt"></p><h2 id="list-tuple-function"><a href="#list-tuple-function" class="headerlink" title="list  tuple  function"></a>list  tuple  function</h2><p><img src="/2021/11/18/types/2.png" alt="alt"></p><h3 id="Functions-with-multiple-arguments"><a href="#Functions-with-multiple-arguments" class="headerlink" title="Functions with multiple arguments"></a>Functions with multiple arguments</h3><p>why are type signatures this way? The reason is that behind the scenes in Haskell, all functions take only one argument. By rewriting makeAddress by using a series of nested lambda functions.</p><p><img src="/2021/11/18/types/3.png" alt="alt"></p><h3 id="Types-for-first-class-functions"><a href="#Types-for-first-class-functions" class="headerlink" title="Types for first-class functions"></a>Types for first-class functions</h3><p>functions can take functions as arguments and return<br>functions as values. To write these type signatures, you write the individual function<br>values in parentheses.</p><p><img src="/2021/11/18/types/4.png" alt="alt"></p><h2 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h2><p> Haskell has type variables. Any lowercase letter in a type signature indicates that any type can be used in that place.<br> Type variables are literally variables for types. Type variables work exactly like regular<br>variables, but instead of representing a value, they represent a type. When you use a<br>function that has a type variable in its signature, you can imagine Haskell substituting<br>the variable that’s needed.</p><h1 id="02-CREATING-YOUR-OWN-TYPES"><a href="#02-CREATING-YOUR-OWN-TYPES" class="headerlink" title="02. CREATING YOUR OWN TYPES"></a>02. CREATING YOUR OWN TYPES</h1><h2 id="type-synonyms"><a href="#type-synonyms" class="headerlink" title="type synonyms"></a>type synonyms</h2><p>When you have two names for the same type, it’s referred to as a type synonym. Type synonyms are extremely useful, because they make reading type signatures much easier.<br><em><strong>In Haskell, you can create new type synonyms by using the type keyword.</strong></em></p><h2 id="Creating-new-types"><a href="#Creating-new-types" class="headerlink" title="Creating new types"></a>Creating new types</h2><h2 id="record-syntax"><a href="#record-syntax" class="headerlink" title="record syntax"></a>record syntax</h2><p>You can define data types such as Patient by using record syntax. Defining a new data type by using record syntax makes it much easier to understand which types represent<br>which properties of the data type.<br><img src="/2021/11/18/types/5.png" alt="alt"></p><h3 id="automatically-getters-and-setters"><a href="#automatically-getters-and-setters" class="headerlink" title="automatically getters and setters"></a>automatically getters and setters</h3><p>you don’t have to write your getters; each field in the record syntax automatically creates a function to access that value from the record.You can also set values in record syntax by passing the new value in curly brackets to<br>your data.<br><img src="/2021/11/18/types/6.png" alt="alt"></p><h1 id="03-TYPE-CLASSES"><a href="#03-TYPE-CLASSES" class="headerlink" title="03. TYPE CLASSES"></a>03. TYPE CLASSES</h1><p>Type classes in Haskell are a way of describing groups of types that all behave in the same way. If you’re familiar with<br>Java or C#, type classes may remind you of interfaces.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>definition of the type class is a list of functions that all members of the class must implement, along with the type signatures of<br>those functions. The family of functions that describe a number is +, -, *, negate, abs, and<br>signum (gives the sign of a number)<br><img src="/2021/11/18/types/7.jpg" alt="alt"></p><h2 id="The-benefits-of-type-classes"><a href="#The-benefits-of-type-classes" class="headerlink" title="The benefits of type classes"></a>The benefits of type classes</h2><p>So far in Haskell, each function you’ve defined works for only one specific set of types. Without type classes, you’d need a different name for each function that adds a different type of value. You do have type variables, but they’re too flexible.<br><em><strong>Type classes also allow you to define functions on a variety of types that you can’t even<br>think of</strong></em></p><h2 id="Defining-a-type-class"><a href="#Defining-a-type-class" class="headerlink" title="Defining a type class"></a>Defining a type class</h2><p><img src="/2021/11/18/types/8.jpg" alt="alt"></p><h2 id="Deriving-type-classes"><a href="#Deriving-type-classes" class="headerlink" title="Deriving type classes"></a>Deriving type classes</h2><p><img src="/2021/11/18/types/9.png" alt="alt"></p><h2 id="implement-type-class"><a href="#implement-type-class" class="headerlink" title="implement type class"></a>implement type class</h2><p><img src="/2021/11/18/types/10.png" alt="alt"></p><h2 id="Creating-types-with-newtype"><a href="#Creating-types-with-newtype" class="headerlink" title="Creating types with newtype"></a>Creating types with newtype</h2><p>When looking at our type definition for Name, you find an interesting case in which you’d like to use a type synonym, but need to define a data type in order to make your type an instance of a type class. Haskell has a preferred method of doing this: <em><strong>using the newtype keyword.</strong></em> Here’s an example of the definition of Name using newtype.<br><img src="/2021/11/18/types/11.png" alt="alt"></p><h1 id="04-AlGEBRAIC-DATA-TYPES"><a href="#04-AlGEBRAIC-DATA-TYPES" class="headerlink" title="04. AlGEBRAIC DATA TYPES"></a>04. AlGEBRAIC DATA TYPES</h1><p>Algebraic data types are any types that can be made by combining other types. The key to understanding algebraic data types is knowing exactly how to combine other types. Thankfully, there are only two ways. You can combine multiple types with an and (for example, a name is a String and another String), or you can combine types with an or (for example, a Bool is a True data constructor or a False data constructor). Types that are made by combining other types with an and are called product types. Types combined using or are called sum types.</p><h2 id="product-type"><a href="#product-type" class="headerlink" title="product type"></a>product type</h2><p>Product types are created by combining two or more existing types with and, bundling two or more types together to define a new type. Nearly every programming language supports product types, even if not by that name.<br><img src="/2021/11/18/types/12.png" alt="alt"></p><h2 id="sum-type"><a href="#sum-type" class="headerlink" title="sum type"></a>sum type</h2><p>Sum types are a surprisingly powerful tool, given that they provide only the capability to combine two types with or. </p><h1 id="05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS"><a href="#05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS" class="headerlink" title="05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS"></a>05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS</h1><h2 id="combining-functions"><a href="#combining-functions" class="headerlink" title="combining functions"></a>combining functions</h2><p>combining functions:A special higher-order function that’s just a period (called compose) takes two functions as arguments.<br><img src="/2021/11/18/types/13.png" alt="alt"></p><h2 id="Combining-like-types-Semigroups"><a href="#Combining-like-types-Semigroups" class="headerlink" title="Combining like types: Semigroups"></a>Combining like types: Semigroups</h2><p>The Semigroup class has only one important method you need, the &lt;&gt; operator. You can think of &lt;&gt; as an operator for combining instances of the same type.<br><img src="/2021/11/18/types/14.png" alt="alt"><br><em><strong>This simple signature is the heart of the idea of composability; you can take two like<br>things and combine them to get a new thing of the same type.</strong></em></p><h2 id="Composing-with-identity-Monoids"><a href="#Composing-with-identity-Monoids" class="headerlink" title="Composing with identity: Monoids"></a>Composing with identity: Monoids</h2><p>Another type class that’s similar to Semigroup is Monoid. The only major difference between Semigroup and Monoid is that Monoid requires an identity element for the type. An identity element means that x &lt;&gt; id = x (and id &lt;&gt; x = x). <em><strong>Having an identity element might seem like a small detail, but it greatly increases the power of a type by allowing you to use a fold function to easily combine lists of the same type.</strong></em><br><img src="/2021/11/18/types/15.png" alt="alt"></p><h3 id="mconcat"><a href="#mconcat" class="headerlink" title="mconcat"></a>mconcat</h3><p><em><strong>The mconcat method takes a list of Monoids and combines them, returning a single Monoid.</strong></em><br>The easiest way to see how powerful identity is, is to explore the final method in the definition of Monoid: mconcat. The only required definitions in Monoid are mempty and mappend. If you implement these two, you get mconcat for free.This is because the definition of mconcat relies only on foldr, mappend, and mempty. Here’s the definition of mconcat:<br><img src="/2021/11/18/types/16.png" alt="alt"></p><h3 id="Monoid-laws"><a href="#Monoid-laws" class="headerlink" title="Monoid laws"></a>Monoid laws</h3><ol><li>mappend mempty x is x</li><li>mappend x mempty is x</li><li>mappend x (mappend y z) = mappend (mappend x y) z</li><li>mconcat = foldr mappend mempty</li></ol><h1 id="06-PARAMETERIZED-TYPES"><a href="#06-PARAMETERIZED-TYPES" class="headerlink" title="06. PARAMETERIZED TYPES"></a>06. PARAMETERIZED TYPES</h1><p>If you’re familiar with type generics in languages such as C# and Java, parameterized types will initially seem similar. Like generics in C# and Java, parameterized types allow you to create “containers” that can hold other types.</p><h2 id="definition-1"><a href="#definition-1" class="headerlink" title="definition"></a>definition</h2><p><img src="/2021/11/18/types/17.png" alt="alt"></p><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>A list of type a is either Empty or the consing of the value a with another     list of type a.<br><img src="/2021/11/18/types/18.png" alt="alt"></p><h2 id="Types-with-more-than-one-parameter"><a href="#Types-with-more-than-one-parameter" class="headerlink" title="Types with more than one parameter"></a>Types with more than one parameter</h2><p>Just like functions, types can also take more than one argument. The important thing to remember is that more than one type parameter means the type can be a container for more than one type.</p><h3 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h3><p>Tuples are the most ubiquitous multiparameter type in Haskell. tuples use a built-in type constructor, ().you have to use () with one comma inside for every n – 1 items in the tuple. For example, if you want the definition of a 2-tuple, you’d type :info<br>(,) into GHCi. Here’s the built-in definition.<br><img src="/2021/11/18/types/19.png" alt="alt"></p><h3 id="Data-Map"><a href="#Data-Map" class="headerlink" title="Data.Map"></a>Data.Map</h3><p>Map allows you to look up values by using keys. In many other languages, this data type is called Dictionary. The type parameters of Map are the types of the keys and values. The most common way to build a Map is with the fromList function.<br><img src="/2021/11/18/types/20.png" alt="alt"><br><img src="/2021/11/18/types/21.png" alt="alt"></p><h2 id="Kinds-types-of-types"><a href="#Kinds-types-of-types" class="headerlink" title="Kinds: types of types"></a>Kinds: types of types</h2><p>The type of a type is called its kind. <em>*<em>The kind of a type indicates the number of parameters the type takes, which are expressed using an asterisk (</em>). Types that take no parameters have a kind of *, types that take one parameter have the kind * -&gt; <em>, types with two parameters have the kind * -&gt; * -&gt; <em>, and so forth.</em></em></em></p><h1 id="07-Maybe"><a href="#07-Maybe" class="headerlink" title="07. Maybe"></a>07. Maybe</h1><h2 id="solving-missing-values-with-types"><a href="#solving-missing-values-with-types" class="headerlink" title="solving missing values with types"></a>solving missing values with types</h2><p>Maybe is a simple but powerful type. So far, all of our parameterized types have been viewed as containers. Maybe is different. <em><strong>Maybe is best understood as a type in a context.The context in this case is that the type contained might be missing. Here’s its definition.</strong></em><br><img src="/2021/11/18/types/22.png" alt="alt"><br>When a function returns a value of the Maybe type, the program can’t use that value without dealing with the fact that the value<br>is wrapped in a Maybe. Missing values can never cause an error in Haskell because Maybe makes it impossible to forget that a value might be null. At the same time, the programmer never has to worry about this until absolutely necessary. </p><p><em><strong>The interesting thing here is that you didn’t even have to remove the organ from the Maybe context. Maybe implements Eq, so you can just compare two Maybe Organs.</strong></em></p><h2 id="isJust-and-isNothing"><a href="#isJust-and-isNothing" class="headerlink" title="isJust and isNothing"></a>isJust and isNothing</h2><p>The Data.Maybe module contains two functions, isJust and isNothing, that solve the general case of handling Just values. </p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell01 - Foundations of functional programming</title>
      <link href="/2021/11/16/Foundations-of-functional-programming/"/>
      <url>/2021/11/16/Foundations-of-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Functions"><a href="#01-Functions" class="headerlink" title="01. Functions"></a>01. Functions</h1><p>All functions in Haskell follow three rules that force them to behave like functions in<br>math:</p><ul><li>All functions must take an argument.</li><li>All functions must return a value.</li><li>Anytime a function is called with the same argument, it must return the same<br>value</li></ul><p>The third rule is part of the basic mathematical definition of a function. When the rule<br>that the same argument must always produce the same result is applied to function in a<br>programming language, it’s called referential transparency.</p><h1 id="02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE"><a href="#02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE" class="headerlink" title="02. LAMBDA FUNCTIONS AND LEXICAL SCOPE"></a>02. LAMBDA FUNCTIONS AND LEXICAL SCOPE</h1><h2 id="Lambda-functions"><a href="#Lambda-functions" class="headerlink" title="Lambda functions"></a>Lambda functions</h2><p>One of the most foundational concepts in functional programming is a function without<br>a name, called a lambda function (hence lambda calculus). Lambda functions are often<br>referred to using the lowercase Greek letter λ. Another common name for a lambda<br>function is an anonymous function.<br><img src="/2021/11/16/Foundations-of-functional-programming/1.png" alt="alt"></p><h2 id="Practical-lambda-functions-and-lexical-scope"><a href="#Practical-lambda-functions-and-lexical-scope" class="headerlink" title="Practical lambda functions and lexical scope"></a>Practical lambda functions and lexical scope</h2><p>IIFE works on exactly the same principles as our example of replacing a where statement. Whenever you create a new function, named or not, you<br>create a new scope, which is the context in which a variable is defined. When a variable is<br>used, the program looks at the nearest scope; if the definition of the variable isn’t there,<br>it goes to the next one up. This particular type of variable lookup is called lexical scope.<br>Both Haskell and JavaScript use lexical scoping, which is why IIFE and your lambda function variables behave in a similar fashion.</p><h1 id="03-FIRST-CLASS-FUNCTIONS"><a href="#03-FIRST-CLASS-FUNCTIONS" class="headerlink" title="03. FIRST-CLASS FUNCTIONS"></a>03. FIRST-CLASS FUNCTIONS</h1><p>The concept of first-class functions is that functions are no different from any other data<br>used in a program. Functions can be used as arguments and returned as values from<br>other functions. This is a deceptively powerful feature for a programming language to<br>have. It allows you to abstract out any repetitive computation from your code, and ultimately allows you to write functions that write other functions.</p><h1 id="04-LISTS"><a href="#04-LISTS" class="headerlink" title="04 LISTS"></a>04 LISTS</h1><p>Lists are the single most important data structure in functional programming. One of<br>the key reasons is that lists are inherently recursive. A list is either an empty list or an<br>element followed by another list</p><h2 id="head-tail"><a href="#head-tail" class="headerlink" title="head tail"></a>head tail</h2><p>When taking apart a list, the main pieces are the head, the tail.The head is just the first element in a list.The tail is the rest of the list left over, after the head<br><img src="/2021/11/16/Foundations-of-functional-programming/3.png" alt="alt"></p><p><img src="/2021/11/16/Foundations-of-functional-programming/4.png" alt="alt"></p><h2 id="cons"><a href="#cons" class="headerlink" title="cons(:)"></a>cons(:)</h2><p>To build a list, you need just one function and the infix operator (:),<br>which is called cons. you need to take a value and cons it with another list. The simplest way<br>to make a list is to cons a value with the empty list. <em><strong>By definition, a list is always a<br>value consed with another list (which can also be an empty list)</strong></em><br>If you do want to combine two lists, you need to concatenate them by using ++</p><h2 id="lazy-evaluation"><a href="#lazy-evaluation" class="headerlink" title="lazy evaluation"></a>lazy evaluation</h2><p>Haskell uses a special form of evaluation called lazy evaluation. In lazy evaluation,<br>no code is evaluated until it’s needed.</p><h2 id="Common-functions-on-lists"><a href="#Common-functions-on-lists" class="headerlink" title="Common functions on lists"></a>Common functions on lists</h2><h3 id="The-operator"><a href="#The-operator" class="headerlink" title="The !! operator"></a>The !! operator</h3><p>If you want to access a particular element of a list by its index, you can use the !! operator. The !! operator takes a list and a number, returning the element at that location in<br>the list. <em><strong>any infix operator (an operator that’s placed between two values, such as +) can also be used like a prefix function by wrapping it in parentheses</strong></em><br><img src="/2021/11/16/Foundations-of-functional-programming/5.png" alt="alt"></p><h4 id="partial-application"><a href="#partial-application" class="headerlink" title="partial application"></a>partial application</h4><p><em><strong>Using prefix notation can often make things such as partial application easier. Prefix<br>notation is also useful for using operators as arguments to other functions. You can still<br>use partial application with an infix operator; you just need to wrap the expression in<br>parentheses</strong></em></p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>give the length of the list</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>reverse the list</p><h3 id="elem"><a href="#elem" class="headerlink" title="elem"></a>elem</h3><p>The elem function takes a value and a list and checks whether the value is in the list.elem is a function that you may want to treat as an infix operator for readability. <em><strong>Any<br>binary function can be treated as an infix operator by wrapping it in back-quotes (`)</strong></em></p><h3 id="take-and-drop"><a href="#take-and-drop" class="headerlink" title="take and drop"></a>take and drop</h3><p>The take function takes a number and a list as arguments and then returns the first n elements of the list. f you ask for more values then a list has, take gives you what it can, with no error.</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>You use zip when you want to combine two lists into tuple pairs. The arguments to zip<br>are two lists. If one list happens to be longer, zip will stop whenever one of the two lists<br>is empty.</p><h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><p> cycle uses lazy evaluation to create an infinite list. Given a list, cycle repeats that list endlessly.<br><img src="/2021/11/16/Foundations-of-functional-programming/6.png" alt="alt"></p><h1 id="05-RECURSION-AND-PATTERN-MATCHING"><a href="#05-RECURSION-AND-PATTERN-MATCHING" class="headerlink" title="05 RECURSION AND PATTERN MATCHING"></a>05 RECURSION AND PATTERN MATCHING</h1><p>In general, something is recursive if it’s defined in terms of itself.</p><h2 id="Rules-from-Recursion"><a href="#Rules-from-Recursion" class="headerlink" title="Rules from Recursion"></a>Rules from Recursion</h2><ol><li>Identify the end goal(s).</li><li>Determine what happens when a goal is reached.</li><li>List all alternate possibilities.</li><li>Determine your “rinse and repeat” process.</li><li>Ensure that each alternative moves you toward your goal.</li></ol><h2 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h2><p>Haskell has an amazing feature called pattern matching<br>that allows you to peek at the values passed as arguments and behave accordingly.</p><ol><li><em><strong>Pattern matching, just like case, looks at the options in order</strong></em></li><li><em><strong>pattern matching is that it can look only at arguments, but it can’t do any computation on them when matching</strong></em></li><li>_<strong>it’s standard practice to use _ as a wildcard for values you don’t use</strong>_</li></ol><h2 id="Recursion-on-lists"><a href="#Recursion-on-lists" class="headerlink" title="Recursion on lists"></a>Recursion on lists</h2><h3 id="implements-built-in-length-take-cycle"><a href="#implements-built-in-length-take-cycle" class="headerlink" title="implements built-in length take cycle"></a>implements built-in length take cycle</h3><p><img src="/2021/11/16/Foundations-of-functional-programming/7.png" alt="alt"></p><h1 id="06-HIGHER-ORDER-FUNCTIONS"><a href="#06-HIGHER-ORDER-FUNCTIONS" class="headerlink" title="06 HIGHER-ORDER FUNCTIONS"></a>06 HIGHER-ORDER FUNCTIONS</h1><p>A higher-order function is technically any function that takes another function as an argument.<br>Typically, when higher-order functions are mentioned, a specific group of them comes<br>to mind, and nearly all of these are used to abstract away common patterns of recursion.<br>The main reason that you use first-class functions, and therefore have higher-order<br>functions, is so you can abstract out programming patterns</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>The map function takes another function and a list as arguments and applies that<br>function to each element in the list.</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>The filter function looks and behaves similarly to map, taking a function and a list as arguments and<br>returning a list. The difference is that the function passed to filter must be passed a<br>function that returns True or False. The filter function works by keeping only the elements of the list that pass the test</p><h2 id="foldl-foldr"><a href="#foldl-foldr" class="headerlink" title="foldl(foldr)"></a>foldl(foldr)</h2><p>The function foldl (the l stands for left) takes a list and reduces<br>it to a single value. The function takes three arguments: a binary function, an initial<br>value, and a list. The most common use of foldl is to sum a list.</p><h2 id="implements-map-filter-amp-foldl"><a href="#implements-map-filter-amp-foldl" class="headerlink" title="implements map filter &amp; foldl"></a>implements map filter &amp; foldl</h2><p><img src="/2021/11/16/Foundations-of-functional-programming/8.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function</title>
      <link href="/2021/11/02/function/"/>
      <url>/2021/11/02/function/</url>
      
        <content type="html"><![CDATA[<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="函数声明的两种方式"><a href="#函数声明的两种方式" class="headerlink" title="函数声明的两种方式"></a>函数声明的两种方式</h2><p><img src="/2021/11/02/function/1.png" alt="alt"></p><blockquote><p>如果使用函数重载，则只能使用第一种方式</p></blockquote><p><img src="/2021/11/02/function/2.png" alt="alt"></p><h2 id="参数注解-amp-返回类型注解"><a href="#参数注解-amp-返回类型注解" class="headerlink" title="参数注解 &amp; 返回类型注解"></a>参数注解 &amp; 返回类型注解</h2><h2 id="可选参数-amp-默认值参数"><a href="#可选参数-amp-默认值参数" class="headerlink" title="可选参数 &amp; 默认值参数"></a>可选参数 &amp; 默认值参数</h2>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>enum</title>
      <link href="/2021/11/01/enum/"/>
      <url>/2021/11/01/enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h1><p>当一个变量有几种可能的取值时,可以将它定义为枚举类型，</p><ol><li>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加</li><li>因此当我们把第一个值赋值后,后面也会根据第一个值进行累加</li><li>枚举类型的值其实也可以是字符串类型</li><li>字符串枚举可以和数字枚举混合使用</li></ol><h2 id="枚举的本质-amp-双向映射"><a href="#枚举的本质-amp-双向映射" class="headerlink" title="枚举的本质 &amp; 双向映射"></a>枚举的本质 &amp; 双向映射</h2><p>枚举具有双向映射的特性，所谓双向映射指的是通过key可以索引到value,同时通过value也可以索引到key.<br>原因就在编译后的 JavaScript把枚举类型构造成为了一个对象，而由于其特殊的构造，导致其拥有正反向同时映射的特性<br><img src="/2021/11/01/enum/1.png" alt="alt"></p><h2 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h2><p>枚举可以被 const 声明为常量,这样做的好处是，编译后的js代码中实际上是不存在枚举和枚举对象的，使用的是枚举的值，这是性能提升的一个方案。</p><blockquote><p>如果你非要 TypeScript 保留对象 Direction ,那么可以添加编译选项 –preserveConstEnums</p></blockquote><h2 id="联合枚举类型"><a href="#联合枚举类型" class="headerlink" title="联合枚举类型"></a>联合枚举类型</h2><p>将一个变量声明为枚举类型，可以认为声明了一个联合类型，联合类型的值对应枚举的值。<br><img src="/2021/11/01/enum/2.png" alt="alt"></p><h2 id="使用数字类型作为标志"><a href="#使用数字类型作为标志" class="headerlink" title="使用数字类型作为标志"></a>使用数字类型作为标志</h2><p><img src="/2021/11/01/enum/3.png" alt="alt"></p><h2 id="为枚举添加静态方法"><a href="#为枚举添加静态方法" class="headerlink" title="为枚举添加静态方法"></a>为枚举添加静态方法</h2><p>可以使用enum + namespace 的声明方式向枚举类型添加静态方法.如下例所示，我们将静态成员 isBusinessDay 添加到枚举上<br><img src="/2021/11/01/enum/4.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface</title>
      <link href="/2021/10/31/interface/"/>
      <url>/2021/10/31/interface/</url>
      
        <content type="html"><![CDATA[<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查,它有时被称做”鸭式辩型法”或”结构型子类型化”.<br>TypeScript里接口的作用就是为这些类型命名和为你的代码和第三方代码定义契约.<br><img src="/2021/10/31/interface/1.png" alt="alt"></p><h2 id="可选属性-amp-只读属性"><a href="#可选属性-amp-只读属性" class="headerlink" title="可选属性 &amp; 只读属性"></a>可选属性 &amp; 只读属性</h2><p><img src="/2021/10/31/interface/2.png" alt="alt"></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p><img src="/2021/10/31/interface/3.png" alt="alt"></p><h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>通过定义key和value的类型宽泛的描述接口”形状”.<br><img src="/2021/10/31/interface/4.png" alt="alt"></p><h4 id="所有成员都必须符合字符串的索引签名"><a href="#所有成员都必须符合字符串的索引签名" class="headerlink" title="所有成员都必须符合字符串的索引签名"></a>所有成员都必须符合字符串的索引签名</h4><p><img src="/2021/10/31/interface/5.png" alt="alt"></p><h4 id="使用一组有限的字符串字面量"><a href="#使用一组有限的字符串字面量" class="headerlink" title="使用一组有限的字符串字面量"></a>使用一组有限的字符串字面量</h4><p>一个索引签名可以通过映射类型来使索引字符串为联合类型中的一员<br><img src="/2021/10/31/interface/6.png" alt="alt"></p><h4 id="索引签名的嵌套"><a href="#索引签名的嵌套" class="headerlink" title="索引签名的嵌套"></a>索引签名的嵌套</h4><p>尽量不要使用这种把字符串索引签名与有效变量混合使用。如果属性名称中有拼写错误，这个错误不会被捕获到<br><img src="/2021/10/31/interface/8.png" alt="alt"></p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>基于现有接口实现一个新接口,添加部分额外属性,可以通过接口继承的方式,实现代码重用.<br><img src="/2021/10/31/interface/7.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeScript类型系统</title>
      <link href="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="typeScript类型系统"><a href="#typeScript类型系统" class="headerlink" title="typeScript类型系统"></a>typeScript类型系统</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>基本注解采用 <strong>:TypeAnnotation</strong>语法,在类型声明空间中可用的任何内容都可以用作类型注解</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 string、number、boolean 也可以被用作类型注解.</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/1.png" alt="alt"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>针对数组的类型注解有两种方式 <strong>:TypeAnnotation[]</strong> 或者 <strong>Array&lt;TypeAnnotation&gt;</strong>,这两种方式是等价的<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/2.png" alt="alt"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>typeScript核心特性,合并众多类型声明至一个类型声明<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/3.png" alt="alt"></p><h3 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h3><p>内联类型能快速提供一个类型注解,不必为类型起单独的名称,然而,如果你发现需要多次使用相同的内联注解,应该把它重构为一个接口<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/4.png" alt="alt"></p><h3 id="联合类型-amp-交叉类型"><a href="#联合类型-amp-交叉类型" class="headerlink" title="联合类型 &amp; 交叉类型"></a>联合类型 &amp; 交叉类型</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型(|)"></a>联合类型(|)</h4><p>所期望的属性是众多类型之一,如字符串或字符串数组,本质上是类型的并集操作,这正是typeScript中联合类型的用途,使用 | 作标记.</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/5.png" alt="alt"></p><h4 id="交叉类型-amp"><a href="#交叉类型-amp" class="headerlink" title="交叉类型(&amp;)"></a>交叉类型(&amp;)</h4><p>在 JavaScript 中， extend 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/6.png" alt="alt"></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型和数组很相似,表示一个已知元素数量和类型的数组,各元素的类型不必相同.可以把元组看成严格版型的数组<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/7.png" alt="alt"><br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/8.png" alt="alt"></p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <strong>type SomeName = someValidTypeAnnotation</strong> 来创建别名：</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/9.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core 文件系统</title>
      <link href="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-文件系统"><a href="#Asp-Net-Core-文件系统" class="headerlink" title="Asp.Net Core 文件系统"></a>Asp.Net Core 文件系统</h1><p>ASP.NET Core 具有很多针对文件读取的应用。比如我们倾向于采用JSON文件来定义配置，所以应用就会涉及针对配置文件读取。如果用户发送一个针对物理文件的HTTP请求，应用会根据指定的路径读取目标文件的内容并对请求予以响应。在一个ASP.NET Core MVC应用中，针对View的动态编译会涉及到根据预定义的路径映射关系来读取目标View文件。这些不同应用场景都会出现一个IFileProvider对象的身影，以此对象为核心的文件系统提供了统一的API来读取文件的内容并监控内容的改变。</p><h2 id="物理文件系统"><a href="#物理文件系统" class="headerlink" title="物理文件系统"></a>物理文件系统</h2><h3 id="IChangeToken"><a href="#IChangeToken" class="headerlink" title="IChangeToken"></a>IChangeToken</h3><p>由于IFileProvider提供了针对文件系统变换的监控功能，在.NET Core的世界里类似的功能大都利用一个IChangeToken对象来实现.从字面上理解的IChangeToken对象就是一个与某组监控数据关联的“令牌（Token）”，它能够在检测到数据改变的时候及时地对外发出一个通知。IChangeToken接口具有如下所示的三个成员。</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider1.jpg" alt="alt"></p><ul><li><p><strong>HasChanged</strong>:如果关联的数据发生改变，HasChanged属性将变成True.</p></li><li><p><strong>ActiveChangeCallbacks</strong>:它表示当数据发生变化时是否需要主动执行注册的回调操作.</p></li><li><p><strong>RegisterChangeCallback</strong>:注册一个在数据发生改变时可以自动执行的回调，该方法会以一个IDisposable对象的形式返回注册对象，所以我们应该在适当的时机调用其Dispose方法解除注册的回调.</p></li></ul><h3 id="IFileProvider"><a href="#IFileProvider" class="headerlink" title="IFileProvider"></a>IFileProvider</h3><p>IFileProvider的接口定义如下图:</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider2.jpg" alt="alt"></p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider3.jpg" alt="alt"></p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider4.jpg" alt="alt"></p><ul><li><p><strong>GetDirectoryContents</strong>:通过给定的路径遍历目录,返回一个由IFileInfo组成的集合.该接口有一个属性Exists,判断指定路径目录是否存在.</p></li><li><p><strong>IsDirectory</strong>:由GetDirectoryContents得到的集合中无论是目录还是文件,都会用IFileInfo来表示.判断是文件还是目录用属性IsDirectory来区分.</p></li><li><p><strong>GetFileInfo</strong>:获取指定路径下的文件.如果是目录或者不存在,则Exists属性返回false.</p></li><li><p><strong>Watch</strong>:监控指定文件的变化,如果产生变化,则调用注册的回调函数.如下图所示.</p></li></ul><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider5.jpg" alt="alt"></p><p>文件系统涉及的接口以及相互关系图.</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider6.jpg" alt="alt"></p><h3 id="物理文件系统-1"><a href="#物理文件系统-1" class="headerlink" title="物理文件系统"></a>物理文件系统</h3><p>物理文件系统涉及的接口以及相互关系图</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider7.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务消费</title>
      <link href="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/"/>
      <url>/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务消费"><a href="#Asp-Net-Core-DI-服务消费" class="headerlink" title="Asp.Net Core DI-服务消费"></a>Asp.Net Core DI-服务消费</h1><p>本系列博客均来源于大内老A关于Asp.NET Core的解读,在此进基础上进行了提炼,方便日后查看学习.<br>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IServiceProvider的GetService方法，IServiceProvider就会根据对应的服务注册提供所需的服务实例。</p><h2 id="IServiceProvider"><a href="#IServiceProvider" class="headerlink" title="IServiceProvider"></a>IServiceProvider</h2><p>IServiceProvider由ServiceCollection的BuildServiceProvider方法来生成,ServiceProvider只包含一个方法GetService(Type serviceType).如下图:</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use1.jpg" alt="alt"><br>IserviceProvider包含其他一些扩展方法,可以方便通过不同方式不用应用场景返回实例.如下图:</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use2.jpg" alt="alt"></p><ul><li>GetService<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应实例,如果没有T对应的注册信息,返回null</T></li><li>GetServices<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应的多个实例</T></li><li> GetServices(this IServiceProvider provider, Type serviceType):传参的方式</li><li>GetRequiredService(this IServiceProvider provider, Type serviceType):如果指定服务类型的服务注册不存在,则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用者两个扩展方法</li></ul><h2 id="构造函数的选择"><a href="#构造函数的选择" class="headerlink" title="构造函数的选择"></a>构造函数的选择</h2><p>如果IServiceProvider对象试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，最终被选择出来的构造函数必须具备一个基本的条件：</p><ul><li>第一个原则:<strong>IServiceProvider能够提供构造函数的所有参数</strong>.</li><li>第二个原则: <strong>每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集</strong>.</li></ul><h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>对于DI框架体用的三种生命周期（Singleton、Scoped和Transient）来说，Singleton和Transient都具有明确的语义，但是Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由IServiceScopeFactory接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有如图3所示的“父子关系”。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有“父子关系”。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use3.jpg" alt="alt"></p><p>如上图所示的树形层次结构只是一种逻辑结构，从对象引用层面来开，通过某个IServiceScope包裹的IServiceProvider对象不需要知道自己的“父亲”是谁，它只关心作为根节点的IServiceProvider在哪里就可以了。下图从物理层面揭示了IServiceScope/IServiceProvider对象之间的关系，任何一个IServiceProvider对象都具有针对根容器的引用。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use4.jpg" alt="alt"></p><h2 id="三种生命周期模式"><a href="#三种生命周期模式" class="headerlink" title="三种生命周期模式"></a>三种生命周期模式</h2><ul><li><strong>Singleton</strong>:IServiceProvider创建的服务实例保存在作为根容器的IServiceProvider上，所有多个同根的IServiceProvider对象提供的针对同一类型的服务实例都是同一个对象.</li><li><strong>Scoped</strong>:IServiceProvider创建的服务实例由自己保存，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象.</li><li><strong>Transient</strong>:针对每一次服务提供请求,IServiceProvider总是创建一个新的实例.</li></ul><h2 id="ASP-NET-Core应用下的生命周期"><a href="#ASP-NET-Core应用下的生命周期" class="headerlink" title="ASP.NET Core应用下的生命周期"></a>ASP.NET Core应用下的生命周期</h2><p>DI框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如下图所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider，另一个类则是根据请求及时创建和释放的IServiceProvider，我们可以将它们分别称为Application ServiceProvider和Request ServiceProvider。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use5.jpg" alt="alt"></p><p>在ASP.NET Core应用初始化过程中，即请求管道构建过程中使用的服务实例都是由Application ServiceProvider提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个服务范围，该服务范围提供的Request ServiceProvider用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，上述的这个中间件会主动释放掉由它创建的服务范围。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务注册</title>
      <link href="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务注册"><a href="#Asp-Net-Core-DI-服务注册" class="headerlink" title="Asp.Net Core DI-服务注册"></a>Asp.Net Core DI-服务注册</h1><p>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。IServiceCollection实际上是包含了<strong>ServiceDescriptor</strong>对象的集合.</p><h2 id="ServiceDescriptor"><a href="#ServiceDescriptor" class="headerlink" title="ServiceDescriptor"></a>ServiceDescriptor</h2><p>IServiceCollection对象是一个存放服务注册信息的集合.在IServiceCollection/IServiceProvider为核心的DI框架中,与之对应的类型为ServiceDescriptor.</p><p>DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中.如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p>ServiceDescriptor共有5个属性,3个构造函数,如下所示:</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment1.jpg" alt="alt"></p><p>属性说明:</p><ul><li>ServiceType:注册的服务类型.往往是一个接口</li><li>ImplementationType:实现ServiceType接口的类</li><li>ImplementationInstance:已经实例化的对象</li><li>ImplementationFactory:提供对象的工厂方法.类型为Func&lt;IServiceProvider,object&gt;</li><li>Lifetime:生命周期,枚举类型,对应有三个值,分别为:Singleton,Scoped,Transient</li></ul><p>构造函数说明:<br>ServiceDescriptor的三个属性(ImplementationType,ImplementationInstance,ImplementationFactory)体现了服务实例的三种提供方式，并对应着三个构造函数。</p><ul><li>ServiceDescriptor(Type serviceType,object instace):提供现有对象,该对象就是最终提供的服务实例.</li><li>ServiceDescriptor(Type serviceType,Type implementationType,ServiceLifetime lifetime):最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建.</li><li>ServiceDescriptor(Type serviceType, Func&lt;IServiceProvider, object&gt; factory, ServiceLifetime lifetime):IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例</li></ul><h2 id="IServiceCollection"><a href="#IServiceCollection" class="headerlink" title="IServiceCollection"></a>IServiceCollection</h2><p>DI框架将服务注册(IServiceDescriptor)存储在一个通过IServiceCollection接口表示的集合之中.一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment2.jpg" alt="alt"></p><p>我们在应用启动的时候所做的服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程.考虑到服务注册是一个高频调用的操作,所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作.</p><p>DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中.如下所示的是针对Singleton模式的AddSingleton方法重载的定义,针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义.</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment3.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI框架</title>
      <link href="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-NET-Core-DI框架概览"><a href="#Asp-NET-Core-DI框架概览" class="headerlink" title="Asp.NET Core DI框架概览"></a>Asp.NET Core DI框架概览</h1><p>毫不夸张地说,整个ASP.NET Core框架是建立在一个依赖注入框架之上的,它在应用启动时构建请求处理管道的过程中,以及利用该管道处理每个请求过程中使用到的服务对象均来源于DI容器.该DI容器不仅为ASP.NET Core框架提供必要的服务,同时作为了应用的服务提供者,依赖注入已经成为了ASP.NET Core应用基本的编程模式.</p><h2 id="服务的注册与消费"><a href="#服务的注册与消费" class="headerlink" title="服务的注册与消费"></a>服务的注册与消费</h2><p>ASP.NET Core中的依赖注入框架中,我们添加的服务注册被保存到通过 <strong>IServiceCollection</strong> 接口表示的集合之中,基于这个集合创建的DI容器体现为 <strong>IServiceProvider</strong>.</p><p>DI框架提供了生产实例的三种生命周期模式,分别为:</p><ul><li><strong>Singleton</strong>:整个应用程序生命周期内单例</li><li><strong>Scoped</strong>:单次服务请求内的单例</li><li><strong>Transient</strong>:每次获取均会产生新的对象</li></ul><p>DI框架注册服务时通常会使用三种方式,分别为:</p><ul><li>指定注册非服务类型和实现类型.</li><li>指定一个现有的服务实例.</li><li>指定一个创建服务实例的委托对象.</li></ul><p>当我们在进行服务注册时,可以为同一类型添加一个服务注册,也可以添加多个,实际上添加的所有服务注册都是有效的,在完成服务注册之后，我们调用IServiceCollection接口的扩展方法  <strong>BuildServiceProvider</strong>创建出代表DI容器的IServiceProvider对象,并利用它调用后者的<strong>GetService<T><strong>方法来提供相应的服务实例,总时会返回一个服务实例,这里采用了”后来居上”的原则,即总是采用最近添加的服务注册来创建服务实例.如果我们调用另一个扩展方法</strong>GetServices<T></T></T></strong>,它将利用返回所有服务注册提供的服务实例.如下所示的代码片段.</p><p><img src="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/DI1.jpg" alt="alt"></p><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p>IServiceProvider之间的层次结构造就了三种不同的生命周期模式：由于Singleton服务实例保存在作为根容器的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。Scoped服务实例被保存在当前IServiceProvider上，所以它只能在当前IServiceProvider对象的“服务范围”保证的单例的。没有实现IDisposable接口的Transient服务则采用“即用即取，用后即弃”的策略。</p><p>接下来我们通过简单的实例来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表DI容器的IServiceProvider对象之后，我们调用其CreateScope方法创建了两个所谓的“服务范围”，后者的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。</p><pre><code>//根节点的ServiceProvidervar root = new ServiceCollection()        .AddTransient&lt;IFoo, Foo&gt;()        .AddScoped&lt;IBar&gt;(_ =&gt; new Bar())        .AddSingleton&lt;IBaz, Baz&gt;()        .BuildServiceProvider();//子节点的ServiceProvidervar provider1 = root.CreateScope().ServiceProvider;var provider2 = root.CreateScope().ServiceProvider;void GetServices&lt;TService&gt;(IServiceProvider provider)&#123;    provider.GetService&lt;TService&gt;();    provider.GetService&lt;TService&gt;();&#125;GetServices&lt;IFoo&gt;(provider1);GetServices&lt;IBar&gt;(provider1);GetServices&lt;IBaz&gt;(provider1);Console.WriteLine();GetServices&lt;IFoo&gt;(provider2);GetServices&lt;IBar&gt;(provider2);GetServices&lt;IBaz&gt;(provider2);输出:Foo Foo Bar Baz     Foo Foo Bar</code></pre>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc模式对应的几种设计模式</title>
      <link href="/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ioc原则对应的几种设计模式"><a href="#Ioc原则对应的几种设计模式" class="headerlink" title="Ioc原则对应的几种设计模式"></a>Ioc原则对应的几种设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IoC仅仅是一种设计原则,针对IoC的设计原则有多种设计模式,例如:模板方法,简单工厂,抽象工厂等.以下通过这三种设计模式阐述如何实现IoC设计原则的.</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据按照预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。</p><p>所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供一组相关的对象。</p><p>具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。</p><h2 id="依赖注入-DI容器"><a href="#依赖注入-DI容器" class="headerlink" title="依赖注入(DI容器)"></a>依赖注入(DI容器)</h2><p>DI:Dependency Injection.含义为依赖注入.DI是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。</p><p>在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供所需的每一个服务实例。<br>我们将这个被框架用来提供服务的容器称为“DI容器”.</p><p>从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。依赖注入主要有三种方式:[构造器注入]  [属性注入] [方法注入]</p><h3 id="Service-Locator"><a href="#Service-Locator" class="headerlink" title="Service Locator"></a>Service Locator</h3><p>假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器，那么我们可以采用如下两种方式(ServiceProvider和ServiceLocator)来定义这个服务类型Foo.</p><pre><code>public class Foo : IFoo&#123;    public IBar Bar &#123; get; &#125;    public IBaz Baz &#123; get; &#125;    //方式一:通过构造器注入,通过框架生成服务实例    public Foo(IBar bar, IBaz baz)    &#123;        Bar = bar;        Baz = baz;    &#125;      public async Task InvokeAsync()    &#123;        await Bar.InvokeAsync();        await Baz.InvokeAsync();    &#125;&#125;public class Foo : IFoo&#123;    public Cat Cat &#123; get; &#125;    public Foo(Cat cat) =&gt; Cat = cat;     public async Task InvokeAsync()    &#123;        //方式二:Service Locator,主动去获取服务实例        await Cat.GetService&lt;IBar&gt;().InvokeAsync();        await Cat.GetService&lt;IBaz&gt;().InvokeAsync();    &#125;&#125;</code></pre><p>以上两种方式虽然都解决了针对服务的解耦问题,但是第二种使用方式不能称之为”依赖注入”,而是一种被称为”Service Locator”的设计模式.Service Locator模式同样具有一个通过服务注册创建的全局容器来提供所需的服务实例,该容器被称为”Service Locator”.DI容器和Service Locator实际上是同一事物在不同设计模型的不同称谓罢了.DI容器和Service Locator之间的差异体现在 <strong>“被谁使用”</strong>.DI容器的使用者是框架自身,Service Locator的使用者是应用程序.一般情况下我们尽可能通过构造器注入的方式使用,尽量不要使用Service Locator模式.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core IoC</title>
      <link href="/2019/10/19/Asp.NetCoreIoC/"/>
      <url>/2019/10/19/Asp.NetCoreIoC/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-IOC模式"><a href="#Asp-Net-Core-IOC模式" class="headerlink" title="Asp.Net Core IOC模式"></a>Asp.Net Core IOC模式</h1><p>本系列文章来源于大内老A的博客,对博客内容进行了略微整理,方便自己以后查阅.</p><h2 id="IoC名词解释"><a href="#IoC名词解释" class="headerlink" title="IoC名词解释"></a>IoC名词解释</h2><p>IoC全名为Inverse of Control,含义为”控制倒置”,针对软件设计行业来说,IoC所谓的控制其实是”针对流程的控制”.控制权原来在应用程序,应用程序可以根据自己的场景定义流程,而IoC原则主张流程的控制权转移到框架中,由框架来定义流程的步骤,我们可以通过下图来说明控制权的转移过程.</p><p><img src="/2019/10/19/Asp.NetCoreIoC/IOC1.jpg" alt="alt"></p><h2 id="流程定制"><a href="#流程定制" class="headerlink" title="流程定制"></a>流程定制</h2><p>我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制.作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。</p><p>我们可以说得更加宽泛点。如下图所示我们将一个泛化的工作流程（A=&gt;B=&gt;C）被定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。 </p><p><img src="/2019/10/19/Asp.NetCoreIoC/IOC2.jpg" alt="alt"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一方面IoC对框架的流程进行了封装,消费者只需要执行,框架利用引擎驱动整个流程的运转,应用程序无须关心该工作流程的细节,只需要启动引擎即可.另一方面,框架会提供一系列的扩展点,应用程序则通过定义扩展的方式实现对流程某个环节的定制,在引擎启动前,应用程序将所需的扩展注册到框架中,一旦引擎被正常启动,这些注册的扩展会自动参与到整个流程的执行过程中.这样就实现了框架对流程的高度复用和扩展.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google开发者工具使用指南</title>
      <link href="/2019/09/18/google%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/09/18/google%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="google开发者工具使用指南"><a href="#google开发者工具使用指南" class="headerlink" title="google开发者工具使用指南"></a>google开发者工具使用指南</h1>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript学习笔记</title>
      <link href="/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h2><ul><li>ECMAScript:由ECMA-262定义,提供核心语言功能</li><li>文档对象模型(DOM):提供访问和操作网页内容的方法和接口</li><li>浏览器对象模型(BOM):提供与浏览器交互的方法和接口</li></ul><h2 id="变量-作用域和内存问题"><a href="#变量-作用域和内存问题" class="headerlink" title="变量 作用域和内存问题"></a>变量 作用域和内存问题</h2><p>JavaScript的变量与其他语言有很大区别.不存在定义某个变量必须要保存何种数据类型值的规则,变量的值以及数据类型可以在脚本的生命周期内改变.</p><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li><p>从一个变量向另一个变量赋值基本类型的值,会在变量对象上创建一个新值,然后把该值赋值带为新变量分配的位置上.</p></li><li><p>当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份跟放到为新变量分配的空间中,不同的是,这个值的副本实际上是一个指针.而这个指针指向存储在堆内存中的一个对象.</p></li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>Js中所有函数的参数都是按值传递的.不同的是,对于基本类型的值来说,被传递的值会复制给一个局部变量.对于引用类型的值,会把这个值在内存中的地址复制给一个局部变量.<strong>因此这个局部变量的变化会反映在函数的外部</strong>.</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>检测基本数据类型,通常使用typeof操作符,换句话说,typeof操作符是确定一个变量是字符串,数字,布尔值还是undefined的最佳工具.</li><li>检测引用类型,通常使用instanceof操作符.语法如下:<br><code>result = variable instanceof constructor</code></li></ul><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>JavaScript函数不介意传递进来多少个参数,也不在乎传进来参数是什么类型,即使定义的函数只接受两个参数,调用时也未必要传递两个参数,原因是JavaScript函数的参数在函数内部用一个arguments对象来表示.</p><ul><li><p>参数个数</p><p> 当实参比函数声明指定的形参要少,剩下的形参都将设置为undefined,通常会使用逻辑或(||)来判断参数是否有值来给变量设置默认值.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(x,y)&#123;</span><br><span class="line">    x = x||1;</span><br><span class="line">    y = y||2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(3);</span><br></pre></td></tr></table></figure></li><li><p>对象参数</p><p> 当函数中需要传递多个参数时,一般会使用对象参数的方式,通过键/值对的形式传递参数,这样参数的顺序就无关紧要了.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net 请求webservice接口</title>
      <link href="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="C-调用webservice接口"><a href="#C-调用webservice接口" class="headerlink" title="C#调用webservice接口"></a>C#调用webservice接口</h2><p>由于项目需要调用第三方的webservice接口,以前没有接触过webservice相关知识,故在此记录下来备忘.下边通过webservice天气预报接口为例.简单介绍下如何在.NET项目中调用外部webservice.</p><p>1.项目中添加”服务引用”.如下图:<br>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice1.jpg" alt="alt"></p><p>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice2.jpg" alt="alt"></p><p>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice3.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> .net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .net </tag>
            
            <tag> Webservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记整理</title>
      <link href="/2017/02/22/css/"/>
      <url>/2017/02/22/css/</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>css有三种样式嵌入方式，分别为内联，嵌入，外部引用，一般情况下优先级为内联样式表&gt;嵌入样式表&gt;外部样式表，前提是外部引用css文件在嵌入的前边，如果外部引用在嵌入的后边那么外部引用的优先级将高于嵌入的。简而言之，css优先级是以离标签的距离为依据的。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>取所有选择器所选择元素的并集，然后集中设置样式，语法为在每个选择器中间加上逗号，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1,selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>给所有选择器选中的标签中，相交的那部分标签设置属性。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1Selecotr2&#123;</span><br><span class="line">   属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：Selector1和selector2之间没人任何符号也没有空格。</em></p><span id="more"></span><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>给指定选择器后面紧跟的那个选择器中的标签设置属性，必须是第一个选择器后边紧跟的第一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1+Selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>给指定选择器后面的所有选择器选中的所有标签设置属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1~Selector2&#123;</span><br><span class="line">  属性：值;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><p>selector1:first-child  选中selector1同级别中的第一个元素，如果是selector1对应的元素则选中，否则无法选中任何元素。<br>selector1:last-child 选中同级别中的最后一个标签，如果该标签是Selector1对应的元素，则选中,否则无法选中任何元素。<br>selector1:nth-child(n)选中同级别中的第N个元素，如果该元素是选择器1对应标签则选中<br>selector1:nth-last-child(n)倒数第N个。<br>selector1:only-child选中父元素中唯一的元素。</p><p>selector1:first-of-type 选中同级别中同类型的第一个元素<br>selector1:last-of-type  选中同级别中同类型的最后一个元素<br>selector1:nth-of-type(n) 取出同级别同类型的第N个元素，<br>selector1:nth-last-of-type(n) 同级别同类型倒数第N个元素<br>selector1:only-of-type 选中父元素中唯一类型的元素</p><p>selector1:nth-child(odd) 奇数选择器<br>selector1:nth-child(even) 偶数选择器<br>selector1:nth-child(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><p>selector1:nth-of-type(odd) 奇数选择器<br>selector1:nth-of-type(even) 偶数选择器<br>selector1:nth-of-type(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p><strong>[attribute]:</strong> 根据指定的属性名称找到对应的标签<br>**[attribute=value]:**找到有指定属性，并且属性的取值等于value的标签，常见的应用场景用于区分input属性。例如：Input[type=text]<br>**[attribute^=value]:**属性值以value开头的元素 CSS3( [attribute|=value] css2)<br>**[attribute$=value]:**属性值以value结尾的<br>**[attribute*=value]:**属性值包含value css3([attribute~=value] css2)</p><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1.继承性"></a>1.继承性</h3><p>给父元素设置一些属性，子元素以及后代元素都可以使用，这个我们称之为继承性。并不是所有的属性都可以集成，<strong>只有以color/font-/text-/line开头的属性才可以继承。</strong><br><strong>注意：</strong>CSS继承性中的特殊性：a标签的颜色及样式不可以继承;h标签的字体大小不能继承。<br><strong>应用：</strong>一般用于设置网页上的一些共性信息，例如网页的文字颜色，文字大小等内容，一般在body{}中进行统一设置</p><h3 id="2-层叠性"><a href="#2-层叠性" class="headerlink" title="2.层叠性"></a>2.层叠性</h3><p>在样式表现时，有可能会出现两个或更多的样式寻找同一元素，这就可能出现表现层的不确定性和样式冲突，CSS通过“层叠”给每个规则分配一个重要度。</p><h3 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3.优先级"></a>3.优先级</h3><p><strong>1&gt;</strong>     是否是直接选中（间接选中就是指继承）,如果是间接选中，那么谁离目标比较近就取谁的值。</p><p><strong>2&gt;</strong>     如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级层叠，具体优先级为:<strong>id&gt;class&gt;标签&gt;通配符(*)&gt;继承&gt;浏览器默认。</strong></p><p><strong>3&gt;</strong>     如果都是直接选中，并且都是同类型的选择器，那么谁写的靠后取谁的值。</p><p><strong>4&gt;</strong>     !important 用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级提升为最高，!important 只能用于直接选中，不能用于间接选中，!important的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">  属性:值!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5&gt;</strong>     <strong>优先级的权重</strong>:当多个选择器混合在一起使用时，可以通过计算权重来判断谁的优先级最高。权重的计算规则：首先计算选择器中有多少个id，id多的选择器优先级最高；如果id个数一样，那么再看类名的个数，类名多个优先级高；如果类名个数一样，那么标签名个数多的优先级高；如果都一样，那么谁的位置靠后，取谁的值。</p><h2 id="CSS属性值"><a href="#CSS属性值" class="headerlink" title="CSS属性值"></a>CSS属性值</h2><h3 id="1-文本属性"><a href="#1-文本属性" class="headerlink" title="1.文本属性"></a>1.文本属性</h3><h4 id="1-1-中文字间距-字母间距-单词间距"><a href="#1-1-中文字间距-字母间距-单词间距" class="headerlink" title="1.1 中文字间距 字母间距  单词间距"></a>1.1 中文字间距 字母间距  单词间距</h4><p>1）Letter-spacing用来设置中文字间距和字母间距。<br>2）word-spacing 用来设置英文单词的间距。</p><h4 id="1-2-text-align"><a href="#1-2-text-align" class="headerlink" title="1.2 text-align"></a>1.2 text-align</h4><p><code>text-align：center</code>可以设置块级元素内文本和图片的水平居中<br><strong>注：内联元素之间的间距是由于换行导致的。</strong></p><h4 id="1-3-font"><a href="#1-3-font" class="headerlink" title="1.3 font"></a>1.3 font</h4><h5 id="1-3-1-font字体大小单位"><a href="#1-3-1-font字体大小单位" class="headerlink" title="1.3.1 font字体大小单位"></a>1.3.1 font字体大小单位</h5><p>font属性简写至少要包含 font-family 和font-size属性。如：font：12px “微软雅黑”;<br>Em值的大小是以当前文档中font-size的大小为参考点的，果font-size为16px，则1em = 16px，如果font-size为20px则1em = 20px。<br>特殊情况：当给font-size取值以em为单位时，则此时计算的标准是以父元素font-size为基础的。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*css:*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  p&#123;font-size:14px&#125;</span><br><span class="line">  span&#123;font-size:0.8em;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html:*/</span><br><span class="line">  &lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-3-2-中文英文单独设置字体"><a href="#1-3-2-中文英文单独设置字体" class="headerlink" title="1.3.2 中文英文单独设置字体"></a>1.3.2 中文英文单独设置字体</h5><p>  中文字体里边都包含了英文，英文字体里边没有包含中文，也就是说中文字体可以处理英文，而英文字体不能处理中文，所以如果想要中英文分别单独设置字体，需要采用以下格式：<br>Font—family:”Times New Roman”,”微软雅黑”,将英文字体写在前边，中文字体写在后边作为备选方案。<br>常用字体 中文：宋体/黑体/微软雅黑 英文：Times New Roman / Arial</p><h4 id="1-4-文本垂直居中"><a href="#1-4-文本垂直居中" class="headerlink" title="1.4 文本垂直居中"></a>1.4 文本垂直居中</h4><p>文字在行高中默认是垂直居中的，我们经常将盒子的高度和行高设置一样，那么这样就可以保证单行文字在盒子中是垂直居中的，简而言之：要想单行文字在盒子中垂直居中，那么只需要设置line-height为盒子的height值即可。</p><h5 id="1-4-1-单行文本的垂直居中"><a href="#1-4-1-单行文本的垂直居中" class="headerlink" title="1.4.1 单行文本的垂直居中"></a>1.4.1 单行文本的垂直居中</h5><p>通过设置父元素的height和line-height高度一致来实现，(height该元素的高度，line-height：顾名思义，行高 指在文本中，行与行基线间的距离)，line-height与font-size的计算值之差，在css中称为行间距，分为两半，分别加到一个文本行内容的顶部和底部。</p><h5 id="1-4-2-多行文本及图片的垂直居中"><a href="#1-4-2-多行文本及图片的垂直居中" class="headerlink" title="1.4.2 多行文本及图片的垂直居中"></a>1.4.2 多行文本及图片的垂直居中</h5><p><strong>方法一：</strong><br>使用插入 table  (包括tbody、tr、td)标签，同时设置 vertical-align：middle。<br>css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*Html*/</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    height:300px;</span><br><span class="line">    background:#ccc;</span><br><span class="line">    display:table-cell;/*IE8以上及Chrome、Firefox*/</span><br><span class="line">    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-文本在容器中自动换行"><a href="#1-5-文本在容器中自动换行" class="headerlink" title="1.5 文本在容器中自动换行"></a>1.5 文本在容器中自动换行</h4><p><code>word-break:break-all;</code> 例如div宽200px，它的内容就会到200px自动换行，如果该行末端有个英文单词很长（congratulation等），它会把单词截断，变成该行末端为conra(congratulation的前端部分)，下一行为tulation（conguatulation）的后端部分了。</p><p> <code>word-wrap:break-word;</code> 例子与上面一样，但区别就是它会把congratulation整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断掉的。</p><h3 id="2-background"><a href="#2-background" class="headerlink" title="2. background"></a>2. background</h3><p><code>background-image:url();</code>设置元素背景图片</p><p><code>background-repeat</code>: repeat(默认) repeat-x repeat-y no-repeat</p><p><code>background-position:</code>水平方向 垂直方向;有两种取值方式，分别为具体的方位名词和像素如下：<br>具体的方位名词：水平方向(left center right),垂直方向(top center bottom)<br>具体的像素:浏览器的XY坐标系，X轴向右为正，Y轴向下为正。</p><p><code>background-attachment:fixed</code>(不会随着滚动条滚动)、 scroll(默认取值)</p><p><strong>背景属性缩写的格式:background:background-color  background-image  background-repeat background-attachment  Backgroud-position</strong></p><h3 id="3-CSS-Reset"><a href="#3-CSS-Reset" class="headerlink" title="3.CSS Reset"></a>3.CSS Reset</h3><p>在实际项目开发中我们经常需要清空浏览器给元素设置的默认值，常见的比如margin padding等，在百度中查找YUI CSS Reset或者输入网址:<br><strong><a href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css</a></strong><br>复制其中的内容，粘贴进我们项目的reset.css文件即可。</p><h3 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h3><h4 id="4-1-box-sizing"><a href="#4-1-box-sizing" class="headerlink" title="4.1 box-sizing"></a>4.1 box-sizing</h4><p>盒子元素的宽度 = border-left+padding-left+content-width+padding-right+border-right<br>盒子元素的高度 =border-top+padding-top+content-height+padding-bottom+border-bottom<br>因此假如一个DIV的初始大小为100px*100px，那么加入border或者padding会改变盒子元素自身的大小，从而影响整个网页的布局，如果需要盒子的宽高保持不变，那么需要相应的减少内容的大小，我们可以通过设置属性：<br><code>box-sizing:border-box;</code>,让其自动适应，保持宽高不变。</p><h4 id="4-2-margin"><a href="#4-2-margin" class="headerlink" title="4.2 margin"></a>4.2 margin</h4><p>Margin穿透现象：如果两个盒子是嵌套关系，那么设置内部盒子的margin-top值，外部盒子的margin-top值会被改变，这种情况我们称之为margin穿透现象。解决办法有两种：<br><strong>1)</strong>  给外边的盒子设置边框。<br><strong>2)</strong>     控制嵌套关系盒子之间的距离，首先应该考虑外边盒子的padding属性，其次考虑内层盒子的margin属性。<br><strong>3)</strong>  <code>overflow:hidden;</code></p><h4 id="4-3-块级元素水平居中"><a href="#4-3-块级元素水平居中" class="headerlink" title="4.3 块级元素水平居中"></a>4.3 块级元素水平居中</h4><p>在嵌套关系的盒子中，我们可以通过设置内层盒子的<code>margin:0 auto;</code>让内层盒子在外边的盒子水平居中，margin的auto取值只对水平方向上有效，对垂直方向上是无效的。</p><h3 id="5-浮动流"><a href="#5-浮动流" class="headerlink" title="5.浮动流"></a>5.浮动流</h3><p><strong>1&gt;</strong> 浮动流不区分 块级元素/行内元素/行内块级元素，无论块级元素/行内元素/行内块级元素都可以水平排版。<br><strong>2&gt;</strong> <strong>浮动流中无论块级元素/行内元素/行内块级元素都可以设置宽高。</strong><br><strong>3&gt;</strong> <strong>当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。</strong><br>**4&gt;**设置浮动后，盒子的margin属性不会失效。<br><strong>5&gt;</strong> 浮动元素贴靠现象<br>如果父元素的宽度能够显示所有浮动元素, 那么浮动的元素会并排显示; 如果父元素的宽度不能显示所有浮动元素, 那么会从最后一个元开始往前贴靠, 如果贴靠了前面所有浮动元素之后都不能显示, 最终会贴靠到父元素的左边或者右边。<br>**6&gt;**浮动元素字围现象<br>浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象。</p><h3 id="6-清除浮动"><a href="#6-清除浮动" class="headerlink" title="6.清除浮动"></a>6.清除浮动</h3><p><strong>方式一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box1::after&#123;</span><br><span class="line">  Content:&quot;&quot;</span><br><span class="line">  Display:block;</span><br><span class="line">  Height:0;</span><br><span class="line">  Visibility:hidden;</span><br><span class="line">  Clear:both;</span><br><span class="line">&#125;</span><br><span class="line">/*这种方式在IE6中显示不正常，需要加入额外的属性*/</span><br><span class="line">.box1&#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><pre><code>overflow:hidden;</code></pre><p><strong>注：Overflow:hidden属性的作用有以下几点：</strong><br>        **1.**将超出标签范围的内容才减掉。<br>        **2.**清除浮动。内部盒子浮动后，外部盒子的高度无法被撑起，会缩成一条，这时候对父元素使用clear：both是无法清除浮动的影响的，需要设置overflow：hidden才行。<br>       <strong>3</strong>.外部盒子设置overflow：hidden；保证了内部盒子在设置了margin-top属性后外部盒子的margin-top不会发生变化。</p><h3 id="7-定位流"><a href="#7-定位流" class="headerlink" title="7.定位流"></a>7.定位流</h3><p>定位流分为：相对定位、绝对定位、固定定位、静态定位四种类型。</p><h4 id="7-1-相对定位"><a href="#7-1-相对定位" class="headerlink" title="7.1 相对定位"></a>7.1 相对定位</h4><p>相对定位就是相对于自己以前在标准路中的位置作为参考点进行移动，语法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position：relative；</span><br><span class="line">Top:</span><br><span class="line">Bottom:</span><br><span class="line">Left:</span><br><span class="line">Right:</span><br></pre></td></tr></table></figure><p><strong>1&gt;</strong>    相对定位不会脱离标准流，会继续在标准流中占用一份空间。<br>**2&gt;**在相对定位中同一个方向上的定位属性只能使用一个。<br><strong>3&gt;</strong>    由于相对定位是不脱离标准流的，所以相对定位中区分块级 行内 行内块级元素。<br>**4&gt;**给设置相对定位的元素设置margin属性，是给元素以前的位置设置margin，并不是给定位之后的元素设置margin。</p><h4 id="7-2-绝对定位"><a href="#7-2-绝对定位" class="headerlink" title="7.2 绝对定位"></a>7.2 绝对定位</h4><p>**1&gt;**绝对定位的元素是脱离标准流的<br>**2&gt;**绝对定位中是不区分行内 块级 行内块级元素<br>**3&gt;**参考点：默认情况下所有的绝对定位元素，无论是否有祖先元素，对会以body 作为参考点；<br>  &nbsp;  &nbsp; &nbsp;      a. 如果一个绝对定位有祖先元素，并且这个祖先元素也是定位流，并且这个定位流只能是：绝对定位、相对定位、固定定位。那么这个绝对定位的元素会以这个祖先元素作为参考点。<br>   &nbsp;  &nbsp; &nbsp;      b. 如果绝对定位有多个祖先元素，并且多个祖先元素均为定位流，那么这个绝对定位的元素会以离他最近的元素为参考点。<br>**4&gt;**如果一个绝对定位的元素以body为参考点，其实是以网页首屏宽度为参考点，而不是以整个网页的宽度和高度为参考点。<br><strong>5&gt;</strong> 绝对定位的元素会忽略祖先元素的padding值。</p><h4 id="7-3-子绝父相"><a href="#7-3-子绝父相" class="headerlink" title="7.3 子绝父相"></a>7.3 子绝父相</h4><p>这是通常情况下设置绝对定位元素的方式，将要设置绝对定位元素的父元素设置为相对定位，然后自身设置为绝对定位，那么久会以父元素作为参照点进行偏移，俗称“子绝父相”.<br>如何让绝对定位的元素在父元素中水平居中，只需要设置绝对定位元素的left：50%，然后再设置绝对定位的元素margin-left，负的元素宽度的一半px; </p><h4 id="7-4-不定宽块级元素水平居中"><a href="#7-4-不定宽块级元素水平居中" class="headerlink" title="7.4 不定宽块级元素水平居中"></a>7.4 不定宽块级元素水平居中</h4><p>通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*Html代码*/</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    left:50%</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container ul&#123;</span><br><span class="line">    list-style:none;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    </span><br><span class="line">    position:relative;</span><br><span class="line">    left:-50%;</span><br><span class="line">&#125;</span><br><span class="line">.container li&#123;float:left;display:inline;margin-right:8px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-3-固定定位"><a href="#7-3-固定定位" class="headerlink" title="7.3 固定定位"></a>7.3 固定定位</h4><p> 固定定位：可以让某个盒子不随着网页滚动条而滚动。<br>固定定位的元素是脱离标准流的，不会占用标准流的空间，固定定位和绝对定位一样不区分行内/块级 /行内块级元素。<br><strong>注：IE6不支持position：fixed.</strong></p><h4 id="7-4-z-index"><a href="#7-4-z-index" class="headerlink" title="7.4 z-index"></a>7.4 z-index</h4><p>默认情况下，所有设置了position属性的元素都有一个Z-index属性，默认取值为0，z-index属性的作用是专门用于控制定位流元素的覆盖关系的。</p><p>1&gt;默认情况下定位流的元素会盖住标准流的元素。<br>2&gt;定位里的元素后面编写的会盖住前面编写的元素。<br>3&gt;如果定位流的元素设置了z-index属性，那么谁的z-index属性大，谁就显示在上面。</p><p><strong>从父现象：</strong><br>如果两个元素的父元素都没有设置z-index属性，那么谁的z-index属性大就显示在上面</p><p>如果两个元素的父元素设置了z-index属性，那么他们自身的z-index属性将失效。</p><h4 id="7-5-隐形改变display类型"><a href="#7-5-隐形改变display类型" class="headerlink" title="7.5 隐形改变display类型"></a>7.5 隐形改变display类型</h4><p>当元素设置一下两个句之一：</p><ol><li>   position:ablsolute</li><li>   float:left或right<br>简单来说，只要html代码中出现以上两句之一，元素的display显示类型就自动变为display：inline-block的方式，当然就可以设置元素的width和height了，<strong>且默认宽度不占满父元素</strong>。</li></ol><h3 id="8-a标签伪类选择器"><a href="#8-a标签伪类选择器" class="headerlink" title="8 .a标签伪类选择器"></a>8 .a标签伪类选择器</h3><p>:link 修改从未被访问过状态下的样式<br>:visited 修改被访问过的状态下的样式<br>:active 修改鼠标长按状态下的样式<br>:hover 修改鼠标悬停在a标签上的状态</p><p>注意点：a标签的伪类选择器一起出现，那么有严格的顺序要求，必须按照这个顺序：<br><em><strong>link  visited  hover  active</strong></em></p><h3 id="9-CSS3圆角"><a href="#9-CSS3圆角" class="headerlink" title="9.CSS3圆角"></a>9.CSS3圆角</h3><p>Border-radius是向元素添加圆角边框。使用方式：<br><code>Border-radius:10px;</code>   /<em>所有角都使用半径为10px的圆角</em>/<br><code>Border-radius:5px 4px 3px 2px;</code>四个半径值分别对应左上、右上、右下、左下</p><p><strong>1.实心上半圆</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:50px;/*是width的一半*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实心圆</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:100px;/*与width设置一致*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="10-盒子边框阴影"><a href="#10-盒子边框阴影" class="headerlink" title="10.盒子边框阴影"></a>10.盒子边框阴影</h3><p>Box-shadow是向盒子添加阴影，支持添加一个或多个，如果需要添加多个阴影只需要用逗号隔开即可。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box-shadow:X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</span><br></pre></td></tr></table></figure><p><strong>X轴偏移量：</strong> 必选参数，值可以正负，正值表示向右偏移，负值向左<br><strong>Y轴偏移量：</strong> 必选参数，值可以正负，正值表示向下偏移，负值向上。<br><strong>阴影模糊半径：</strong> 可选参数，值只能为正，如果值为0，代表阴影没有模糊效果。<br><strong>阴影扩展半径：</strong> 可选参数，值可以为正负，越大阴影面积越大。<br><strong>投射方式：</strong> 其中投影方式默认为外阴影方式，可以设置为inset让其显示为内部阴影。</p><h3 id="11-实现双列布局一列固定宽度，另外一列自适应的方式。"><a href="#11-实现双列布局一列固定宽度，另外一列自适应的方式。" class="headerlink" title="11. 实现双列布局一列固定宽度，另外一列自适应的方式。"></a>11. 实现双列布局一列固定宽度，另外一列自适应的方式。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*HTML*/</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*CSS*/</span><br><span class="line">.main&#123;</span><br><span class="line">width:100%;</span><br><span class="line">height:300px;</span><br><span class="line">background:darkred;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left&#123;</span><br><span class="line"> width:200px;</span><br><span class="line"> height:300px;</span><br><span class="line"> background:blue;</span><br><span class="line"> position:absolute;</span><br><span class="line"> left:0px;</span><br><span class="line"> top:0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right&#123;</span><br><span class="line">margin-left:210px;</span><br><span class="line">height:300px;</span><br><span class="line">background:orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html学习笔记整理</title>
      <link href="/2017/02/22/html/"/>
      <url>/2017/02/22/html/</url>
      
        <content type="html"><![CDATA[<h2 id="引用标签"><a href="#引用标签" class="headerlink" title="引用标签"></a>引用标签</h2><p>引用标签会自动对其中的内容加入双引号，有单行文本和长段文本两种方式：</p><pre><code>&lt;q&gt;引用标签&lt;/q&gt; //适用单行文本&lt;blockquote&gt;引用标签&lt;/blockquote&gt; //长段文本</code></pre><h2 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h2><p>在html中输入多个空格是不起作用的，并且换行也会被当做一个空格来看待，如果需要多个空格请使用实体字符，如:<code>&amp;nbsp;</code></p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><pre><code>&lt;address&gt;地址&lt;/address&gt; //显示地址</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>&lt;code&gt;代码&lt;/code&gt;  //显示程序代码&lt;pre&gt;大段代码&lt;/pre&gt; //显示大段代码</code></pre><h2 id="表格摘要"><a href="#表格摘要" class="headerlink" title="表格摘要"></a>表格摘要</h2><p>  摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：</p><pre><code>&lt;table summary=&quot;表格简介文本&quot;&gt;&lt;/table&gt;</code></pre><h2 id="使用mailto在网页中连接Email地址"><a href="#使用mailto在网页中连接Email地址" class="headerlink" title="使用mailto在网页中连接Email地址"></a>使用mailto在网页中连接Email地址</h2><pre><code>&lt;a href=&quot;mailto:yy@imooc.com?subject=&#39;观了不起的盖茨比有感&#39;&amp;body=&#39;你好，对此评论有些想法&#39;&quot;&gt;发送邮件给我&lt;/a&gt;</code></pre><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>用于绑定input在用户点击label标签的文字后即可聚焦input，有两种绑定方式。<br><strong>方式一:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">     &lt;label for=”account”&gt;账号&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text”  id=”account”/&gt;</span><br><span class="line">     &lt;label for=”pwd”&gt;密码&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text” id=”pwd”&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  账号:&lt;input type=”text”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  密码:&lt;input type=”password”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="HTML5-DTD文档类型声明"><a href="#HTML5-DTD文档类型声明" class="headerlink" title="HTML5 DTD文档类型声明"></a>HTML5 DTD文档类型声明</h2><pre><code>&lt;!DOCTYPE html&gt; //必须位于html文档的第一行</code></pre><span id="more"></span><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p>**width:**设置图片的宽度</p><p><strong>height：</strong>设置图片的高度</p><p><em>注： 如果img标签没有指定需要显示的图片的宽高，那么系统会按照图片默认的宽高来显示。想要保持img图片原图的宽高比，只需要设置img宽度和高度其中之一，另外一个属性会根据原图的宽高比自动计算得出。</em></p><p>**title:**当鼠标悬停在图片上时，弹出的描述狂中显示的内容。</p><p>**alt(alternate):**当需要显示的图片找不到时，显示的替代的文字内容。</p><h2 id="br"><a href="#br" class="headerlink" title="br"></a>br</h2><p>&nbsp;&nbsp;&nbsp;br标签用于换行，多个br标签可以连续使用，使用了多少个br标签就会换多少行，由于html的作用就是给文本添加语义，而br标签的语义是不另起一个段落换行，而在企业开发中一般情况下需要换行都是因为需要另起一个段落，所以在企业开发中很少使用br标签，换行另起段落一般用P标签。</p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p> base标签专门用来统一指定当前网页中所有的a标签的打开方式,base标签必须写在head标签之间,格式为：</p><pre><code>&lt;base target=”_blank”&gt;               //必须位于head之间</code></pre><p><em>注：如果即在base中指定了target又在a标签中指定了target，那么浏览器会按照a标签中指定方式的来执行。</em></p><h3 id="假链接"><a href="#假链接" class="headerlink" title="假链接"></a>假链接</h3><p>为a标签的href属性分配一个#或者JavaScript，以实现特定的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#”&gt;返回顶部&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”javascript:”&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>锚点是文档中某行的一个记号，类似于书签，用于链接到文档中的某个位置。当定义了锚点后，我们可以创建直接跳至该锚点（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 创建锚点需要以下几个步骤：</p><ol><li>给需要定位的目标标签添加一个ID属性。</li><li>告诉a标签你需要转到的目标标签。</li><li>格式：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#target”&gt;跳转到目标&lt;/a&gt;</span><br><span class="line">&lt;h1 id=”target”&gt;我是目标&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><em>注：使用这种方式跳转是没有过渡动画的，一下就跳转到了指定位置  a标签除了可以跳转到当前界面的指定位置，还可以直接跳转到其他界面的指定位置。</em></p><h2 id="定义列表-dl-definition-list"><a href="#定义列表-dl-definition-list" class="headerlink" title="定义列表 dl(definition list)"></a>定义列表 dl(definition list)</h2><p>常用于网站底部的信息、图文混排等。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;   //definition title 定义列表中的标题</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;  //definition description 定义列表标题的描述</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格摘要-1"><a href="#表格摘要-1" class="headerlink" title="表格摘要"></a>表格摘要</h3><p>摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table summary=”表格简介文本”&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h3><p>表格标题永远处于表格的水平中心位置，语法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;caption&gt;</span><br><span class="line">     &lt;h2&gt;表格标题&lt;/h2&gt;</span><br><span class="line">  &lt;/caption&gt;                 //表格标题</span><br><span class="line">  &lt;thead&gt;&lt;/thead&gt;            //表格头</span><br><span class="line">  &lt;tbody&gt;&lt;/tbody&gt;            //表格内容体</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="细线表格"><a href="#细线表格" class="headerlink" title="细线表格"></a>细线表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  Table&#123;</span><br><span class="line">Padding:0.1px;</span><br><span class="line">Background-Color:steelblue;  //定义边框的颜色</span><br><span class="line">Width:650px;</span><br><span class="line">Height:40px;</span><br><span class="line">Font:16px “微软雅黑”;</span><br><span class="line">Text-align:center;</span><br><span class="line">  &#125;</span><br><span class="line">  Table tr&#123;</span><br><span class="line">    Background-Color:white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h2><p>给input输入框绑定待选项列表，格式如下：<br>先定义一个datalist列表项，给它分配一个唯一的ID “cars”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;datalist  id=”cars”&gt;</span><br><span class="line">    &lt;option&gt;奔驰&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;；路虎&lt;/option&gt;</span><br><span class="line">&lt;option&gt;Jeep&lt;/option&gt;</span><br><span class="line">&lt;option&gt;劳斯莱斯&lt;/option&gt;</span><br><span class="line">&lt;option&gt;宝马&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p>然后给输入框添加一个属性list，值填写刚才定义列表的id值”cars”。<br>请输入你的车型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=”text” list=”cars”/&gt;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>可以通过给option标签添加一个selected属性来制定列表的默认选中项;可以给option进行分组，使用optgroup label标签的名字显示了分组的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line"> &lt;optgroup label=”北京”&gt;</span><br><span class="line"> &lt;option&gt;西城区&lt;/option&gt;</span><br><span class="line"> &lt;option selected=”selected”&gt;朝阳区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;通州区&lt;/option&gt;</span><br><span class="line"> &lt;/optgroup&gt;</span><br><span class="line"> &lt;optgroup label=”广州&gt;</span><br><span class="line"> &lt;option&gt;天河区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;越秀区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;黄浦区&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="textArea"><a href="#textArea" class="headerlink" title="textArea"></a>textArea</h2><p>Textarea通过css的属性resize:none可以禁止用户自由拉伸textarea</p><h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p>**src:**用于告诉video标签需要播放的视频地址。<br><strong>autoplay：</strong>用于告诉video标签是否需要自动播放视频 autoplay = “autoplay”。<br><strong>controls:</strong> 用于告诉video标签是否显示控制条 controls = “controls”。<br><strong>poster:</strong> 用于设置视频在播放之前，显示的图片。<br><strong>loop:</strong> 一般用于广告视频，用于告诉video标签播放完毕后是否需要循环播放。Loop = “loop”。<br><strong>preload:</strong> 预加载视频，但是需要注意preload和autoplay相冲。<br><strong>muted:</strong> 静音   muted = “muted”。<br><strong>width/height：</strong>二者只设置一个，保持视频的宽高比</p><p>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式，但是显然所有浏览器都通过video标签播放视频有一个前提条件，那就是浏览器必须支持H5，可以通过一个JS框架叫做<strong>html5demia</strong>来实现兼容。</p><p>video的第二种格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">&lt;source src=”video/1.webm” type=”video/webm”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/2.mp4” type=”video/mp4”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/3.ogg” type=”video/ogg”&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="marquee"><a href="#marquee" class="headerlink" title="marquee"></a>marquee</h2><p>Marquee标签虽然不是w3c标准的标签，，但是各大浏览器对其支持很好。Marquee标签是一个内联块级元素，主要用于实现类似于跑马灯的效果。格式为：</p><pre><code>&lt;marquee&gt;内容&lt;/marquee&gt;</code></pre><p><strong>direction(left right up down):</strong> 设置内容滚动的方向<br><strong>scrollamount：</strong>设置滚动的速度，值越大越快<br><strong>loop：</strong>设置滚动次数，默认为-1，也就是无限滚动<br><strong>behavior：</strong>设置滚动类型，slide，滚动到边界即停止，alternate，滚动到边界即弹回。</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2017/02/09/blog/"/>
      <url>/2017/02/09/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="http://i1.piimg.com/567571/f63d2030ab646842.png"><br><a href="hexo.io">Hexo</a>是一个快捷、简单、功能强大的个人博客框架，使用Node.js下载与安装，上百个文件仅需几秒就可以安装完毕;Hexo的页面使用Markdown语法，简洁高效;通过简单的命令即可发布到网站，支持发布到GitHub Pages Heroku和其他站点;同时Hexo拥有丰富强大的插件系统，可以根据个人需要进行安装。本文主要针对技术开发人员如何快速的搭建Hexo博客做一个详尽的教程，也是对自己在搭建博客的过程中遇到的问题进行总结，避免以后的小伙伴踩坑。本文从五个方面进行讲解，分别为：</p><ul><li><p>环境部署</p></li><li><p>HEXO安装与常用命令</p></li><li><p>个性化设置</p></li><li><p>HEXO部署Github</p></li><li><p>定制化个性域名</p><span id="more"></span><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h2 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1.Node.js"></a>1.Node.js</h2><p>首先我们需要安装Node.js，点击进入<a href="https://nodejs.org/en/">node.js官网</a>，按照通用的安装方式下载安装即可。Node.js主要用于生成静态界面。</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><p>这里说的git实则是为了使用git指令，我们的git使用一般有两种方式，一种是图形化界面（GUI），另一种是通过命令行，我们这里要使用的是后者，点击<a href="http://git-scm.com/downloads">这里</a>进入git的下载网站下载git的安装包。作用：把本地的hexo内容提交到github上去.</p><h2 id="3-GitHub配置"><a href="#3-GitHub配置" class="headerlink" title="3.GitHub配置"></a>3.GitHub配置</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>如果你没有GitHub账号，请到<a href="https://github.com/">这里</a>进行注册申请，详细注册过程略。</p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p>点击右上角的”+”选择New respository 建立新仓库，如图：<br><img src="http://p1.bqimg.com/567571/b85d00d61646ce19.png"><br>接下来需要配置仓库信息，如图：<br><img src="http://p1.bpimg.com/567571/8ddca7070ac1d6d3.png"><br>这里我们需要填写Repository name，注意这里的命名规范，如果我们要把这个仓库作为我们的个人博客，必须遵照以下规范命名：<strong>github用户名.github.io</strong>,点击Create repository即可。</p><h3 id="生成添加秘钥"><a href="#生成添加秘钥" class="headerlink" title="生成添加秘钥"></a>生成添加秘钥</h3><p>本机生成秘钥是为了方便以后更新博客不用每次都输入用户名密码，这个根据个人需要，不是必须操作。<br>在终端输入：</p><p>  $ ssh-keygen -t rsa -C “Github的注册邮箱地址”<br>待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，这两个文件位于：<br><img src="http://p1.bpimg.com/567571/ab706a277d27e1cd.png"><br>这个目录下，用文本编辑器(notepad++ 、Sublime Text)打开id_rsa.pub这个文件,全选复制里边的内容，然后打开<a href="https://github.com/settings/ssh">网址</a>,如图:<br><img src="http://i1.piimg.com/567571/15b94723da693034.png"></p></li></ul><p>点击 New SSH key:<br><img src="http://i1.piimg.com/567571/efd23501f3d72f7b.png"><br>Title随便起个名字，将刚才复制的内容粘贴进Key中，然后点击Add SSH Key，这样生成的秘钥就添加完毕了，在今后更新博客，不必每次都输入用户名密码验证登录。</p><h3 id="为Hexo安装Git插件"><a href="#为Hexo安装Git插件" class="headerlink" title="为Hexo安装Git插件"></a>为Hexo安装Git插件</h3><p>安装 hexo-deployer-git，否则会报 ERROR Deployer not found: git 的错误。</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>至此，环境全部配置完毕，接下来我们讲Hexo的安装，目录结构与常用命令。</p><h1 id="Hexo安装与常用命令"><a href="#Hexo安装与常用命令" class="headerlink" title="Hexo安装与常用命令"></a>Hexo安装与常用命令</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。执行如下命令安装Hexo：<br>定位blog安装位置：</p><pre><code>$ cd 文件夹路径$ npm install hexo-cli -g</code></pre><p>安装好hexo以后，在终端输入：</p><pre><code>$ hexo</code></pre><p>若出现下图，说明Hexo安装成功：<br><img src="http://i1.piimg.com/567571/fe00cc2a41c9c40b.png"></p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><pre><code>$ hexo init //初始化博客$ npm install //node.js的命令，根据博客的dependencies配置安装所有的依赖包</code></pre><p>完成后我们可以看到Blog文件夹下的文件结构是这样的：<br><img src="http://p1.bqimg.com/567571/cf1c9ba7e9372f95.png"></p><h3 id="主目录结构："><a href="#主目录结构：" class="headerlink" title="主目录结构："></a>主目录结构：</h3><pre><code>主目录1  ├── .deploy       #需要部署的文件2  ├── node_modules  #Hexo插件3  ├── public        #生成的静态网页文件4  ├── scaffolds     #模板5  ├── source        #博客正文和其他源文件，CNAME也放这里6  | ├── _drafts     #草稿7  | ├── _posts      #文章8  ├── themes        #主题9  ├── _config.yml   #全局配置文件10 └── package.json</code></pre><p>我们经常需要操作的目录为source &gt; _post(文章目录),themes(主题目录),config.yml(全局配置文件)。</p><h3 id="主题目录结构："><a href="#主题目录结构：" class="headerlink" title="主题目录结构："></a>主题目录结构：</h3><pre><code>主目录1  ├── languages          #国际化2  |   ├── default.yml    #默认3  |   └── zh-CN.yml      #中文4  ├── layout             #布局5  |   ├── _partial       #局部的布局6  |   └── _widget        #小挂件的布局7  ├── script             #js脚本8  ├── source             #源代码文件9  |   ├── css            #CSS10 |   |   ├── _base      #基础CSS11 |   |   ├── _partial   #局部CSS12 |   |   ├── fonts      #字体13 |   |   ├── images     #图片14 |   |   └── style.styl #style.css15 |   ├── fancybox       #fancybox16 |   └── js             #js17 ├── _config.yml        #主题配置文件18 └── README.md          #主题介绍</code></pre><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><pre><code>$ npm install hexo-cli -g           //安装Hexo$ hexo init                         //初始化博客$ npm install                       //安装依赖包$ hexo server                       //本地启动$ npm update hexo -g                //升级 $ hexo new &quot;文件名&quot;                  //新建文章$ hexo p                            //发布$ hexo generate                     //生成静态文件$ hexo generate -watch              //监视文件变动$ hexo deploy                       //部署$ hexo d -g                         //同上$ hexo g -d                         //同上$ hexo new page &quot;pageName&quot;          //新建页面</code></pre><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><h2 id="配置博客信息"><a href="#配置博客信息" class="headerlink" title="配置博客信息"></a>配置博客信息</h2><p>博客初始化完毕后，我们需要对博客做一些详细的配置信息，以及个性化设置，主要设置的内容有：博客信息，语言、时区、主题样式、博客目录结构、部署设置(deploy)、插件等。</p><h3 id="全局配置文件-config-yml"><a href="#全局配置文件-config-yml" class="headerlink" title="全局配置文件_config.yml"></a>全局配置文件_config.yml</h3><p>使用sublime Text打开根目录下的config.yml文件，首先我们要对站点信息进行设置:</p><h4 id="网站信息："><a href="#网站信息：" class="headerlink" title="网站信息："></a>网站信息：</h4><pre><code># Site        //站点信息title :       //博客名称subtilte:     //副标题description:  //站点描述信息ahthor:       //作者language:     //语言(zh-CN) *重要timezone:     //时区(Asia/Shanghai) *重要</code></pre><p><strong>注意：填写每一项内容时,:后边都要留一个空格再填写内容。</strong></p><h4 id="分页设置："><a href="#分页设置：" class="headerlink" title="分页设置："></a>分页设置：</h4><pre><code># Pagination## Set per_page to 0 to disable paginationper_page:5     //每页显示文章数pagination_dir: page</code></pre><h4 id="主题设置："><a href="#主题设置：" class="headerlink" title="主题设置："></a>主题设置：</h4><pre><code>#  Extensions## Plugins:https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next        //主题名称</code></pre><h4 id="部署设置："><a href="#部署设置：" class="headerlink" title="部署设置："></a>部署设置：</h4><pre><code>deploy:type: git          //类型repo:              //Github仓库地址branch: master     //项目分支，默认使用主分支即master</code></pre><h2 id="设置个性化主题"><a href="#设置个性化主题" class="headerlink" title="设置个性化主题"></a>设置个性化主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>首先找到我们喜欢的<a href="https://hexo.io/themes/">主题</a>，本篇文章以Next主题为例，将终端定位到Blog根目录，将Next主题从github clone到本地。</p><pre><code>$ cd:d/Blog $ git clone https://github.com/iissnan/hexo-theme-next themes/next   </code></pre><p>稍等片刻，Next主题会自动下载到Blog &gt;themes文件夹下。</p><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改config.yml全局配置文件，找到theme字节，修改值为：next</p><pre><code>theme: next</code></pre><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><h4 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h4><p>打开theme &gt; next &gt;_config.yml，定位到menu,hexo博客框架默认有/home 、/archives、/tags三个一级页面。如果我们要增加其他的页面需要对这里的配置文件进行修改。</p><pre><code>menu：  home: /                          //主页(默认打开)  #categories: /categories         //分类  #about: /about                   //关于  archives: /archives              //文章(默认打开)  tags: /tags                      //标签(默认打开)  #sitemap: /sitemap.xml           //站点地图  #commonweal: /404.html           //公益404</code></pre><p>我们需要增加哪个页面只需要把前边的#注释去掉即可。然后在终端中新建刚才添加的页面</p><pre><code>hexo new page &quot;categories&quot;          //这里用categories举例</code></pre><p>编辑站点的source/categories/index.md，添加</p><pre><code>---title: categoriesdate: 2017-02-09 17:52:11type: &quot;categories&quot;             //添加类型comments: false                //禁用评论---</code></pre><p>保存后<code>hexo s</code>,打开<a href="http://localhost:4000/%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/查看效果。</a></p><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>打开themes &gt;next &gt;languages 找到zh-Hans.yml，重命名为zh-CN.yml,或者将全局配置文件_config.yml的languages设置为zh-Hans也可以。</p><h4 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h4><p>定位到menu_icons,这里储存了页面使用的图标信息，Next主题采用了FontAwesome的图标，直接使用FontAwesome的图标名称即可调用对应的图标文件,关于FontAwesome的详细信息点击<a href="http://fontawesome.io/icons/">这里</a>，选择自己喜欢的图标复制名称粘贴即可。</p><pre><code>menu_icons:                    //目录图标配置enable: true                   //是否启用 #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home                    //主页 about: user                   //关于 categories: th                //分类 schedule: calendar            //进度 tags: tags                    //标签 archives: archive             //文章 sitemap: sitemap              //站点地图 commonweal: heartbeat</code></pre><h4 id="Scheme设置"><a href="#Scheme设置" class="headerlink" title="Scheme设置"></a>Scheme设置</h4><pre><code># Scheme Setting# ---------------------------------------------------------------# Schemes#scheme: Muse scheme: Mist#scheme: Pisces</code></pre><p>Next主题提供了三种样式，分别为Muse Mist Pisces，将样式前的#注释去掉即可启用该主题，同时只能启用一个。</p><h4 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h4><p>定位到social_icons，修改配置信息。</p><h4 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h4><p>定位倒sidebar，可以设置侧边栏的显示位置(左右),显示方式等。</p><h4 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h4><p>首先将我们的头像图片copy到themses &gt; next &gt; source &gt;images文件夹下，然后打开next主题下的_config.yml文件，定位到avatar。</p><pre><code>avatar: /images/头像文件名</code></pre><h1 id="Hexo部署GitHub"><a href="#Hexo部署GitHub" class="headerlink" title="Hexo部署GitHub"></a>Hexo部署GitHub</h1>]]></content>
      
      
      <categories>
          
          <category> Blog建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2017/02/08/hello-world/"/>
      <url>/2017/02/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>终于创建好了自己的HEXO博客，这是我的第一篇文章，以后要坚持记录!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
