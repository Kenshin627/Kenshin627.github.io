<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/04/26/Computer-Graphic04-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8B/5/"/>
      <url>/2024/04/26/Computer-Graphic04-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8B/5/</url>
      
        <content type="html"><![CDATA[<h1 id="空间变换-下-Spatial-Transformation"><a href="#空间变换-下-Spatial-Transformation" class="headerlink" title="空间变换-下(Spatial Transformation)"></a>空间变换-下(Spatial Transformation)</h1><p>书接上文,本章我们继续讲变换,上一章介绍了旋转和反射,这章我们开始介绍剩下几种变换:缩放/平移/错切</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h3 id="均匀缩放"><a href="#均匀缩放" class="headerlink" title="均匀缩放"></a>均匀缩放</h3><p>每一个向量被映射到自身与缩放因子的乘积.</p><p>$f(\mathbf{u}) = a\mathbf{u} \ \ \ \ a \in R$</p><p>旋转变换保持变换后向量的模不变,缩放保持方向不变:</p><p>$\frac{\mathbf{u}}{|\mathbf{u}|}  = \frac{a\mathbf{u}}{|a\mathbf{u}|}$</p><p>缩放是线性变换吗?可以用线性变化的代数定义来证明:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ba42699c42434f9eebaf89906e76b3~tplv-k3u1fbpfcp-watermark.image?" alt="1.jpg"><br>通过上图可知,缩放是线性变换!</p><p>矩阵表示:<br>假如我们想用因数$a$缩放向量$\mathbf{u} = (u_{1},u_{2},u_{3})$,我们如何用矩阵来表示该变换?</p><p>用缩放因子$a$构造一个对角矩阵($diagonal \ matrix \ D$)即可:</p><p>$\begin{bmatrix}<br> a &amp; 0 &amp; 0<br> 0 &amp; a &amp; 0 \\<br> 0 &amp; 0 &amp; a<br>\end{bmatrix}\begin{bmatrix}<br> u_{1}\\<br> u_{2}\\<br> u_{3}<br>\end{bmatrix} = \begin{bmatrix}<br> au_{1}\\<br> au_{2}\\<br> au_{3}<br>\end{bmatrix}$</p><h3 id="负数缩放"><a href="#负数缩放" class="headerlink" title="负数缩放"></a>负数缩放</h3><p>如果缩放因子为负,假设$a = -1$,可以把缩放分解为一系列的反射变换.负因子缩放的这种性质在二维和三维中的表现是不同的,因为二维缩放分解为两个反射矩阵的乘积,而三维缩放分解为三个反射矩阵的乘积:</p><p>$\begin{bmatrix}<br> -1 &amp; 0\\<br> 0 &amp; -1<br>\end{bmatrix} = \begin{bmatrix}<br> -1 &amp; 0\\<br> 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0\\<br> 0 &amp; -1<br>\end{bmatrix}$</p><p>对于二维负数缩放,可以将其分解为沿着$Y$轴和$X$轴做两次镜像,两次朝向反转相互抵消,最终面朝向保持不变,本质上这是一次180°的旋转变换.</p><p>$\begin{bmatrix}<br> -1 &amp; 0 &amp; 0 \\<br> 0 &amp; -1 &amp; 0 \\<br> 0 &amp; 0 &amp; -1<br>\end{bmatrix} = \begin{bmatrix}<br> -1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; -1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; -1<br>\end{bmatrix}$</p><p>对于三维负数缩放,可以分解为沿着$Y$轴$X$和$Z$轴做三次镜像,两次抵消一次反转,最终面朝向是反转的.</p><h3 id="非均匀缩放-轴向"><a href="#非均匀缩放-轴向" class="headerlink" title="非均匀缩放(轴向)"></a>非均匀缩放(轴向)</h3><p>上边介绍的几种缩放缩放因子都是统一的,每个轴的缩放系数保持一致,如果每个轴按照不同的因子缩放,该如何去表达呢?</p><p>$f(\mathbf{u_{1}}, \mathbf{u_{2}}, \mathbf{u_{3}}) = (a\mathbf{u_{1}}, b\mathbf{u_{2}}, c\mathbf{u_{3}}) $</p><p>$ a,b,c \in R$</p><p>和均匀缩放矩阵表示一样,只不过在对角线上替换成不同的缩放因子即可:</p><p>$\begin{bmatrix}<br> a &amp; 0 &amp; 0 \\<br> 0 &amp; b &amp; 0 \\<br> 0 &amp; 0 &amp; c<br>\end{bmatrix}\begin{bmatrix}<br> \mathbf{u_{1}}\\<br> \mathbf{u_{2}}\\<br>\mathbf{u_{3}}<br>\end{bmatrix}=\begin{bmatrix}<br> a\mathbf{u_{1}}\\<br> b\mathbf{u_{2}}\\<br>c\mathbf{u_{3}}<br>\end{bmatrix}$</p><h3 id="非轴向缩放"><a href="#非轴向缩放" class="headerlink" title="非轴向缩放"></a>非轴向缩放</h3><p>非轴向缩放即未按照当前标准基进行缩放,因此无法直接写出这样的矩阵,但是可以换个角度,可以先将其转换(旋转)到新的坐标空间,应用轴向缩放,再转换回原始的坐标空间,基本步骤分解如下:</p><ol><li>应用旋转矩阵转换到新的坐标系空间($R$)</li><li>应用轴向缩放矩阵($D$)</li><li>旋转回原始的坐标空间($R^T$)</li></ol><p><strong>注:旋转矩阵的逆等于其转置,因此可以用其转置来表示逆变换</strong></p><p>可以将非轴向缩放用对称矩阵($Symmetric \ matrix$)来表示:</p><p>$f(\mathbf{X}) = R^TDR\mathbf{X}$</p><p><strong>对称矩阵:对称矩阵的转置等于其自身:$A = A^T$</strong></p><p>那么所有的对阵矩阵都表示了非均匀缩放吗?答案是肯定的.下一小节我们根据谱定理来推导为什么所有的对称矩阵都代表了非均匀缩放?</p><h3 id="谱定理-Spectral-theorem"><a href="#谱定理-Spectral-theorem" class="headerlink" title="谱定理($Spectral \ theorem$)"></a>谱定理($Spectral \ theorem$)</h3><p>谱定理告诉我们对于任意一个对称矩阵$A = A^T$包含:</p><ul><li>正交特征向量:  $e_{1},…,e_{n} \in R^n$</li><li>特征值: $\lambda_{1},…,\lambda_{n} \in R$</li></ul><p>根据特征向量和特征值的定义可以得到:</p><p>$Ae_{i} = \lambda_{i}e_{i}$</p><p>也可以换一种表述方式:</p><p>$AR = RD$</p><p>$R = [e_{1}…e_{n}]$</p><p>$D = \begin{bmatrix}<br> \lambda_{1} &amp;  &amp; \\<br>  &amp; \cdot \cdot \cdot  &amp; \\<br>  &amp;  &amp; \lambda_{n}<br>\end{bmatrix}$</p><p>$\Rightarrow $</p><p>$A = RDR^T$</p><p>因此得出结论,<strong>所有的对称矩阵都代表了沿某一方向的非均匀缩放</strong>,这也给对称矩阵提供了一种几何视角,当我们看到一个对称矩阵,就明白它代表了某个方向上的非均匀缩放.</p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变($Shear$)"></a>切变($Shear$)</h2><p>先从简单的二维切变着手,如下图表示了一种切变变换过程:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05624da08838485fbeae86ec54c9c7e8~tplv-k3u1fbpfcp-watermark.image?" alt="3.png"></p><p>通过观察发现,变换后点的$y$不变,$x$的变化和$y$成一定的比例关系,取一个特殊点,$(0, 1)$在转换后变成$(a, 1)$,中间的任一点转换满足这种线性关系即:</p><p>$(x,y) \longrightarrow \ (x + ay, y)$</p><p>用矩阵表示:</p><p>$\begin{bmatrix}<br>x^丶 \\<br>y^丶<br>\end{bmatrix} = \begin{bmatrix}<br> 1 &amp; a\\<br>0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}$</p><p>切变严格定义: 切变使每个点$x$向u方向位移,移动距离和点$x$在$v$方向上的投影长度成正比:</p><p> $f_{u,v}(\mathbf{x}) = \mathbf{x} + &lt;\mathbf{v},\mathbf{x}&gt;\mathbf{u}$</p><p> $A_{u,v} = I + \mathbf{u}\mathbf{v^T}$</p><p>举例:</p><p>$\mathbf{u} = (\cos(t), 0, 0)$</p><p>$\mathbf{v} = (0 , 1, 0)$</p><p>$A_{u,v} = \begin{bmatrix}<br> 1 &amp; \cos(t) &amp;0 \\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><h2 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h2><p>通过这些基本变换(旋转,反射,缩放,切变)的组合,我们可以构建一个复合变换,只需要将这些矩阵相乘即可:</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dd73dfc644533be984f6c6c7fb73a~tplv-k3u1fbpfcp-watermark.image?" alt="4.png"></p><p><strong>应用变换的顺序:从右到左</strong></p><p>假设现在有一个代表变换的矩阵,如何将其分解为这些基础的变换呢?</p><h2 id="线性变换的分解"><a href="#线性变换的分解" class="headerlink" title="线性变换的分解"></a>线性变换的分解</h2><p>有许多线性变换分解的方法:</p><ol><li>奇异值分解($Singular \ value \ decomposition$) (信号处理领域)</li><li>LU分解($LU factorization$)(解线性方程组)</li><li>极分解($Polar \ decomposition$)(空间变换领域)</li></ol><p>对于本章主题,着重介绍奇异值分解和极分解.</p><p>考虑如下变换:<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af46c14bf40c4fd8bd5f6a094b0bb603~tplv-k3u1fbpfcp-watermark.image?" alt="5.png"></p><h3 id="极分解-amp-奇异值分解"><a href="#极分解-amp-奇异值分解" class="headerlink" title="极分解 &amp; 奇异值分解"></a>极分解 &amp; 奇异值分解</h3><p>极分解将任意矩阵$A$分解为一个正交矩阵$Q$和对阵矩阵$P$(缩放因子非负):</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7bc2da4f41a48b78938977ad51cb7a8~tplv-k3u1fbpfcp-watermark.image?" alt="6.png"></p><p>$QP$被称为矩阵$A$极分解.</p><p>由于$P$是对称矩阵,根据谱分解定理,可以将$P$继续分解为:$P = VDV^T$(V是正交矩阵,D是对角矩阵),因此:</p><p>$A = QVDV^T$</p><p>将QV合成一个旋转矩阵:</p><p>$A = QVDV^T = UDV^T$</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41490a0f0bd44886980121965b98ba53~tplv-k3u1fbpfcp-watermark.image?" alt="7.png"></p><p>$UDV^T$被称为矩阵$A$的奇异值分解.</p><h3 id="线性变换分解的意义"><a href="#线性变换分解的意义" class="headerlink" title="线性变换分解的意义"></a>线性变换分解的意义</h3><p>这些线性变换的分解方法有什么作用,具体在图形学中有什么重要意义呢?</p><p>考虑在两个线性变换$A_{0},A_{1}$之间做插值:</p><p>最简单的做法就是在两个矩阵之间根据时间($t \in [0, 1]$)做线性插值:</p><p>$A(t) = (1- t)A_{0} + tA_{1}$</p><p>我们发现在开始和结束时,变换是正确的,但是中间的插值过程看起来却很奇怪,现在正是矩阵分解该上场的时候了,其基本思想为分别对极分解生成的两个矩阵做插值而非原始矩阵自身.</p><p>我们先将$A_{0}和A_{1}$分别分解为$Q_{0}P_{0}和Q_{1}P_{1}$:</p><p>$A_{0} = Q_{0}P_{0}$</p><p>$A_{1} = Q_{1}P_{1}$</p><p>接下来我们不对矩阵本身做插值,而是对分解后的$QP$做插值:</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b813d8b2c0b4e659ba0b7eaaf5d1d42~tplv-k3u1fbpfcp-watermark.image?" alt="9.png"></p><h2 id="平移-Translations"><a href="#平移-Translations" class="headerlink" title="平移(Translations)"></a>平移(Translations)</h2><p>截止到现在我们介绍了 旋转/反射/缩放/错切变换,却忽略了一种最基础的变换:平移,平移用代数很好表达:</p><p>$f_{u}(\mathbf{X}) = \mathbf{X} + \mathbf{U}$</p><p>平移变换是线性的吗?让我们用线性变换的两条规则验证下:</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b310f1963adf451c97aa0db304394143~tplv-k3u1fbpfcp-watermark.image?" alt="10.png"></p><p><strong>显然平移变换不满足线性变换的加性法则和乘性法则,因此平移变换不是线性变换,相反它是仿射变换.</strong></p><p>回忆前边说过的复合线性变换可以用矩阵乘法来表示:</p><p>$A_{3}(A_{2}(A_{1}\mathbf{X})) = A_{3}A_{2}A_{1}\mathbf{X}$</p><p>同样复合平移变换可以用向量的加法来表示:</p><p>$f_{u3}(f_{u2}{f_{u1}(\mathbf{X})}) = f_{u1+u2+u3}(\mathbf{X})$</p><p>但是如果一个变换中既包含线性变换又包含平移变换:</p><p>$A_{2}(A_{1}\mathbf{X} + \mathbf{b_{1}}) + \mathbf{b_{2}} = (A_{2}A{1})\mathbf{X} + (A_{2}\mathbf{b_{1}} + \mathbf{b_{2}})$</p><p>既要处理矩阵计算又要处理向量计算,有没有什么方法统一二者,用简单明了的方式来表达?</p><p><strong>或许可以通过提高维度的方式将平移变换转换为线性变换…</strong>.这其实就是齐次坐标的基本思想.</p><h3 id="齐次坐标-Homogeneous-Coordinates"><a href="#齐次坐标-Homogeneous-Coordinates" class="headerlink" title="齐次坐标($Homogeneous \ Coordinates$)"></a>齐次坐标($Homogeneous \ Coordinates$)</h3><p>齐次坐标的概念起源于绘画中的透视法,由Möbius引入(为直线分配坐标):</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8adba8c8fae4e928c5efa42bc26acc4~tplv-k3u1fbpfcp-watermark.image?" alt="11.png"></p><p>是一个很重要的概念,广泛应用在图形学的方方面面:</p><ul><li>3D变换</li><li>透视投影</li><li>曲面简化</li><li>预乘计算透明度</li><li>阴影生成</li><li>….</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c0fe7832dac4116bdd8ddf32ade32a7~tplv-k3u1fbpfcp-watermark.image?" alt="12.png"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>想象三维空间中任意二维平面(与原点不相交),每一条穿过三维空间原点的直线$L$都会在二维平面上找到相应唯一的点$P$:</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03a92290d82740408bc4da67e3d21585~tplv-k3u1fbpfcp-watermark.image?" alt="13.png"></p><p>因此,在直线$L$上的任意一点$\hat{P}$可以被用来”表示”点$P$</p><h3 id="二维空间下的齐次坐标"><a href="#二维空间下的齐次坐标" class="headerlink" title="二维空间下的齐次坐标"></a>二维空间下的齐次坐标</h3><p>先从二维空间来解释,假设二维平面上的任意一点$P = (x, y)$,二维平面在三维空间中的$Z$值为1.</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc9e74d281244a8b9f2c4e7fff2ea45~tplv-k3u1fbpfcp-watermark.image?" alt="14.png"></p><p>任何满足$(a/c, b/c) = (x,y)$的点$\hat{P} = (a, b, c)$即为点$P$的齐次坐标.例如:</p><ul><li>$(x, y, 1)$</li><li>$(cx,cy,c) \ for \ c != 0$</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bebfbc5d5c554f0b8fbd976bb448d0c5~tplv-k3u1fbpfcp-watermark.image?" alt="15.png"></p><p>因此可以得出结论,两个点$\hat{p},\hat{q} \in R^3$描述的是二维空间中相同的点,只要满足 $\hat{p} = \lambda\hat{q}$并且$\lambda \ != 0$,同样我们可以说<strong>齐次坐标是低维空间坐标的高维度空间表示.</strong></p><h4 id="齐次坐标下的二维平移变换"><a href="#齐次坐标下的二维平移变换" class="headerlink" title="齐次坐标下的二维平移变换"></a>齐次坐标下的二维平移变换</h4><p>想象一下在齐次坐标空间下应用二维平移变换会发生什么:</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d571d7efd2f4f5d8908d8299195d220~tplv-k3u1fbpfcp-watermark.image?" alt="16.png"></p><p>这种变换和三维空间下的切变很像….其实它就是三维空间上的切变($Z$不变)…</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/846b1d50092e459ab0428670c7fe6b7c~tplv-k3u1fbpfcp-watermark.image?" alt="17.png"></p><p>让我们尝试证明齐次坐标下的平移变换是一个仿射变换:</p><p>假设将一个二维点 $\mathbf{p} = (p_{1}, p_{2})$平移$\mathbf{u} = (u_{1}, u_{2})$得到$p^丶 = (p_{1} + u_{1}, p_{2} + u_{2})$</p><p>在齐次坐标空间下用$\hat{p}$来表示$p$:</p><p>$\hat{p} = (cp_{1}, cp_{2}, c) \ \ \ \Rightarrow \ \ \ \hat{p^丶} = (cp_{1} + cu_{1}, cp_{2} + cu{2}, c)$</p><p><strong>注意我们将点$\hat{p}$沿着$u$方向位移,位移距离c和与第三个轴的距离成正比,这正是切变的定义.</strong></p><blockquote><p><em>重要结论:利用齐次坐标,可以用三维空间的线性变换(切变)来表示二维空间的仿射变换(平移)</em></p></blockquote><h4 id="齐次坐标下二维空间平移变换的矩阵表示"><a href="#齐次坐标下二维空间平移变换的矩阵表示" class="headerlink" title="齐次坐标下二维空间平移变换的矩阵表示"></a>齐次坐标下二维空间平移变换的矩阵表示</h4><p>既然用三维空间的切变来表示二维空间的平移,根据前文所述切变的代数定义可知:</p><p>$f_{u,v}(\mathbf{x}) = \mathbf{x} + &lt;\mathbf{v}, \mathbf{x}&gt;\mathbf{u}$</p><p>矩阵形式:</p><p>$f_{u,v}(\mathbf{x}) = (\mathbf{I} +\mathbf{u}\mathbf{v}^T)\mathbf{x}$</p><p>在我们表达平移这种情况下 $\mathbf{v} = (0, 0, 1)$,因此我们得到矩阵:</p><p>$\begin{bmatrix}<br> 1 &amp; 0 &amp; u_{1}\\<br> 0 &amp; 1 &amp; u_{2}\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96aceaddf2384802aa0a924d8ab7a0b3~tplv-k3u1fbpfcp-watermark.image?" alt="18.png"></p><h4 id="齐次坐标空间下的其他变换"><a href="#齐次坐标空间下的其他变换" class="headerlink" title="齐次坐标空间下的其他变换"></a>齐次坐标空间下的其他变换</h4><p>二维空间下的原始形状在三维齐次坐标空间下可以被表示为很多份均匀沿着$x_{3}$方向缩放的拷贝.</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e366395ddf554ccba84016b8baccc1f6~tplv-k3u1fbpfcp-watermark.image?" alt="22.png"></p><p>齐次坐标空间下的旋转:</p><p>齐次坐标空间下的二维旋转可以被表示为沿着$x_{3}$的旋转</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee510898e7948fdb788a74f63abaec7~tplv-k3u1fbpfcp-watermark.image?" alt="19.png"></p><p>齐次坐标空间下的缩放:</p><p>齐次坐标空间下的缩放可以被看作缩放$x_{1}和x_{2}$保持$x_{3}$不变</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2076b273337f4e01a338d851df3997b1~tplv-k3u1fbpfcp-watermark.image?" alt="20.png"></p><p>齐次坐标空间下的平移:</p><p>二维空间的平移被看作三维空间的切变($Z$不变)</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/803d737e333e41e78a32e4daf8d2851c~tplv-k3u1fbpfcp-watermark.image?" alt="21.png"></p><p><strong>以上我们就将几种基本变换完美的统一了起来,在齐次坐标空间下计算变换矩阵,将平移转换为切变,这样就可以用矩阵乘法来表示所有的变换组合,用一个矩阵表示任意的变换.</strong></p><h3 id="三维空间平移的齐次坐标表示"><a href="#三维空间平移的齐次坐标表示" class="headerlink" title="三维空间平移的齐次坐标表示"></a>三维空间平移的齐次坐标表示</h3><p> 和二维空间下一样,三维空间下的齐次坐标用四维空间表示:</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d39a751acf4f789790e8c649b5b017~tplv-k3u1fbpfcp-watermark.image?" alt="23.png"></p><h3 id="点-vs-向量"><a href="#点-vs-向量" class="headerlink" title="点 vs 向量"></a>点 vs 向量</h3><p>齐次坐标有另外一个有用的特性:区分空间中的点和向量</p><p>假设三维空间下一个三角形,由三个顶点组成, $a,b,c \in R^3$,法线为$\mathbf{n} \in R^3$:</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45cf87e724a6454aa389050b9b7b1dc6~tplv-k3u1fbpfcp-watermark.image?" alt="24.png"></p><p>假设我们对三个顶点和法线应用同样的变换:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/add4d320a873416da68fcc51c4259aa0~tplv-k3u1fbpfcp-watermark.image?" alt="25.png"></p><p>我们发现在变换后,法线不再垂直于三角形平面,为什么?我们来看下当对法线做变换时发生了什么</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9af8af33c54b1c800526cf9f4b1428~tplv-k3u1fbpfcp-watermark.image?" alt="26.png"></p><p>但是当我们旋转 &amp; 平移一个三角形时,它的法线不应该被平移,因为法线是一个向量,代表空间中的一个方向,它没有自己的起点($Base Point$),空间中任意两个向量方向相同长度相同,则它们应该是相等的,因此平移变换对于向量不应该起作用,有什么办法能避免法线被平移呢?我们只需要将向量的$w$分量设置为0即可:</p><p>$\begin{bmatrix}<br>n_{1}\\<br>n_{2}\\<br>n_{3}\\<br>0<br>\end{bmatrix}$</p><p>这样经过变换后,我们得到的三角形法线是垂直于其表面的:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04078922cdb1406190419413047d3eae~tplv-k3u1fbpfcp-watermark.image?" alt="27.png"></p><p><strong>因此,齐次坐标下的点和向量表示是不同的,向量应该忽略平移变换,其$w$分量应该被设置为0,点的$w$分量为1</strong></p><p>但是最终齐次坐标需要除以$w$得到原空间的坐标,但是对于向量$w$分量为0的情况,这意味着什么?</p><p>假设我们不断缩小除数$c$,当$c$无限趋近于0时,可以认为向量是在无限远处的一个点:</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9452729c7ef04fafa748dcbb9499c27e~tplv-k3u1fbpfcp-watermark.image?" alt="28.png"></p><h2 id="齐次坐标空间下的投影矩阵"><a href="#齐次坐标空间下的投影矩阵" class="headerlink" title="齐次坐标空间下的投影矩阵"></a>齐次坐标空间下的投影矩阵</h2><p>用齐次坐标如何表达一个投影矩阵呢,根据小孔相机模型的定义:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f028e8217d489ab4c7fb930f41a551~tplv-k3u1fbpfcp-watermark.image?" alt="30.png"></p><p>$(x,y,z) \Rightarrow (x/z, y/z, 1)$</p><p>因此我们可以构建一个矩阵:把z坐标赋值给齐次坐标分量$w$,除以齐次坐标分量$w$会得到在z平面上的投影:</p><p>$\begin{bmatrix}<br>1  &amp; 0 &amp; 0 &amp; 0\\<br>0  &amp; 1 &amp; 0 &amp; 0\\<br>0  &amp; 0 &amp; 1 &amp; 0\\<br>0  &amp; 0 &amp; 1 &amp; 0<br>\end{bmatrix}\begin{bmatrix}<br> x\\<br> y\\<br> z\\<br> 1<br>\end{bmatrix} = \begin{bmatrix}<br> x\\<br> y\\<br> z\\<br> z<br>\end{bmatrix} \Rightarrow \begin{bmatrix}<br> x/z\\<br> y/z\\<br> 1<br>\end{bmatrix}$</p><h2 id="NDC-To-ScreenSpace"><a href="#NDC-To-ScreenSpace" class="headerlink" title="NDC To ScreenSpace"></a>NDC To ScreenSpace</h2><p>经过mvp变换后,原始的顶点被转换为$[-1,1]^3$的标准立方体中(NDC Space),接下来我们需要将顶点从Ndc空间转换到屏幕空间(多种不同的叫法:$ScreenSpace/PixelSpace/ImageSpace$),即我们常常看到视口变换($viewport$)</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994b85e7304b49bab9ded86560e54163~tplv-k3u1fbpfcp-watermark.image?" alt="34.png"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c938f1bb470494287eaa199a76247f9~tplv-k3u1fbpfcp-watermark.image?" alt="33.png"></p><h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>什么是屏幕空间?顾名思义就是我们的显示器,由像素组成的数组构成,数组的大小被我们称为分辨率</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4862226e73ee49a0a3f0a65af16f68f1~tplv-k3u1fbpfcp-watermark.image?" alt="32.png"></p><ul><li>像素由$(x,y)$的形式来表示,$x和y$均为整数,假设像素是一个小方块,$(x,y)$为该小方块左下角的坐标</li><li>坐标范围从 $(0,0) -(width-1,height-1) $</li><li>像素$(x,y)$的中心点位于$(x+0.5, y+0.5)$</li><li>屏幕空间覆盖范围:$(0,0) - (width, height)$</li></ul><h3 id="viewport矩阵"><a href="#viewport矩阵" class="headerlink" title="$viewport矩阵$"></a>$viewport矩阵$</h3><p>先对Ndc应用缩放矩阵,由于Ndc空间是$[-1,1]$,所以缩放矩阵应该是屏幕w和h各除以2,然后应用平移变换,将原点从中心移到左下角,平移的量正好是宽高的一半$(width/2, height/2)$,矩阵形式表示如下:</p><p>$M_{viewport} = \begin{bmatrix}<br> width/2 &amp; 0 &amp; 0 &amp; width/2\\<br> 0 &amp; height/2 &amp; 0 &amp; height/2\\<br> 0 &amp; 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><h2 id="在组合转换时，顺序很重要"><a href="#在组合转换时，顺序很重要" class="headerlink" title="在组合转换时，顺序很重要!"></a>在组合转换时，顺序很重要!</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039ac486484b45b081e3062b21e0244d~tplv-k3u1fbpfcp-watermark.image?" alt="35.png"></p><h3 id="实现基于自身旋转"><a href="#实现基于自身旋转" class="headerlink" title="实现基于自身旋转"></a>实现基于自身旋转</h3><p>如果对空间中的一个物体直接应用旋转矩阵,物体将围绕原点做旋转而非自身.<br>物体实现自身旋转的一个常用技巧就是,先将物体平移到原点,应用旋转变换,然后再将其移动到原位置:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44238cbe0018456dbcfc2f774d741e8e~tplv-k3u1fbpfcp-watermark.image?" alt="36.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们总结下在光栅化管线中,从顶点到屏幕坐标一系列的变换过程:</p><ol><li>首先，我们使用场景图对立方体的多个副本应用变换($ModelSpace-&gt;WorldSpace$)</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a26747b0080429583d50acc52d04ef7~tplv-k3u1fbpfcp-watermark.image?" alt="37.png"></p><ol><li>然后应用相机变换,即我们观看场景的视角($WorldSpace-&gt;ViewSpace$)</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e7d2b147f04433697b65b6f7e685c83~tplv-k3u1fbpfcp-watermark.image?" alt="38.png"></p><ol><li>应用投影变换(perspective)($ViewSpace-&gt;NdcSpace$)</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2896eed3f1b43bebc0c36fd0ae36180~tplv-k3u1fbpfcp-watermark.image?" alt="39.png"></p><ol><li>最后将ndc标准立方体转换到屏幕空间($NdcSpace-&gt;ScreenSpace$)</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1c08943de1437db1abb7d981ffbe9a~tplv-k3u1fbpfcp-watermark.image?" alt="40.png"></p><p>经过以上四个步骤,我们将顶点转换为了屏幕上的像素点,接下来就是光栅化着色的过程.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphic04-空间变换-下</title>
      <link href="/2023/05/02/Computer-Graphic04-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8B/"/>
      <url>/2023/05/02/Computer-Graphic04-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Graphic04-空间变换-下"><a href="#Computer-Graphic04-空间变换-下" class="headerlink" title="Computer Graphic04-空间变换-下"></a>Computer Graphic04-空间变换-下</h1><p>上一篇文章中介绍了旋转和反射变换,这章我们开始介绍剩下几种变换:缩放/平移/错切。</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h3 id="均匀缩放"><a href="#均匀缩放" class="headerlink" title="均匀缩放"></a>均匀缩放</h3><p>每一个向量被映射到自身与缩放因子的乘积。</p><p>$f(\mathbf{u}) = a\mathbf{u} \ \ \ \ a \in R$</p><p>旋转变换保持向量大小不变,缩放保持方向不变:</p><p>$\frac{\mathbf{u}}{|\mathbf{u}|}  = \frac{a\mathbf{u}}{|a\mathbf{u}|}$</p><p>缩放是线性变换吗?可以用线性变化的代数定义来证明:</p><p><img src="1.png" alt="1.png"></p><p><strong>缩放是线性变换!</strong></p><p>矩阵表示:</p><p>假如用因数$a$缩放向量$\mathbf{u} = (u_{1},u_{2},u_{3})$，如何用矩阵来表示该变换?</p><p>用缩放因子$a$构造一个对角矩阵($diagonal \ matrix \ D$)即可:</p><p>$\begin{bmatrix}<br> a &amp; 0 &amp; 0 \\<br> 0 &amp; a &amp; 0 \\<br> 0 &amp; 0 &amp; a<br>\end{bmatrix}\begin{bmatrix}<br> u_{1}\\<br> u_{2}\\<br> u_{3}<br>\end{bmatrix} = \begin{bmatrix}<br> au_{1}\\<br> au_{2}\\<br> au_{3}<br>\end{bmatrix}$</p><h3 id="负数缩放"><a href="#负数缩放" class="headerlink" title="负数缩放"></a>负数缩放</h3><p>如果缩放因子为负,假设$a = -1$,可以把缩放分解为一系列的反射变换.负因子缩放的这种性质在二维和三维中的表现是不同的,因为二维缩放分解为两个反射矩阵的乘积,而三维缩放分解为三个反射矩阵的乘积:</p><p>$\begin{bmatrix}<br> -1 &amp; 0\\<br> 0 &amp; -1<br>\end{bmatrix} = \begin{bmatrix}<br> -1 &amp; 0\\<br> 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0\\<br> 0 &amp; -1<br>\end{bmatrix}$</p><p>对于二维负数缩放,可以将其分解为沿$Y$轴和$X$轴做两次镜像,两次朝向反转相互抵消,最终面朝向保持不变,本质上这是一次180°的旋转变换.</p><p>对于三维负数缩放,可以分解为沿$Y$轴$X$和$Z$轴做三次镜像,两次抵消一次反转,最终面朝向是反转的:</p><p>$\begin{bmatrix}<br> -1 &amp; 0 &amp; 0 \\<br> 0 &amp; -1 &amp; 0 \\<br> 0 &amp; 0 &amp; -1<br>\end{bmatrix} = \begin{bmatrix}<br> -1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; -1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; -1<br>\end{bmatrix}$</p><h3 id="非均匀缩放-轴向"><a href="#非均匀缩放-轴向" class="headerlink" title="非均匀缩放(轴向)"></a>非均匀缩放(轴向)</h3><p>上边介绍的几种缩放缩放因子都是统一的,每个轴的缩放系数保持一致,如果每个轴按照不同的因子缩放,该如何去表达呢?</p><p>$f(\mathbf{u_{1}}, \mathbf{u_{2}}, \mathbf{u_{3}}) = (a\mathbf{u_{1}}, b\mathbf{u_{2}}, c\mathbf{u_{3}})$</p><p>$a,b,c \in R$</p><p>和均匀缩放矩阵表示一样,只不过在对角线上替换成不同的缩放因子即可:</p><p>$\begin{bmatrix}<br> a &amp; 0 &amp; 0 \\<br> 0 &amp; b &amp; 0 \\<br> 0 &amp; 0 &amp; c<br>\end{bmatrix}\begin{bmatrix}<br> \mathbf{u_{1}}\\<br> \mathbf{u_{2}}\\<br>\mathbf{u_{3}}<br>\end{bmatrix}=\begin{bmatrix}<br> a\mathbf{u_{1}}\\<br> b\mathbf{u_{2}}\\<br>c\mathbf{u_{3}}<br>\end{bmatrix}$</p><h3 id="非轴向缩放"><a href="#非轴向缩放" class="headerlink" title="非轴向缩放"></a>非轴向缩放</h3><p>非轴向缩放即未按照当前标准基进行缩放,因此无法直接写出这样的矩阵,但是可以换个角度,可以先将其转换(旋转)到新的坐标空间,应用轴向缩放,再转换回原始的坐标空间,基本步骤分解如下:</p><ol><li>应用旋转矩阵转换到新的坐标系空间($R$)</li><li>应用轴向缩放矩阵($D$)</li><li>旋转回原始的坐标空间($R^T$)</li></ol><p><strong>注:旋转矩阵的逆等于其转置,因此可以用其转置来表示逆变换</strong></p><p>可以将非轴向缩放用对称矩阵($Symmetric \ matrix$)来表示:</p><p>$A = R^TDR$</p><p>$A^T = (R^TDR)^T = R^TD^T(R^T)^T = R^TDR$</p><p><strong>对称矩阵:对称矩阵的转置等于其自身:$A = A^T$</strong></p><p>那么所有的对阵矩阵都表示了非均匀缩放吗?答案是肯定的.下一小节我们根据谱定理来推导为什么所有的对称矩阵都代表了非均匀缩放?</p><h3 id="谱定理-Spectral-theorem"><a href="#谱定理-Spectral-theorem" class="headerlink" title="谱定理($Spectral \ theorem$)"></a>谱定理($Spectral \ theorem$)</h3><p>谱定理告诉我们对于任意一个对称矩阵$A = A^T$包含:</p><ul><li>正交特征向量:  $e_{1},…,e_{n} \in R^n$</li><li>特征值: $\lambda_{1},…,\lambda_{n} \in R$</li></ul><p>根据特征向量和特征值的定义可以得到:</p><p>$Ae_{i} = \lambda_{i}e_{i}$</p><p>也可以换一种表述方式:</p><p>$AR = RD$</p><p>$R = [e_{1}…e_{n}]$</p><p>$D = \begin{bmatrix}<br> \lambda_{1} &amp;  &amp; \\<br>  &amp; \cdot \cdot \cdot  &amp; \\<br>  &amp;  &amp; \lambda_{n}<br>\end{bmatrix}$</p><p>$\Rightarrow$</p><p>$A = RDR^T$</p><p>因此得出结论,<strong>所有的对称矩阵都代表了沿某一方向的非均匀缩放</strong>,这也给对称矩阵提供了一种几何视角,当我们看到一个对称矩阵,就明白它代表了某个方向上的非均匀缩放.</p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变($Shear$)"></a>切变($Shear$)</h2><p>先从简单的二维切变着手,如下图表示了一种切变变换过程:</p><p><img src="3.png" alt="3.png"></p><p>通过观察发现,变换后点的$y$不变,$x$的变化和$y$成一定的比例关系,取一个特殊点,$(0, 1)$在转换后变成$(a, 1)$,中间的任一点转换满足这种线性关系即:</p><p>$(x,y) \longrightarrow \ (x + ay, y)$</p><p>用矩阵表示:</p><p>$\begin{bmatrix}<br>x^丶 \\<br>y^丶<br>\end{bmatrix} = \begin{bmatrix}<br> 1 &amp; a\\<br>0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}$</p><p>切变严格定义: 切变使每个点$x$向u方向位移,移动距离和点$x$在$v$方向上的投影长度成正比:</p><p>$f_{u,v}(\mathbf{x}) = \mathbf{x} + &lt;\mathbf{v},\mathbf{x}&gt;\mathbf{u}$</p><p>切变的矩阵表示：</p><p>$A_{u,v} = I + \mathbf{u}\mathbf{v^T}$</p><p>举例:</p><p>$\mathbf{u} = (\cos(t), 0, 0)$</p><p>$\mathbf{v} = (0 , 1, 0)$</p><p>$A_{u,v} = \begin{bmatrix}<br> 1 &amp; \cos(t) &amp;0 \\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><h2 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h2><p>通过这些基本变换(旋转,反射,缩放,切变)的组合,我们可以构建一个复合变换,只需要将这些矩阵相乘即可:</p><p><img src="4.png" alt="4.png"></p><p><strong>应用变换的顺序:从右到左</strong></p><p>假设现在有一个代表变换的矩阵,如何将其分解为这些基础的变换呢?</p><h2 id="线性变换的分解"><a href="#线性变换的分解" class="headerlink" title="线性变换的分解"></a>线性变换的分解</h2><p>有许多线性变换分解的方法:</p><ol><li>奇异值分解($Singular \ value \ decomposition$) (信号处理领域)</li><li>LU分解($LU factorization$)(解线性方程组)</li><li>极分解($Polar \ decomposition$)(空间变换)</li><li>…</li></ol><p>对于本章主题,着重介绍奇异值分解和极分解.</p><p>考虑如下变换:<br><img src="5.png" alt="5.png"></p><h3 id="极分解-amp-奇异值分解"><a href="#极分解-amp-奇异值分解" class="headerlink" title="极分解 &amp; 奇异值分解"></a>极分解 &amp; 奇异值分解</h3><p>极分解将任意矩阵$A$分解为一个正交矩阵$Q$和对阵矩阵$P$(缩放因子非负):</p><p>$A = QP$</p><p><img src="6.png" alt="6.png"></p><p>$QP$被称为矩阵$A$的极分解.</p><p>由于$P$是对称矩阵,根据谱分解定理,可以将$P$继续分解为:$P = VDV^T$(V是正交矩阵,D是对角矩阵),因此:</p><p>$A = QVDV^T$</p><p>将QV合成一个旋转矩阵:</p><p>$A = QVDV^T = UDV^T$</p><p><img src="7.png" alt="7.png"></p><p>$UDV^T$被称为矩阵$A$的奇异值分解.</p><h3 id="线性变换分解的意义"><a href="#线性变换分解的意义" class="headerlink" title="线性变换分解的意义"></a>线性变换分解的意义</h3><p>这些线性变换的分解方法有什么作用,具体在图形学中有什么重要意义呢?</p><p>考虑在两个线性变换$A_{0},A_{1}$之间做插值:</p><p>最简单的做法就是在两个矩阵之间根据时间($t \in [0, 1]$)做线性插值:</p><p>$A(t) = (1- t)A_{0} + tA_{1}$</p><p>我们发现在开始和结束时,变换是正确的,但是中间的插值过程看起来却很奇怪,这正是矩阵分解的用武之地,其基本思想为分别对极分解生成的两个矩阵做插值而非原始矩阵自身.</p><p>我们先将$A_{0}和A_{1}$分别分解为$Q_{0}P_{0}和Q_{1}P_{1}$:</p><p>$A_{0} = Q_{0}P_{0}$</p><p>$A_{1} = Q_{1}P_{1}$</p><p>接下来我们不对矩阵本身做插值,而是对分解后的$QP$做插值:</p><p><img src="9.png" alt="9.png"></p><h2 id="平移-Translations"><a href="#平移-Translations" class="headerlink" title="平移(Translations)"></a>平移(Translations)</h2><p>截止到现在我们介绍了旋转/反射/缩放/错切变换,却忽略了一种最基础的变换:平移,平移用代数很好表达:</p><p>$f_{u}(\mathbf{X}) = \mathbf{X} + \mathbf{U}$</p><p>平移变换是线性的吗?让我们用线性变换的两条规则验证下:</p><p><img src="10.png" alt="10.png"></p><p><strong>显然平移变换不满足线性变换的加性法则和乘性法则,因此平移变换不是线性变换,相反它是仿射变换.</strong></p><p>回忆前边说过的复合线性变换可以用矩阵乘法来表示:</p><p>$A_{3}(A_{2}(A_{1}\mathbf{X})) = A_{3}A_{2}A_{1}\mathbf{X}$</p><p>同样复合平移变换可以用向量的加法来表示:</p><p>$f_{u3}(f_{u2}{f_{u1}(\mathbf{X})}) = f_{u1+u2+u3}(\mathbf{X})$</p><p>但是如果一个变换中既包含线性变换又包含平移变换:</p><p>$A_{2}(A_{1}\mathbf{X} + \mathbf{b_{1}}) + \mathbf{b_{2}} = (A_{2}A{1})\mathbf{X} + (A_{2}\mathbf{b_{1}} + \mathbf{b_{2}})$</p><p>既要处理矩阵计算又要处理向量计算,有没有什么方法统一二者,用简单明了的方式来表达?</p><p><strong>或许可以通过提高维度的方式将平移变换转换为线性变换…</strong>.这就是齐次坐标的基本思想.</p><h3 id="齐次坐标-Homogeneous-Coordinates"><a href="#齐次坐标-Homogeneous-Coordinates" class="headerlink" title="齐次坐标($Homogeneous \ Coordinates$)"></a>齐次坐标($Homogeneous \ Coordinates$)</h3><p>齐次坐标的概念起源于绘画中的透视法,由$Möbius$引入(为直线分配坐标):</p><p><img src="11.png" alt="11.png"></p><p>是一个很重要的概念,广泛应用在图形学的方方面面:</p><ul><li>3D变换</li><li>透视投影</li><li>曲面简化</li><li>预乘计算透明度</li><li>阴影生成</li><li>….</li></ul><p><img src="12.png" alt="12.png"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>想象三维空间中任意二维平面(与原点不相交),每一条穿过三维空间原点的直线$L$都会在二维平面上找到相应唯一的点$P$:</p><p><img src="13.png" alt="13.png"></p><p>因此,在直线$L$上的任意一点$\hat{P}$可以被用来”表示”点$P$</p><h4 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h4><p>回顾下小孔成像原理，所有沿着一条直线的点最终会被投影到成像平面上的同一个点，这就是齐次坐标的最初想法。</p><p><img src="41.png" alt="13.png"></p><h3 id="二维空间下的齐次坐标"><a href="#二维空间下的齐次坐标" class="headerlink" title="二维空间下的齐次坐标"></a>二维空间下的齐次坐标</h3><p>先从二维空间来解释,假设二维平面上的任意一点$P = (x, y)$,二维平面在三维空间中的$Z$值为1.</p><p><img src="14.png" alt="14.png"></p><p>任何满足$(a/c, b/c) = (x,y)$的点$\hat{P} = (a, b, c)$即为点$P$的齐次坐标.例如:</p><ul><li>$(x, y, 1)$</li><li>$(cx,cy,c) \ for \ c != 0$</li></ul><p><img src="15.png" alt="15.png"></p><p>因此可以得出结论,两个点$\hat{p},\hat{q} \in R^3$描述的是二维空间中相同的点,只要满足 $\hat{p} = \lambda\hat{q}$并且$\lambda \ != 0$,同样我们可以说<strong>齐次坐标是低维空间坐标的高维度空间表示.</strong></p><h3 id="齐次坐标下的二维平移变换"><a href="#齐次坐标下的二维平移变换" class="headerlink" title="齐次坐标下的二维平移变换"></a>齐次坐标下的二维平移变换</h3><p>想象一下在齐次坐标空间下应用二维平移变换会发生什么:</p><p><img src="16.png" alt="16.png"></p><p>这种变换和三维空间下的切变很像，其实它就是三维空间上的切变($Z$不变)</p><p><img src="17.png" alt="17.png"></p><p>让我们尝试证明齐次坐标下的平移变换是一个仿射变换:</p><p>假设将一个二维点 $\mathbf{p} = (p_{1}, p_{2})$平移$\mathbf{u} = (u_{1}, u_{2})$得到$p^丶 = (p_{1} + u_{1}, p_{2} + u_{2})$</p><p>在齐次坐标空间下用$\hat{p}$来表示$p$:</p><p>$\hat{p} = (cp_{1}, cp_{2}, c) \ \ \ \Rightarrow \ \ \ \hat{p^丶} = (cp_{1} + cu_{1}, cp_{2} + cu{2}, c)$</p><p><strong>注意我们将点$\hat{p}$沿着$u$方向位移,位移距离c和与第三个轴的距离成正比,这正是切变的定义.</strong></p><blockquote><p><em>重要结论:利用齐次坐标,可以用三维空间的线性变换(切变)来表示二维空间的仿射变换(平移)</em></p></blockquote><h3 id="齐次坐标下二维平移变换的矩阵表示"><a href="#齐次坐标下二维平移变换的矩阵表示" class="headerlink" title="齐次坐标下二维平移变换的矩阵表示"></a>齐次坐标下二维平移变换的矩阵表示</h3><p>既然用三维空间的切变来表示二维空间的平移,根据前文所述切变的代数定义可知:</p><p>$f_{u,v}(\mathbf{x}) = \mathbf{x} + &lt;\mathbf{v}, \mathbf{x}&gt;\mathbf{u}$</p><p>矩阵形式:</p><p>$f_{u,v}(\mathbf{x}) = (\mathbf{I} +\mathbf{u}\mathbf{v}^T)\mathbf{x}$</p><p>在我们表达平移这种情况下 $\mathbf{v} = (0, 0, 1)$,因此我们得到矩阵:</p><p>$\begin{bmatrix}<br> 1 &amp; 0 &amp; u_{1}\\<br> 0 &amp; 1 &amp; u_{2}\\<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><p><img src="18.png" alt="18.png"></p><h3 id="齐次坐标空间下的其他变换"><a href="#齐次坐标空间下的其他变换" class="headerlink" title="齐次坐标空间下的其他变换"></a>齐次坐标空间下的其他变换</h3><p>二维空间下的原始形状在三维齐次坐标空间下可以被表示为很多份均匀沿着$x_{3}$方向缩放的拷贝.</p><p><img src="19.png" alt="19.png"></p><p><strong>以上我们就将几种基本变换完美的统一了起来,在齐次坐标空间下计算变换矩阵,将平移转换为切变,这样就可以用矩阵乘法来表示所有的变换组合,用一个矩阵表示任意的变换.</strong></p><h3 id="三维空间平移的齐次坐标表示"><a href="#三维空间平移的齐次坐标表示" class="headerlink" title="三维空间平移的齐次坐标表示"></a>三维空间平移的齐次坐标表示</h3><p>和二维空间一样,三维空间下的齐次坐标用四维空间表示:</p><p><img src="23.png" alt="23.png"></p><h3 id="点-vs-向量"><a href="#点-vs-向量" class="headerlink" title="点 vs 向量"></a>点 vs 向量</h3><p>齐次坐标有另外一个有用的特性:区分空间中的点和向量</p><p>假设三维空间下一个三角形,由三个顶点组成, $a,b,c \in \mathbb{R}^3$,法线为$\mathbf{n} \in \mathbb{R}^3$:</p><p><img src="24.png" alt="24.png"></p><p>假设我们对三个顶点和法线应用同样的变换:</p><p><img src="25.png" alt="25.png"></p><p>我们发现在变换后,法线不再垂直于三角形平面,为什么?我们来看下当对法线做变换时发生了什么</p><p><img src="26.png" alt="26.png"></p><p>但是当我们旋转 &amp; 平移一个三角形时,它的法线不应该被平移,因为法线是一个向量,代表空间中的一个方向,它没有自己的起点($Base Point$),空间中任意两个向量方向相同长度相同,则它们应该是相等的,因此平移变换对于向量不应该起作用,有什么办法能避免法线被平移呢?我们只需要将向量的$w$分量设置为0即可:</p><p>$\begin{bmatrix}<br>n_{1}\\<br>n_{2}\\<br>n_{3}\\<br>0<br>\end{bmatrix}$</p><p>这样经过变换后,我们得到的三角形法线是垂直于其表面的:</p><p><img src="27.png" alt="27.png"></p><p><strong>因此,齐次坐标下的点和向量表示是不同的,向量应该忽略平移变换,其$w$分量应该被设置为0,点的$w$分量为1</strong></p><p>但是最终齐次坐标需要除以$w$得到原空间的坐标,但是对于向量$w$分量为0的情况,这意味着什么?</p><p>假设我们不断缩小除数$c$,当$c$无限趋近于0时,可以认为向量是在无限远处的一个点:</p><p><img src="28.png" alt="28.png"></p><h2 id="齐次坐标空间下的投影矩阵"><a href="#齐次坐标空间下的投影矩阵" class="headerlink" title="齐次坐标空间下的投影矩阵"></a>齐次坐标空间下的投影矩阵</h2><p>用齐次坐标如何表达一个投影矩阵呢,根据小孔相机模型的定义:</p><p><img src="30.png" alt="30.png"></p><p>$(x,y,z) \Rightarrow (x/z, y/z, 1)$</p><p>因此我们可以构建一个矩阵:把z坐标赋值给齐次坐标分量$w$,除以齐次坐标分量$w$会得到在z平面上的投影:</p><p>$\begin{bmatrix}<br>1  &amp; 0 &amp; 0 &amp; 0\\<br>0  &amp; 1 &amp; 0 &amp; 0\\<br>0  &amp; 0 &amp; 1 &amp; 0\\<br>0  &amp; 0 &amp; 1 &amp; 0<br>\end{bmatrix}\begin{bmatrix}<br> x\\<br> y\\<br> z\\<br> 1<br>\end{bmatrix} = \begin{bmatrix}<br> x\\<br> y\\<br> z\\<br> z<br>\end{bmatrix} \Rightarrow \begin{bmatrix}<br> x/z\\<br> y/z\\<br> 1<br>\end{bmatrix}$</p><h2 id="NDC-To-ScreenSpace"><a href="#NDC-To-ScreenSpace" class="headerlink" title="NDC To ScreenSpace"></a>NDC To ScreenSpace</h2><p>经过mvp变换后,原始的顶点被转换为$[-1,1]^3$的标准立方体中(NDC Space),接下来我们需要将顶点从$NDC空间转换到屏幕空间(多种不同的叫法:$ScreenSpace/PixelSpace/ImageSpace$),即我们常常看到视口变换($viewport$):</p><p><img src="31.png" alt="31.png"></p><h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>什么是屏幕空间?顾名思义就是我们的显示器,由像素数组构成,数组的大小被我们称为分辨率.</p><p><img src="32.png" alt="32.png"></p><ul><li>像素由$(x,y)$的形式来表示,$x和y$均为整数,假设像素是一个小方块,$(x,y)$为该小方块左下角的坐标</li><li>坐标范围从 $(0,0) -(width-1,height-1) $</li><li>像素$(x,y)$的中心点位于$(x+0.5, y+0.5)$</li><li>屏幕空间覆盖范围:$(0,0) - (width, height)$</li></ul><h3 id="viewport矩阵"><a href="#viewport矩阵" class="headerlink" title="$viewport矩阵$"></a>$viewport矩阵$</h3><p>先对$NDC$应用缩放矩阵,由于$NDC$空间是$[-1,1]$,所以缩放矩阵应该是屏幕w和h各除以2,然后应用平移变换,将原点从中心移到左下角,平移的量正好是宽高的一半$(width/2, height/2)$,矩阵形式表示如下:</p><p>$M_{viewport} = \begin{bmatrix}<br> width/2 &amp; 0 &amp; 0 &amp; width/2\\<br> 0 &amp; height/2 &amp; 0 &amp; height/2\\<br> 0 &amp; 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}$</p><h2 id="在组合转换时，顺序很重要"><a href="#在组合转换时，顺序很重要" class="headerlink" title="在组合转换时，顺序很重要!"></a>在组合转换时，顺序很重要!</h2><p><img src="35.png" alt="35.png"></p><h3 id="实现基于自身旋转"><a href="#实现基于自身旋转" class="headerlink" title="实现基于自身旋转"></a>实现基于自身旋转</h3><p>如果对空间中的一个物体直接应用旋转矩阵,物体将围绕原点做旋转而非自身.<br>物体实现自身旋转的一个常用技巧就是,先将物体平移到原点,应用旋转变换,然后再将其移动到原位置:</p><p><img src="36.png" alt="36.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们总结下在光栅化管线中,从顶点到屏幕坐标一系列的变换过程:</p><ol><li>首先，我们使用场景图对立方体的多个副本应用变换($ModelSpace-&gt;WorldSpace$)</li></ol><p><img src="37.png" alt="37.png"></p><ol><li>然后应用相机变换,即我们观看场景的视角($WorldSpace-&gt;ViewSpace$)</li></ol><p><img src="38.png" alt="38.png"></p><ol><li>应用投影变换(perspective)($ViewSpace-&gt;NdcSpace$)</li></ol><p><img src="39.png" alt="39.png"></p><ol><li>最后将ndc标准立方体转换到屏幕空间($NdcSpace-&gt;ScreenSpace$)</li></ol><p><img src="40.png" alt="40.png"></p><p>经过以上四个步骤,我们将顶点转换为了屏幕上的像素点,接下来就是光栅化着色的过程.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphic03-空间变换(上)</title>
      <link href="/2023/05/01/Computer-Graphic03-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8A/"/>
      <url>/2023/05/01/Computer-Graphic03-%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Graphic03-空间变换-上-Spatial-Transformation"><a href="#Computer-Graphic03-空间变换-上-Spatial-Transformation" class="headerlink" title="Computer-Graphic03-空间变换-上(Spatial Transformation)"></a>Computer-Graphic03-空间变换-上(Spatial Transformation)</h1><p>本章将开始学习空间变换,空间变换在图形学中有非常广泛的应用,对于深入了解图形学底层有重要意义,特别在光栅化渲染管线中, 我们知道最初输入的顶点坐标都是在对象局部空间的($Local Space$), 需要经过一系列的变换将对象从局部空间变换到世界空间(物体摆放在场景的哪里,物体的相对位置关系),接下来再变换到相机空间(即我们观看的视角,就像拿个相机拍照一样,我们是从哪个角度对场景进行观察的),即$mvp$矩阵中的”$m(model Matrix)$和$v(view Matrix)$”.这一系列操作即光栅化渲染管线的第一个阶段,也是理解光栅化背后原理的基础.本章将介绍涉及图形学的基础变换。</p><p><img src="1.png" alt="1.png"></p><p>任何将一个点变换到新位置的函数都可以被认为是空间变换<br>$f: R^n \to  R^n$<br>今天我们将重点学习几种基础变换:</p><ul><li>旋转($Rotation$)</li><li>缩放($Scaling$)</li><li>平移($Translation$)(仿射变换)</li><li>错切($Shearing$)</li><li>镜像($Reflect$)</li></ul><p>重点讲解：</p><ol><li>空间几何表示 </li><li>矩阵表示 </li><li>齐次坐标 </li><li>如何用齐次坐标解决仿射变换和线性变换统一问题</li></ol><h2 id="线性变换回顾"><a href="#线性变换回顾" class="headerlink" title="线性变换回顾"></a>线性变换回顾</h2><p>前几章详细阐述了<a href="https://kenshin.tech/2024/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#more">线性变换</a>的定义,并从几何上和代数上分别对其做了解释:</p><ol><li>从几何的角度,线性变换会保持直线变换后仍然为直线,并保持原点不变</li></ol><p><img src="2.jpg" alt="2.jpg"></p><ol><li>从代数角度: </li></ol><p>$f(\vec{u} + \vec{v}) = f(\vec{u}) + f(\vec{v})$</p><p>$f(a\vec{u}) = af(\vec{u})$</p><p><img src="3.jpg" alt="3.jpg"></p><h2 id="为什么我们要关注线性变换"><a href="#为什么我们要关注线性变换" class="headerlink" title="为什么我们要关注线性变换?"></a>为什么我们要关注线性变换?</h2><ol><li>计算效率高</li><li>容易求解</li><li>多个线性变换的符合构造仍然是线性的</li><li>多个线性变换的乘积可以用单个矩阵来表达</li><li>对各种变换提供了统一的表达方式</li></ol><h2 id="变换的种类"><a href="#变换的种类" class="headerlink" title="变换的种类"></a>变换的种类</h2><p><img src="4.jpg" alt="4.jpg"></p><h3 id="各种变换的特征-经过变换后哪些保持不变"><a href="#各种变换的特征-经过变换后哪些保持不变" class="headerlink" title="各种变换的特征(经过变换后哪些保持不变)"></a>各种变换的特征(经过变换后哪些保持不变)</h3><div class="table-container"><table><thead><tr><th>变换</th><th>不变性</th><th>代数描述</th></tr></thead><tbody><tr><td>线性</td><td>直线保持直线 原点不变性</td><td>$f(ax + y) = af(x) + f(y)$, $f(0) = 0$</td></tr><tr><td>平移</td><td>两点之间相对位置不变</td><td>$f(x-y) = x- y$</td></tr><tr><td>缩放</td><td>直线经过原点 任意一点的方向不变</td><td>$f(x)/\</td><td>f(x)\</td><td>= x/\</td><td>x\</td><td>$</td></tr><tr><td>旋转</td><td>原点保持不变,两点之间距离不变,面的朝向不变</td><td>$\</td><td>f(x) - f(y)\</td><td>= \</td><td>x-y\</td><td>,def(f) &gt; 0$</td></tr></tbody></table></div><h3 id="旋转-Rotation"><a href="#旋转-Rotation" class="headerlink" title="旋转($Rotation$)"></a>旋转($Rotation$)</h3><p><img src="5.png" alt="5.png"><br>旋转有三个特征,保持原点不变,保持两点之间距离不变,保持面的朝向不变,前两个特征意味着<strong>旋转是一个线性变换</strong></p><h4 id="二维旋转"><a href="#二维旋转" class="headerlink" title="二维旋转"></a>二维旋转</h4><p>我们知道旋转保持距离和原点不变,因此,二维旋转(旋转角度$\theta$)会将点$x$映射到同一半径的圆上的一点$f_{\theta}(x)$</p><p>那么当点$x$位于$(1, 0)处时$,逆时针旋转$\theta$,点会被映射到哪里呢?</p><p>根据三角函数可知,该点的坐标被旋转后为$(\cos(\theta), sin(\theta))$.</p><p>同理当点位于$(0, 1)$时,被旋转$\theta$角后为$(-\sin(\theta), \cos(\theta))$</p><p><img src="19.png" alt="19.png"></p><p>那么对于任意一个点$(x,y)$,该怎么办呢?<br>我们可以将任意向量分解为两个基向量的线性组合:</p><p>$x = \begin{bmatrix}<br> x1\\<br>x2<br>\end{bmatrix} = x_{1}\begin{bmatrix}<br> 1\\<br>0<br>\end{bmatrix} + x_{2}\begin{bmatrix}<br> 0\\<br>1<br>\end{bmatrix}$</p><p>通过上边的推导(特殊的两个点/basis),我们知道二维空间下基向量是如何旋转的,<strong>因此只需要简单的应用基向量的线性组合.</strong></p><p><img src="20.png" alt="20.jpg"></p><p>$f(x) = x_{1}\begin{bmatrix}<br> \cos(\theta)\\<br>\sin(\theta)<br>\end{bmatrix} + x_{2}\begin{bmatrix}<br> -\sin(\theta)\\<br>\cos(\theta)<br>\end{bmatrix}$</p><p><strong>二维旋转的矩阵表示:</strong></p><p>$f_{\theta}(x) = \begin{bmatrix}<br> \cos(\theta)&amp;-\sin(\theta)\\<br>\sin(\theta)&amp;\cos(\theta)<br>\end{bmatrix}$</p><h4 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h4><p>在三维空间,如何围绕基向量$Z$旋转?只需要保持该基向量不变,其他应用二维变换即可:</p><p>$\begin{bmatrix}<br>  \cos(\theta)&amp;-\sin(\theta) &amp; 0 \\<br>  \sin(\theta)&amp;\cos(\theta) &amp; 0 \\<br>   0 &amp; 0  &amp; 1<br>\end{bmatrix}$</p><p>围绕$X$旋转:</p><p>$\begin{bmatrix}<br>  1 &amp; 0 &amp; 0\\<br>  0 &amp; \cos(\theta)&amp;-\sin(\theta)\\<br>  0 &amp; \sin(\theta)&amp;\cos(\theta)<br>\end{bmatrix}$</p><p>围绕$Y$旋转:</p><p>$\begin{bmatrix}<br>  \cos(\theta) &amp; 0 &amp; \sin(\theta)\\<br>  0 &amp; 1&amp; 0\\<br>  -\sin(\theta) &amp; 0&amp;\cos(\theta)<br>\end{bmatrix}$</p><p><img src="21.png" alt="21.jpg"></p><h4 id="旋转矩阵-矩阵的转置-矩阵的逆"><a href="#旋转矩阵-矩阵的转置-矩阵的逆" class="headerlink" title="旋转矩阵: 矩阵的转置 = 矩阵的逆"></a>旋转矩阵: 矩阵的转置 = 矩阵的逆</h4><p>旋转会将标准正交基变换为另外一个正交基$e_{1},e_{2},e_{3}$,旋转矩阵可以用正交基$e_{1},e_{2},e_{3}$来表示,其中每个基向量做为旋转矩阵的一列,而矩阵的转置是将矩阵的每一列放到对应的行，有趣的地方来了，将两个矩阵相乘，用前一个矩阵的当一行点乘后一个矩阵的当前列做为结果矩阵的当前元素，我们知道变换后的基向量是正交基(根据旋转矩阵的性质),根据正交基的定义,基向量相互垂直,向量均为单位向量,长度为1，因此：</p><p><img src="22.png" alt="21.jpg"></p><p><strong>重要结论</strong></p><p>$R^TR = I$</p><p>$R^{-1}R = I$</p><p>$R^TR = R^{-1}R$</p><p>$\Longrightarrow  R^T = R^{-1}$</p><p><strong>旋转矩阵的转置等于它的逆矩阵</strong>,这个结论为什么很有用呢,因为矩阵的逆比较难计算,而矩阵的转置计算相对简单,因此我们可以利用旋转矩阵的这一特殊性质求它的逆矩阵:转置即可.</p><h3 id="反射矩阵-Relection"><a href="#反射矩阵-Relection" class="headerlink" title="反射矩阵($Relection$)"></a>反射矩阵($Relection$)</h3><p>那么,任何满足$Q^TQ = I$的矩阵都是旋转矩阵吗?<br>考虑下边的矩阵:</p><p>$Q = \begin{bmatrix}<br>  -1&amp;0 \\<br>  0&amp;1<br>\end{bmatrix}$   $Q^TQ = \begin{bmatrix}<br>  (-1)^2&amp;0 \\<br>  0&amp;1<br>\end{bmatrix} = I$</p><p><img src="18.jpg" alt="18.jpg"></p><p>那么$Q$是旋转矩阵吗?显然不是的,该矩阵描述了水平方向上的镜像变换,违反了旋转矩阵的面朝向不变性,本质上它是一个反射矩阵($Reflections$)</p><h3 id="正交矩阵-Orthogonal-Transformations"><a href="#正交矩阵-Orthogonal-Transformations" class="headerlink" title="正交矩阵($Orthogonal Transformations$)"></a>正交矩阵($Orthogonal Transformations$)</h3><p>我们将这种类型的矩阵(保持距离和原点不变)称之为正交矩阵,旋转矩阵和反射矩阵都是正交矩阵的子集,代数表示:</p><p>$Q^TQ = I$</p><p>旋转矩阵: 除了保持距离和原点不变以外,还会保持朝向不变: $det(Q) &gt;0$</p><p>反射矩阵: 反转朝向:$det(Q) &lt; 0$</p><p>本章我们深入了解了其中两种变换,旋转和反射,并将其推广到了更泛化的定义:正交矩阵,下一章我们将深入探讨缩放/错切/平移变换。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（十一）：信号处理</title>
      <link href="/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（十一）：信号处理"><a href="#计算机图形学（十一）：信号处理" class="headerlink" title="计算机图形学（十一）：信号处理"></a>计算机图形学（十一）：信号处理</h1><p>在图形学中,通常要处理些连续变量的函数:图片是你见过的第一个例子，但是当你继续探索图形学的时候，你会遇到很多类似的情况.就其本质而言,计算机无法直接表达连续的函数,必须使用有限的位数表达他们- <strong>采样(将函数的值离散的存储起来,在需要时进行重建).</strong><br>本章首先用数字音频的具体一维例子来总结采样和重构。然后，我们继续介绍在一维和二维的采样和重构基础上的基本数学和算法。最后，我们深入频域观点的细节，它为这些算法的行为提供了许多见解。</p><h2 id="数字音频-一维采样"><a href="#数字音频-一维采样" class="headerlink" title="数字音频: 一维采样"></a>数字音频: 一维采样</h2><p>尽管采样在电信领域已经应用了很多年,但随着数字音频的使用增加，1982年cd的推出是采样在消费者中的第一次大规模应用.<br><img src="1.jpg" alt="alt"><br>在录音过程中，麦克风将空气中以压力波形式存在的声音转换成时变的电压，这相当于在麦克风所在的位置测量空气压力的变化。这种电信号需要以某种方式储存起来，以便在以后的某个时间播放，并发送到扬声器中，通过与电压同步移动膜片，将电压转换回压力波.<br>录制音频的过程中使用了采样技术, 模数转换器 analog-to-digital converter (A/D converter, or ADC)每秒钟数千次测量电压,生成容易被存储下来的数据流(例如记录在计算机硬盘中).<br>在回放时,数据流以适当的速率被读取,并被发送到数模转换器 digital-to-analog converter (D/A converter, or DAC),DAC根据它接收到的数字产生一个电压，并且如果我们取足够多的样本来表示电压的变化，所得到的电信号，都是相同的输入信号.<br>事实证明，每秒钟需要多少样本来完成一次良好的录制，取决于我们试图记录的声音有多高。一个可以很好录制弦乐低音或者鼓的采样率，应用于录制短笛或铙钹，就会产生奇怪的结果;但这些声音在较高的采样率下被录制得很好。为了避免这些采样不足的影响，数字音频记录器对ADC的输入进行滤波，去除可能导致问题的高频。<br>另一种问题出现在输出端。DAC产生的电压在新采样进入时发生变化，但在下一个采样进入前保持不变，产生阶梯型的波形。这些楼梯就像噪音一样，增加了一种高频的、依赖于信号的嗡嗡声。为了消除这种重建带来的问题，数字音频播放器过滤DAC的输出以平滑波形.</p><h2 id="采样偏差与失真"><a href="#采样偏差与失真" class="headerlink" title="采样偏差与失真"></a>采样偏差与失真</h2><p>数字音频记录链可以作为采样和重建过程的具体模型，发生在图形中。同样的欠采样和重构伪影也会发生在图像或图形中的其他采样信号上，解决方法是一样的:采样前进行滤波，重构时再进行滤波.<br><img src="2.png" alt="alt"><br>上图显示了一个由过低的采样频率导致的走样具体例子。在这里，我们用两种不同的采样频率对一个简单的正弦波进行采样:顶部的高频采样和底部的低频采样。高频采样显然能够更好的还原信号,但是由低采样率产生的样本与低频正弦波的样本是无法区分的.<br>一旦采样完成，就无法区分两个信号——快正弦波和慢正弦波——哪个是原始信号，因此没有单一的方法可以在这两种情况下正确地重建信号。因为高频信号可以“假装”成低频信号，这种现象被称为失真。<br>在图形领域,失真经常表现为: </p><ul><li>摩尔纹(moire patterns)  </li><li>边缘锯齿</li></ul><p>采样和重构的基本问题可以简单地根据特征太小或太大来理解，但一些更定量的问题很难回答:</p><ul><li>多高的采样率能够还原重建结果?</li><li>什么样的滤波器适合于采样和重建?</li><li>为了避免失真,需要多大程度的平滑过渡?</li></ul><h2 id="卷积-Convolution"><a href="#卷积-Convolution" class="headerlink" title="卷积(Convolution)"></a>卷积(Convolution)</h2><p>在讨论采样和重建相关算法之前,首先需要明确相关的基础数学概念-<strong>卷积</strong>.卷积是一个简单的数学概念，它构建了采样、滤波和重构的算法基础.卷积是对函数的一种操作:它接受两个函数作为参数,生成一个新的函数.本书中采用星号(★)作为标记.对函数f和g应用卷积的结果为 f★g.<br>卷积即可以应用于连续函数,也可以应用于离散序列的函数. 它可以应用于定义在一维、二维或高维域上的函数(即具有一个、两个或多个参数的函数)。</p><h3 id="移动的平均数-平滑处理"><a href="#移动的平均数-平滑处理" class="headerlink" title="移动的平均数(平滑处理)"></a>移动的平均数(平滑处理)</h3><p>为了对卷积有一个基本概念上的认识，考虑使用移动平均来平滑一维函数的例子。为了得到任意点的平滑值，我们在每个方向上扩展距离r的范围内计算函数的平均值。距离r称为平滑操作的半径，是一个参数，控制平滑计算的采样范围.<br><img src="3.jpg" alt="alt"><br>对于离散函数或连续函数，我们可以用数学方法来表述这个概念。</p><ul><li>如果我们平滑一个连续函数g(x)，平均意味着在一个区间上对g积分，然后除以区间的长度:</li></ul><p><img src="4.jpg" alt="alt"></p><ul><li>另一方面,如果要平滑处理一个离散函数a[i],平均意味着将一系列的a相加，然后除以数值的个数:</li></ul><p><img src="5.jpg" alt="alt"></p><p><strong>移动平均线的概念是卷积的本质;唯一的区别是在卷积中移动平均是一个加权平均。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（十）：柏林噪声</title>
      <link href="/2023/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/"/>
      <url>/2023/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（十）：柏林噪声"><a href="#计算机图形学（十）：柏林噪声" class="headerlink" title="计算机图形学（十）：柏林噪声"></a>计算机图形学（十）：柏林噪声</h1><h2 id="Perlin-Noise"><a href="#Perlin-Noise" class="headerlink" title="$Perlin\;Noise$"></a>$Perlin\;Noise$</h2><p>1985年，$Ken\;Perlin$发表了一篇名为《A Image Synthetizer》的Siggraph学术论文。提出了一种类似于之前介绍的噪声函数算法,但是表现更好。柏林噪声和之前的噪声函数很相似，和$Value\;Noise$一样，它也依赖于网格系统。在网格的每个顶点处定义随机值，然后对其进行插值以计算空间中某个位置的噪声值。之前我们详细介绍了1D和2D$Value\;Noise$的创建。本章将实现$Perlin\;Nosie$的3D版本。那么$Perlin\;Nosie$和$Value\;Noise$有什么区别呢？对于$Value\;Noise$来说，我们只需在网格的顶点处分配随机数，采样点对所在单元格四个顶点做双线性插值即可。在$Perlin\;Nosie$中，$Ken\;Perlin$建议将网格顶点的随机值替换为梯度（归一化的三维向量），方法是在$[0,1]$范围内生成三个随机浮点数，再将这些随机数重映射到$[-1,1]$范围内，最后对向量进行归一化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> gradients = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">    gradients[i] = <span class="title function_">vec3</span>(<span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>);</span><br><span class="line">    gradients[i] = gradients[i].<span class="title function_">normalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>相比通过随机数插值的$Value\;Noise$，$Perlin\;Nosie$在网格顶点分布的是三维向量，由于噪声函数需要返回一个浮点数，如何通过三维向量生成浮点数呢？$Ken\;Perlin$建议计算每个网格顶点到我们要计算的点$p$的方向向量，我们可以得到8个3D向量（一个立方体有8个角或顶点）和4个2D向量（二维）。然后计算网格顶点的梯度和从该顶点到$p$点向量的点积。由于向量点积返回一个浮点数，因此，我们将梯度或向量转换为了浮点数。与2D情况一样，为了计算点$p$在3D网格中的坐标，我们将点坐标从浮点数转换为整数值($floor$)，然后将这些整数坐标取模$N$，即随机方向的数组（N = 256）。正如在上一章中解释的那样，我们不想生成256x256x256方向的网格。使用包含256个随机方向的单个一维数组，并使用置换表通过将点的整数坐标转换为带有哈希的置换表的索引来“随机拾取”存储在该表中的方向之一。</p><p>代码实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableSize = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> tableSizeMask = tableSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> gradients = [];</span><br><span class="line"><span class="keyword">const</span> permutationTable = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerlinNoise</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">            gradients[i] = <span class="title function_">vec3</span>(<span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">1</span>);</span><br><span class="line">            gradients[i] = gradients[i].<span class="title function_">normalize</span>();</span><br><span class="line">            permutationTable[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i &lt; tableSize; ++i) </span><br><span class="line">        <span class="attr">std</span>::<span class="title function_">swap</span>(permutationTable[i], permutationTable[<span class="title function_">diceInt</span>() &amp; tableSizeMask]); </span><br><span class="line">        <span class="comment">// extend the permutation table in the index range [256:512]</span></span><br><span class="line">        <span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i &lt; tableSize; ++i) &#123; </span><br><span class="line">            permutationTable[tableSize + i] = permutationTable[i]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">hash</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, z: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">permutationTable</span>[<span class="variable language_">this</span>.<span class="property">permutationTable</span>[<span class="variable language_">this</span>.<span class="property">permutationTable</span>[x] +y ] + z]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">computeX</span>(<span class="params">p: vec3</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> xi0 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">x</span>) &amp; tableSizeMask;</span><br><span class="line">        <span class="keyword">const</span> yi0 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">y</span>) &amp; tableSizeMask;</span><br><span class="line">        <span class="keyword">const</span> zi0 = math.<span class="title function_">floor</span>(p.<span class="property">z</span>) &amp; tableSizeMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> xi1 = (xi0 + <span class="number">1</span>) &amp; tableSizeMask;</span><br><span class="line">        <span class="keyword">const</span> xi1 = (xi0 + <span class="number">1</span>) &amp; tableSizeMask;</span><br><span class="line">        <span class="keyword">const</span> xi1 = (xi0 + <span class="number">1</span>) &amp; tableSizeMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> tx = p.<span class="property">x</span> - <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">const</span> ty = p.<span class="property">y</span> - <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">const</span> tz = p.<span class="property">z</span> - <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">z</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> u = <span class="title function_">smoothStep</span>(tx);</span><br><span class="line">        <span class="keyword">const</span> v = <span class="title function_">smoothStep</span>(tx);</span><br><span class="line">        <span class="keyword">const</span> w = <span class="title function_">smoothStep</span>(tx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> c000 = gradients[<span class="title function_">hash</span>(xi0, yi0, zi0)]; </span><br><span class="line">        <span class="keyword">const</span> c100 = gradients[<span class="title function_">hash</span>(xi1, yi0, zi0)]; </span><br><span class="line">        <span class="keyword">const</span> c010 = gradients[<span class="title function_">hash</span>(xi0, yi1, zi0)]; </span><br><span class="line">        <span class="keyword">const</span> c110 = gradients[<span class="title function_">hash</span>(xi1, yi1, zi0)]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> c001 = gradients[<span class="title function_">hash</span>(xi0, yi0, zi1)]; </span><br><span class="line">        <span class="keyword">const</span> c101 = gradients[<span class="title function_">hash</span>(xi1, yi0, zi1)]; </span><br><span class="line">        <span class="keyword">const</span> c011 = gradients[<span class="title function_">hash</span>(xi0, yi1, zi1)]; </span><br><span class="line">        <span class="keyword">const</span> c111 = gradients[<span class="title function_">hash</span>(xi1, yi1, zi1)]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> x0 = tx, x1 = tx - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">const</span> y0 = ty, y1 = ty - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">const</span> z0 = tz, z1 = tz - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> p000 = <span class="title function_">vec3</span>(x0, y0, z0); </span><br><span class="line">        <span class="keyword">const</span> p100 = <span class="title function_">vec3</span>(x1, y0, z0); </span><br><span class="line">        <span class="keyword">const</span> p010 = <span class="title function_">vec3</span>(x0, y1, z0); </span><br><span class="line">        <span class="keyword">const</span> p110 = <span class="title function_">vec3</span>(x1, y1, z0); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> p001 = <span class="title function_">vec3</span>(x0, y0, z1); </span><br><span class="line">        <span class="keyword">const</span> p101 = <span class="title function_">vec3</span>(x1, y0, z1); </span><br><span class="line">        <span class="keyword">const</span> p011 = <span class="title function_">vec3</span>(x0, y1, z1); </span><br><span class="line">        <span class="keyword">const</span> p111 = <span class="title function_">vec3</span>(x1, y1, z1); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">const</span> a = <span class="title function_">lerp</span>(<span class="title function_">dot</span>(c000, p000), <span class="title function_">dot</span>(c100, p100), u); </span><br><span class="line">        <span class="keyword">const</span> b = <span class="title function_">lerp</span>(<span class="title function_">dot</span>(c010, p010), <span class="title function_">dot</span>(c110, p110), u); </span><br><span class="line">        <span class="keyword">const</span> c = <span class="title function_">lerp</span>(<span class="title function_">dot</span>(c001, p001), <span class="title function_">dot</span>(c101, p101), u); </span><br><span class="line">        <span class="keyword">const</span> d = <span class="title function_">lerp</span>(<span class="title function_">dot</span>(c011, p011), <span class="title function_">dot</span>(c111, p111), u); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> e = <span class="title function_">lerp</span>(a, b, v); </span><br><span class="line">        <span class="keyword">const</span> f = <span class="title function_">lerp</span>(c, d, v); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">lerp</span>(e, f, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了平滑插值，我们在使用tx ty tz之前对其分别使用smoothStep函数重新映射为uvw。<br>通过代码可以看出，$Perlin\;Nosie$和$Value\;Noise$非常类似，唯一不同的是我们将网格顶点的随机值替换为随机的单位向量，然后计算顶点梯度和顶点到当前点的方向向量的点积。</p><p><img src="1.jpg" alt="perlinNoise"></p><h2 id="均匀分布梯度"><a href="#均匀分布梯度" class="headerlink" title="均匀分布梯度"></a>均匀分布梯度</h2><p>生成均匀分布的随机方向看似很简单，但要正确实现还是比较麻烦的。上述代码生成的随机梯度不是均匀分布的。它们是在立方体的体积内而不是球体的体积内产生随机方向。因此，相对于球体来说分布是不均匀的。一种简单的方案是随机生成单位球坐标$\theta和\phi$，并将这些球坐标转换为笛卡尔坐标：</p><p><img src="7.jpg" alt="二维极坐标系"></p><p>$d = r\sin\phi$</p><p>$x = d\cos\theta = r\sin\phi\cos\theta$</p><p>$y = d\sin\theta = r\sin\phi\sin\theta$</p><p>$z = r\cos\phi$</p><p>根据球坐标系转换笛卡尔坐标系公式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> phi = <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line"><span class="keyword">const</span> theta = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(theta);</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(theta);</span><br><span class="line"><span class="keyword">const</span> z = <span class="title class_">Math</span>.<span class="title function_">cos</span>(theta);</span><br></pre></td></tr></table></figure><p>这种方式看起来很不错,当生成随机球坐标时,这些坐标也确实均匀的分布在定义它的坐标空间中。但是当将矩形包裹到球体上时，可以明显看到矩形被挤压在球体的两极，换句话说，极点附近的密度要大于其它地方，因此这种分布也是不均匀的。</p><p><img src="2.jpg" alt="二维极坐标系"></p><p>我们知道球体的立体角为$4\pi$,$PDF$（概率密度函数）的积分为1，因此，球体微分立体角的概率为$\dfrac{1}{4\pi}$：</p><p>$\int_0^{4\pi} p(w)dw = 1$</p><p>$p(w) = \dfrac{1}{4\pi}$</p><p>用极坐标的形式表达$PDF$：</p><p>$p(\phi, \theta)d\phi d\theta = p(w)dw$</p><p>根据微分立体角的定义可知：</p><p>$dw = \sin\theta d\theta d\phi$</p><p>综合以上两个公式：</p><p>$p(\phi, \theta)d\phi d\theta = p(w)dw$</p><p>$dw = \sin\theta d\theta d\phi$</p><p>$p(\phi, \theta)d\phi d\theta = p(w) \sin\theta d\theta d\phi$</p><p>$p(\phi, \theta) = p(w) \sin\theta$</p><p>$p(\phi, \theta) = \dfrac{\sin\theta}{4\pi}$</p><p>接下来将$p(\phi,\theta)$对$\phi$积分，得到：</p><p>$p(\theta) = \int_{\phi}^{2\pi} p(\phi, \theta) d\phi = \int_{\phi}^{2\pi} \dfrac{\sin\theta}{4\pi} d\phi = 2\pi * \dfrac{\sin\theta}{4\pi} = \dfrac{\sin\theta}{2}$</p><p>$p(\phi) = \dfrac{p(\phi, \theta)}{p(\theta)} = \dfrac{1}{2\pi}$</p><p>至此就得到了$\phi和\theta$的$PDF$,通过$PDF$可以很轻易的计算出$CDF$（累积分布函数）：</p><p>$P_r(X &lt;= \theta) = P(\theta) = \int_0^{\theta} p(\theta)d\theta = \int_0^{\theta} \dfrac{\sin\theta}{2}d\theta = \dfrac{1}{2} - \dfrac{\cos\theta}{2}$.</p><p>$p(\phi)$的$CDF$求解过程类似：</p><p>$P_r(X &lt;= \phi) = P(\phi) = \int_0^{\phi} \dfrac{1}{2\pi}d\phi = \dfrac{1}{2\pi}[\phi - 0] = \dfrac{\phi}{2\pi}$</p><p>最后反转$CDF$：</p><p>$\xi = \dfrac{1}{2} - \dfrac{\cos\theta}{2}$</p><p>$\dfrac{\cos\theta}{2} = \dfrac{1}{2} - \xi$</p><p>$\cos\theta = 1 - 2\xi$</p><p>$\theta = cos^{-1}(1-2\xi) = cps^{-1}(2\xi-1)$</p><p>$\xi = \dfrac{\phi}{2\pi}$</p><p>$\phi = 2\pi\xi$</p><p>其中希腊字母$\xi$表示[0,1]范围内均匀分布的随机数。也就是说要在球体表面上生成均匀的随机点，需要对代码做优化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> theta = <span class="title class_">Math</span>.<span class="title function_">arccos</span>(<span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> phi = <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="title class_">Math</span>.<span class="title function_">cos</span>(phi)*<span class="title class_">Math</span>.<span class="title function_">sin</span>(theta);</span><br><span class="line">    <span class="keyword">const</span> y = <span class="title class_">Math</span>.<span class="title function_">sin</span>(phi)*<span class="title class_">Math</span>.<span class="title function_">sin</span>(theta);</span><br><span class="line">    <span class="keyword">const</span> z = <span class="title class_">Math</span>.<span class="title function_">cos</span>(theta);</span><br><span class="line">    gradients[i] = <span class="title function_">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Perlin-Noise-相比-Value-Nosie-优势"><a href="#Perlin-Noise-相比-Value-Nosie-优势" class="headerlink" title="$Perlin\;Noise$相比$Value\;Nosie$优势"></a>$Perlin\;Noise$相比$Value\;Nosie$优势</h2><p>拿一维举例，值噪声在整数位置生成随机数，然后在这些整数位置之间插入这些值，因为这些值是随机选择的，所以几个连续的值可能非常相似，导致噪声的某些部分会快速变化，而某些部分会缓变化慢。噪声函数中变化缓慢的部分频率低，快速变化的部分频率高，这意味着值噪声由高频和低频组成。良好的噪声是一种看起来随机的噪声，局部变化平滑，但通常也呈现出相当均匀的变化。换句话说，构成噪声的特征通常应该具有相似的大小（相似的频率）。这显然不是值噪声的特征。</p><p><img src="3.jpg" alt="二维极坐标系"></p><p>而柏林噪声不同的是，柏林噪声在整数位置生成随机梯度，梯度可以被看作是一维噪声函数的“切线”。<strong>随机的梯度不会导致噪声值的随机</strong>，正如在下图中看到的那样，梯度指向哪个方向并不重要，因为如果它导致曲线在单元格顶点的一侧上，它会导致曲线在同一点的另一侧下降。在最坏的情况下，如果两个连续的单元格顶点梯度指向完全相反的方向（一个指向上方，另一个指向下方），则噪声函数将在两个点之间具有类似“S”的形状。在另一种情况下，曲线将上升或下降。</p><p><img src="4.jpg" alt="二维极坐标系"></p><p>由于这种结构，所有特征都具有或多或少相同的大小并且是平滑连续的。它是两个连续单元格顶点之间的凸起或凹陷或类似“S”的形状。因此，$Perlin\;Noise$的频率分布比$Value\;Noise$的频谱更规则（特别是它消除了后者的低频）。正如Perlin在他的论文中指出的那样：</p><blockquote><p>The above texture has a band-limited character to it; there is no detail outside of a certain range of size.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2">scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（九）：噪声-下</title>
      <link href="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%99%AA%E5%A3%B0-%E4%B8%8B/"/>
      <url>/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%99%AA%E5%A3%B0-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（九）：噪声-下"><a href="#计算机图形学（九）：噪声-下" class="headerlink" title="计算机图形学（九）：噪声-下"></a>计算机图形学（九）：噪声-下</h1><h2 id="2D-Noise"><a href="#2D-Noise" class="headerlink" title="$2D\;Noise$"></a>$2D\;Noise$</h2><p>在上一章中，我们介绍并解释了实现一维噪声函数的大部分技术和方法。创建更高维度的噪声和一维噪声并没有本质上的区别，因为它们都是基于同样的方法和技术。之前提到过，所有的噪声函数都会返回一个浮点数，无论输入参数是浮点数，二维点还是三维点，至于一维噪声 二维或三维噪声仅与其输入值有关。二维噪声是将二维点作为输入参数的噪声函数。<br>对于二维噪声，我们会在网格顶点处分布随机值。噪声函数的2D版本以2D点作为输入，假设当前要求的点为$p$。与一维版本类似，我们先得找到点$p$在网格中的位置，如果点在网格之外，可以通过相同的取模技巧重新映射$p$点的位置，得到网格上点$p$的新坐标，记作$Pnoise$。<br>之前的章节中讲过插值相关的很多内容。</p><p><img src="1.jpg" alt="2dNoise"></p><p>如下图所示：点$Pnoise$被一个单元上的四个顶点所包围。使用之前学到过的双线性插值技术可以轻松得到点$Pnoise$的值（周围四个点的加权平均）：</p><p><img src="2.jpg" alt="2dNoise"></p><p>为此我们首先计算$s和t$，它们是一维噪声中t的对应物：</p><p><img src="3.png" alt="2dNoise"></p><p>代码实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lerp</span>(<span class="params">min:<span class="built_in">number</span>, max: nmber, t: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> min * (<span class="number">1</span>-t) + max * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">smoothStep</span>(<span class="params">t: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * t * (<span class="number">3</span>- <span class="number">2</span> * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueNoise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">K_MAX_TABLE_SIZE</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">K_MAX_TABLE_SIZE_MASK</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">vertices</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE</span> = <span class="number">256</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span> = <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vertices</span> = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE</span> * <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE</span>; i++) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">vertices</span>[i] = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">computeX</span>(<span class="params">p: vec2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> xi = <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">const</span> yi = <span class="title class_">Math</span>.<span class="title function_">floor</span>(p.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">const</span> s = p.<span class="property">x</span> - xi;</span><br><span class="line">        <span class="keyword">const</span> t = p.<span class="property">y</span> - yi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> rx0 = xi &amp; <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span>;</span><br><span class="line">        <span class="keyword">const</span> rx1 = (rx0 + <span class="number">1</span>) &amp; <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span>;</span><br><span class="line">        <span class="keyword">const</span> ry0 = yi &amp; <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span>;</span><br><span class="line">        <span class="keyword">const</span> ry1 = (ry0 + <span class="number">1</span>) &amp; <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过置换表查找四个顶点处的随机值</span></span><br><span class="line">        <span class="keyword">const</span> c00 = <span class="variable language_">this</span>.<span class="property">vertices</span>[ry0 * <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span> + rx0];</span><br><span class="line">        <span class="keyword">const</span> c10 = <span class="variable language_">this</span>.<span class="property">vertices</span>[ry0 * <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span> + rx1];</span><br><span class="line">        <span class="keyword">const</span> c01 = <span class="variable language_">this</span>.<span class="property">vertices</span>[ry1 * <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span> + rx0];</span><br><span class="line">        <span class="keyword">const</span> c11 = <span class="variable language_">this</span>.<span class="property">vertices</span>[ry1 * <span class="variable language_">this</span>.<span class="property">K_MAX_TABLE_SIZE_MASK</span> + rx1];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对得到的s和t做平滑处理</span></span><br><span class="line">        <span class="keyword">const</span> ss = <span class="title function_">smoothStep</span>(s);</span><br><span class="line">        <span class="keyword">const</span> st = <span class="title function_">smoothStep</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> a = <span class="title function_">lerp</span>(c00, c10, ss);</span><br><span class="line">        <span class="keyword">const</span> b = <span class="title function_">lerp</span>(c01, c11, ss);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">lerp</span>(a, b, st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单的模式示例"><a href="#简单的模式示例" class="headerlink" title="简单的模式示例"></a>简单的模式示例</h2><p>本小节将介绍使用噪声函数创建的模式示例。当$Ken\;Perlin$最初发明他的噪声函数时，他还提出了一些简单的算法来使用这个函数作为构建模块来生成有趣的纹理。其中一些例如流噪声（$turbulence $），现在仍然被广泛使用。他在1985年的Siggraph上描述了这些模式中的大部分。</p><p><img src="4.png" alt="2dNoise"></p><p>之前我们实现的基础版噪声看起来有很多的“块状”,如上图所示，左侧是基于当前版本噪声函数生成的纹理，右侧是$Perlin\;Noise$生成的。本章不会讲解$Perlin\;Noise$，而是了解该技术的工作原理和函数特性。基于目前说了解到的噪声函数特性，实现一些略微复杂的纹理效果。</p><h3 id="1D-Noise-示例"><a href="#1D-Noise-示例" class="headerlink" title="$1D\;Noise$示例"></a>$1D\;Noise$示例</h3><p>首先介绍的一种技术叫做分形叠加（$Fractal\;Sum$），其背后思想是叠加几种频率和振幅不同的噪声，每一个噪声称为一个$Layer$，层与层之间的频率和振幅不一样，却是有关联的。<br>如下图所示，第一条噪声曲线是原始噪声函数生成的（频率和振幅均为1），其他各层的频率为上一层的两倍，振幅为1/2，通过这种方式创造一系列的噪声并将它们叠加起来会得到下图底部的函数图像：</p><p><img src="5.png" alt="2dNoise"></p><p>可以看到，这条曲线比单条噪声函数有更丰富的局部细节，这也正是分形叠加所要达到的目的，通过高频低振幅的噪声填充原始曲线的局部细节。将分形叠加推广到二维，生成的二维纹理应用于平面的纹理贴图（displaceMapping），可以生成类似于地形的东西。<br>代码实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amplitude = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> frequency = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//通常被设置为 3，5 或者 7</span></span><br><span class="line"><span class="keyword">const</span> layers = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> noiseSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; layers; i++) &#123;</span><br><span class="line">   noiseSum += <span class="title function_">noise</span>(p * frequency) * amplitude;</span><br><span class="line">   amplitude *= <span class="number">0.5</span>;</span><br><span class="line">   frequency *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>分形叠加（$fractal\;Sum$）:将频率和幅度相互关联的噪声层相叠加的技术可以称为分形叠加。</li><li>粉红噪声（$Pink\;Noise$）:分型噪声的连续层具有与其频率成反比的振幅。</li><li>布朗噪声（$Brownian\;noise$）:当我们将层之间的频率加倍并且这些层的幅度与其频率成反比时，我们会获得一种特殊类型的粉红噪声，我们称之为布朗噪声（以数学家罗伯特布朗命名）。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pinkNoise = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> layers = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> rateOfChange = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; layers; i++) &#123;</span><br><span class="line">    pinkNoise += <span class="title function_">noise</span>(p * <span class="title class_">Math</span>.<span class="title function_">pow</span>(rateOfChange, i)) / <span class="title class_">Math</span>.<span class="title function_">pow</span>(rateOfChange, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>频谱密度（$spectral densities$）:连续层之间的频率和振幅的变化几乎形成了噪声曲线的特征。 它定义了它的光谱特性。 我们使用术语频谱密度来定义产生噪声的各种频率（层）。</li><li><p>功率谱（$power spectra$）:这些层中的每一层都有一个特定的振幅，我们称之为功率谱</p></li><li><p>间隙度（$lacunarity$）:控制层与层之间频率的变化率</p></li><li>$gain$: 控制层与层之间振幅的变化率</li></ul><h3 id="2D-Noise-示例"><a href="#2D-Noise-示例" class="headerlink" title="$2D\;Noise$示例"></a>$2D\;Noise$示例</h3><h4 id="分形叠加（-Fractal-Sum-）"><a href="#分形叠加（-Fractal-Sum-）" class="headerlink" title="分形叠加（$Fractal\;Sum$）"></a>分形叠加（$Fractal\;Sum$）</h4><p>在1D示例中已经介绍额分形叠加的技术原理，在此我们将实现其二维版本：</p><p><img src="6.png" alt="2dNoise"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> layers = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> imageWidth = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> imageHeight = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">let</span> maxNoiseVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> frequency = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> amplitude = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> noiseMap = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; imageWidth; j++) &#123;</span><br><span class="line">        vec2 pNoise = <span class="title function_">vec2</span>(i, j);</span><br><span class="line">        frequency = <span class="number">1</span>;</span><br><span class="line">        amplitude = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; layers; k++) &#123;</span><br><span class="line">            noiseMap[i * imageWidth + j] += noise.<span class="title function_">commputeX</span>(pNoise * frequency) * amplitude;</span><br><span class="line">            frequency *= <span class="number">2</span>;</span><br><span class="line">            amplitude *= <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (noiseMap[i * imageWidth + j] &gt; maxNoiseVal) &#123;</span><br><span class="line">            maxNoiseVal = noiseMap[i * imageWidth + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上程序生成的纹理如下图所示:</p><p><img src="7.png" alt="2dNoise"></p><p>注：因为我们将几层噪声相加，结果可能大于1，因此当我们将值转换为颜色时，将出现问题。解决此问题的其中一个思路是使用clamp函数，将值限制到$[0,1]$之间。但更好的方案是将遍历NoiseMap，每次循环将噪声值除以最大值（存储于maxNoiseVal中）来标准化噪声值数组。</p><p>之前提到过，分形叠加可以生成许多自然中的纹理，例如起伏的地形：</p><p><img src="8.png" alt="2dNoise"></p><p>各种各样的纹理图案都是通过改变分形噪声函数的间隙度（$lacunarity $）和$gain$来控制的：<br><img src="9.png" alt="2dNoise"></p><h4 id="流噪声（-Turbulence-）"><a href="#流噪声（-Turbulence-）" class="headerlink" title="流噪声（$Turbulence$）"></a>流噪声（$Turbulence$）</h4><p><strong>与分形噪声的原理相同，但是流噪声使用的是噪声结果的绝对值</strong>。而不是直接使用每一层噪声函数。我们会先将噪声结果转换为有符号噪声，然后取其绝对值。如下图所示，以这种方式处理噪声函数会生成一个由凹凸组成的轮廓。这种技术可以产生模拟火，烟或云的图案。</p><p><img src="10.png" alt="2dNoise"></p><p>代码示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> frequency = <span class="number">0.02</span>;</span><br><span class="line"><span class="keyword">const</span> lacunarity = <span class="number">1.8</span>;</span><br><span class="line"><span class="keyword">const</span> gain = <span class="number">0.35</span>;</span><br><span class="line"><span class="keyword">const</span> layers = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> maxNoiseVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> imageHeight = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> imageWidth = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> noiseMap = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; imageWidth; j++) &#123;</span><br><span class="line">       vec2 pNoise = <span class="title function_">vec2</span>(j, i);</span><br><span class="line">       amplitude = <span class="number">1</span>;</span><br><span class="line">       frequency = <span class="number">0.02</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; layers; k++) &#123;</span><br><span class="line">            noiseMap[i * imageWidth + j] = noise.<span class="title function_">computeX</span>(pNoise * frequency) * amplitude;</span><br><span class="line">            frequency *= lacunarity;</span><br><span class="line">            amplitude *= gain;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(noiseMap[i * imageWidth + j] &gt; maxNoiseVal)&#123;</span><br><span class="line">            maxNoiseVal = noiseMap[j * imageWidth + j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageWidth * imageHeight; i++) &#123;</span><br><span class="line">   noiseMap[i] /= maxNoiseVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大理石纹理（-Marble-Texture-）"><a href="#大理石纹理（-Marble-Texture-）" class="headerlink" title="大理石纹理（$Marble\;Texture$）"></a>大理石纹理（$Marble\;Texture$）</h4><p>大理石纹理可以通过噪声函数或分形和调制正弦的相位来创建，关键点在于不直接使用噪声函数创建纹理，而是扰乱创建纹理的函数。这个想法可以用任何周期性函数中引入随机性。<br><img src="11.png" alt="2dNoise"></p><p>示例代码如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> frequency = <span class="number">0.02</span>;</span><br><span class="line"><span class="keyword">const</span> lacunarity = <span class="number">1.8</span>;</span><br><span class="line"><span class="keyword">const</span> gain = <span class="number">0.35</span>;</span><br><span class="line"><span class="keyword">const</span> layers = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> maxNoiseVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> imageHeight = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> imageWidth = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> noiseMap = [];</span><br><span class="line"><span class="keyword">let</span> noiseVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; imageWidth; j++) &#123;</span><br><span class="line">       vec2 pNoise = <span class="title function_">vec2</span>(j, i);</span><br><span class="line">       amplitude = <span class="number">1</span>;</span><br><span class="line">       frequency = <span class="number">0.02</span>;</span><br><span class="line">       noiseVal = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; layers; k++) &#123;</span><br><span class="line">            noiseVal = noise.<span class="title function_">computeX</span>(pNoise * frequency) * amplitude;</span><br><span class="line">            frequency *= lacunarity;</span><br><span class="line">            amplitude *= gain;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(noiseVal &gt; maxNoiseVal)&#123;</span><br><span class="line">            maxNoiseVal = noiseVal;</span><br><span class="line">       &#125;</span><br><span class="line">       noiseMap[j * imageWidth + i] = (<span class="title function_">sin</span>((i + noiseValue * <span class="number">100</span>) * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">200</span>) + <span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageWidth * imageHeight; i++) &#123;</span><br><span class="line">   noiseMap[i] /= maxNoiseVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="木纹（-Wood-Texture-）"><a href="#木纹（-Wood-Texture-）" class="headerlink" title="木纹（$Wood\;Texture$）"></a>木纹（$Wood\;Texture$）</h4><p>与大理石纹理一样，木质纹理依赖于一个很简单的技巧。基本思想是将噪声函数乘以大于1的某个值。让我们将这个乘法结果称为$g$,纹理是通过从其整数部分减去$g$获得的。因此减法结果必然在$[0,1)$之间。</p><p><img src="12.png" alt="2dNoise"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = noise.<span class="title function_">computeX</span>(<span class="title function_">vec2</span>(i, j) * frequency) * <span class="number">10</span>;</span><br><span class="line">noiseMap[i * imageWidth + j] = g - <span class="title class_">Math</span>.<span class="title function_">floor</span>(g);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.scratchapixel.com/">Scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（八）：噪声-上</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%99%AA%E5%A3%B0-%E4%B8%8A/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%99%AA%E5%A3%B0-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（八）：噪声-上"><a href="#计算机图形学（八）：噪声-上" class="headerlink" title="计算机图形学（八）：噪声-上"></a>计算机图形学（八）：噪声-上</h1><p>本章将介绍噪声的基础内容，包括噪声是什么，它的属性以及可以用来做什么。噪声不是一个难以理解的复杂概念，但它有许多微妙之处需要注意。 正确使用它需要了解它的工作原理和实现方式。 为了创建一些图像并使用各种参数进行实验，我们将实现一个简单（但功能齐全）的噪声函数，称为$Value Noise$。 本章我们将忽略许多过于复杂而无法在此处全面研究的技术，只是对噪声及其一些应用的初步介绍。 </p><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>噪声是在80年代中期发明的，起初是作为图像纹理的替代方法。主要原因在于80年代中期的电脑内存有限，无法容纳用于纹理映射的图片，于是人们开始寻找替代解决方案。用纯色渲染物体看起来太无趣了，需要通过调整物体的表面材质属性来打破这种干净的外观。在编程中，我们通常在需要创建随机时使用伪随机数生成器。然而使用$RNG(Random\;number\;generator)$是远远不够的。我们在自然界中观察到的随机模式通常是很自然的，物体表面上距离很近的两个点通常看起来会比较相似。但是同一物体上相距很远的两个点却差异很大。换句话说：<strong>局部变化是细微的，是渐进的，而全局变化则是很大的。</strong>$RNG$无法满足这个要求，因为每次调用随机数生成器它会返回和其它数值完全不相干的随机数。因此调用这个函数会产生两个完全不同的数字，最终产生杂乱无章的白噪声。下面是一个例子：让我们观察一块真实岩石的图像，假设我们想要复现该CG图像。这个例子很有趣，因为我们可以看到岩石图案由三种颜色组成：绿色，粉色和灰色。这些颜色或多或少分布在岩石表面上。我们首先使用随机数生成器的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateRandPattern</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">unsigned</span> imageWidth, imageHeight; </span><br><span class="line">    imageWidth = imageHeight = <span class="number">512</span>; </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> kNumColors = <span class="number">3</span>; </span><br><span class="line">    Color3f rockColors[ kNumColors ] = &#123; </span><br><span class="line">        &#123; <span class="number">0.4078</span>, <span class="number">0.4078</span>, <span class="number">0.3764</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0.7606</span>, <span class="number">0.6274</span>, <span class="number">0.6313</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0.8980</span>, <span class="number">0.9372</span>, <span class="number">0.9725</span> &#125; &#125;; </span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofs</span><span class="params">( <span class="string">&quot;./rockpattern.ppm&quot;</span> )</span></span>; </span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;P6\n&quot;</span> &lt;&lt; imageWidth &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; imageHeight &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; imageWidth; ++j ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; imageHeight; ++i ) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">unsigned</span> colorIndex = std::<span class="built_in">min</span>( <span class="built_in">unsigned</span>( <span class="built_in">drand48</span> () * kNumColors ), kNumColors - <span class="number">1</span> ); </span><br><span class="line">            ofs &lt;&lt; <span class="built_in">uchar</span>( rockColors[ colorIndex ][ <span class="number">0</span> ] * <span class="number">255</span> ) &lt;&lt; </span><br><span class="line">                   <span class="built_in">uchar</span>( rockColors[ colorIndex ][ <span class="number">1</span> ] * <span class="number">255</span> ) &lt;&lt; </span><br><span class="line">                   <span class="built_in">uchar</span>( rockColors[ colorIndex ][ <span class="number">2</span> ] * <span class="number">255</span> ); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    ofs.<span class="built_in">close</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="RNG"></p><p>上图中间的图像是程序生成的，结果并不理想，实际上这个模式有个名字，白噪声（$white\;Noise$）（稍后会解释什么是白噪声）。使用$RNG$为程序生成纹理的每个像素随机选择一种颜色，使得结果中每个像素的颜色变化很大。为了改进结果，我们复制了纹理的一小块区域（10x10像素），将其调整到原始图像的尺寸（256x256），进行高斯模糊处理，生成的图像如上右所示，局部有了较小的变化，而全局变化比较明显。</p><p>这个实验结论告诉我们，为了创建平滑的随机图案，需要在网格的固定位置上使用$RNG$分配随机数，然后使用高斯模糊来模糊这些值。下章将详细介绍如何对随机数做模糊，现在只需要记住：<strong>噪声（在图形学上下文中）是一个用于模糊在网格上生成的随机数的函数。</strong></p><p>目前应用最广泛的噪声版本是由$Ken\;Perlin$在1983年实现的，称为柏林噪声（$Perlin\;Noise$）当时他正在制作1982年版本的电影 Tron（© Walt Disney Pictures）。肯·柏林 (Ken Perlin) 于1997年获得美国电影艺术与科学学院颁发的奥斯卡技术成就奖，以表彰他对这部电影的贡献。 他于1984年在Siggraph展示了他的工作，并于1985年发表了一篇论文《An Image Synthesiser》，这是程序化纹理开创性的成果。Perlin噪声会在后续章节中进行解释。</p><p><img src="2.jpg" alt="RNG"></p><h2 id="程序化纹理的世界"><a href="#程序化纹理的世界" class="headerlink" title="程序化纹理的世界"></a>程序化纹理的世界</h2><p>噪声的发展引领了计算机图形学研究的一个全新领域，噪声可以被视为一个基本的构件模块，从中可以生成许多有趣的程序化纹理。在程序化纹理的世界中，可以生成许多类型的纹理，它们不一定都是模仿自然中的图案，可以是规则的，不规则的或随机的。<br>除了规则图案,所有其它的图案都可以使用噪声来生成纹理,自从$Ken\;Perlin$发明了他的噪声函数以来,工业界开始逐渐使用它来生成复杂的材质纹理,例如 地形, 云 水体模拟等.噪声不仅可以通过生成纹理改变物体表面着色,也可以用于程序化建模,替换物体表面结构(地形),控制体积密度(体积渲染).通过每帧偏移噪声输入值,我们也可以将它应用于程序化动画.直到90年代中期,它是最受欢迎的水体模拟动画方法.</p><h2 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h2><p>在本章开始我们就提到,噪声不同于纹理,相较于纹理贴图不会占用很大的内存,同时噪声函数的实现也并不复杂.最后,使用噪声为对象添加纹理不需要表面的任何参数化数据,但这通常是纹理映射所必须的($uv$)。</p><p>但是，噪声函数生成通常比纹理映射要慢。噪声函数需要执行一些相对复杂的数学运算，而纹理映射仅读取纹理图片的每个纹素数据即可。</p><h2 id="噪声的属性"><a href="#噪声的属性" class="headerlink" title="噪声的属性"></a>噪声的属性</h2><p><strong>噪声是伪随机的</strong>。这可能是它最重要的一个属性。它看起来像是随机的，可实际上确实有迹可循的。输入相同的参数，噪声函数总会返回同样的数值。</p><p><strong>噪声函数总是返回一个浮点数，无论输入数据的维度是多少</strong>。输入数据的维度通过噪声函数的名字来表达，1D 2D 3D噪声函数分别表示函数的入参是一个数值，二维的点，三维的点。另外还有4D噪声，它的输入参数有两个，一个三维点和一个额外的浮点值，用于随着时间的推移对噪声进行动画处理。从数学上讲噪声函数实际上是一个从$\mathbb{R}^n$到$\mathbb{R}$的映射。它以n维点作为输入返回一个浮点数。1D噪声通常用于物体动画，2D和3D噪声用于生成物体表面纹理，另外3D噪声对于体渲染很有用。</p><p><strong>噪声是有限带宽$band\;limited$的</strong>。噪声是一个函数，可以将其视为一种信号（如果绘制噪声的函数图像，将得到一条曲线，即<strong>信号</strong>），在信号处理中，可以将信号从时域空间转换到频域空间，通过频域分析，能够直观的看到构成信号的不同频率。噪声函数可能由多个频率组成（低频表现为宏观变化，高频表现为微观局部的变化）。这些频率中的其中一个会起到主导作用，这一频率定义了噪声函数的整体视觉效果和特征。为什么我们要关心噪声函数的频率？因为当生成的噪声纹理在离相机很远的地方是，会表现为<strong>白噪声</strong>，俗称混叠或走样（$aliasing$）。</p><p><img src="3.gif" alt="RNG"></p><p>之前我们提到过噪声函数使用插值函数或其它平滑函数（高斯模糊等）来模糊各点处生成的随机数，这些平滑函数必须具备两个属性：<strong>连续和可导</strong>。在某些情况下需要计算噪声函数的导数，所以最好选择一个即连续又可导的平滑函数。</p><p>最后，当观察一幅由噪声函数生成的图像时，理想情况下不应该能看到噪声模式的重复，换句话说，没有明显边界（接缝处很自然无痕迹），一开始提到，噪声只能在预先定义的尺寸上生成。如果需要计算的噪声超过了噪声函数预定义尺寸的大小该怎么做呢？我们可以把预定义尺寸的噪声比作瓷砖，要使用特定大小的瓷砖覆盖更大的区域时，需要将许多瓷砖彼此相邻平铺。但是这种方法有一些问题。在瓷砖边界处，噪声可能是不连续的。但是我们想要的是从瓷砖到瓷砖的自然过渡，不会看到接缝的存在。</p><h2 id="一维噪声函数"><a href="#一维噪声函数" class="headerlink" title="一维噪声函数"></a>一维噪声函数</h2><p>噪声是一个函数，返回一个介于0到1之间的浮点数。输入参数可能是一维的二维的或者三维四维。本小姐将主要介绍一维入参的情况。可以使用一个伪随机数生成器生成这些浮点数，但每次调用噪声函数会生成完全不可预测的数值，这不是我们想要的，完全基于$RNG$的噪声函数通常被称为白噪声（$White\;Noise$）。这种方法生成的数据不适合作为程序化纹理，因为自然界中的噪声纹理通常都是自然的。</p><p><img src="1.png" alt="WHITEnoise"></p><p>首先要做的是以固定间隔创建一个网格。在二维空间中，将在网格中的顶点处生成这些随机值，在一维中这个网格可以被视为一个标尺，为了简单起见,假设网格的顶点或标尺的刻度沿着x和y轴创建。</p><p><img src="2.png" alt="WHITEnoise"></p><p>创建$2D\;Noise$需要将随机数分配给网格的每个顶点处。对于$1D\;Noise$，随机数将会被分配到x轴固定的间隔处。无论1D还是2D，顶点坐标均为整数，在本示例中，我们仅对前10个数执行此操作，从0到9。</p><p>先拿$1D\;Noise$举例说明，在标尺上的整数位置处生成一系列的随机值。例如：当x = 0结果为0.36， x=1结果为0.68，但是当x不是整数时，函数的结果是什么呢？<br>要计算x轴上任意点的值，需要做的就是找出x轴上该输入值临近的两个整数值（$floor$和$ceil$）。为了计算这个数字，通过线性插值即可（$Linear\;interpolation$）：</p><p>$a(1-t) +bt\;\;\;with\; 0 &lt;=t\;&lt;=\;1$</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求出当前位置临近的最小值和最大值</span></span><br><span class="line"><span class="keyword">const</span> currentX = <span class="number">1.27</span>;</span><br><span class="line"><span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">floor</span>(currentX);</span><br><span class="line"><span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(currentX);</span><br><span class="line"><span class="comment">//拿到最小值和最大值位置的值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getValueByX</span>(min);</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">getValueByX</span>(max);</span><br><span class="line"><span class="comment">//求出当前时间t</span></span><br><span class="line"><span class="keyword">const</span> t = currentX - min;</span><br><span class="line"><span class="comment">//线性插值计算当前位置的值。</span></span><br><span class="line"><span class="keyword">return</span> a*(<span class="number">1</span>-t) + b*t;</span><br></pre></td></tr></table></figure><p>使用线性插值计算$[0,1]$范围内任意x值类似于画了一条直线（<strong>线性</strong>）,如果对其它区间的任意x值执行相同的操作，我们会得到如下图所示的曲线。通过这种线性插值技术产生的噪声我们称之为$Value\;Noise$;</p><p><img src="3.jpg" alt="WHITEnoise"></p><p>我们只在x轴上从x = 0 开始的每个整数位置定义了10个随机值，因此我们只能为$[0,10]$范围内的任何x计算一个值。 为什么[0:10]而不是[0:9]？ 当x在[9:10]范围内时，我们将使用索引9和索引0处的随机值来计算噪声值。如果这样做，曲线的起点和终点是相同的。 换句话说，当x = 0 和x = 10 时的噪声是相同的。让我们复制曲线并将其移动到现有曲线的左侧或右侧。 现有曲线（曲线 1）在 [0:10] 范围内定义，新副本（曲线 2）在 [10:20] 范围内定义。</p><p><img src="4.png" alt="WHITEnoise"></p><p>我们发现在曲线重复连接处没有不连续的情况。因为在曲线1和曲线2是首尾相连的。因此可以根据需要制作任意数量的副本，将噪声函数扩展到无限大。x的值不再限制在$[0,9]$之间。</p><p>接下来就是代码实现部分，我们已经知道如何计算$[0,9]$范围内的噪声，但是当x大于9时，例如x = 9.35，我们希望计算在$[9,0]$之间的插值函数。按照常规做法计算x的临近最小最大值，我们得到9和10。我们想要使用0而不是10，这里可以使用取模运算符来实现。使用这种技术，我们可以在沿x轴移动时重复循环遍历噪声函数（类似于复制原始曲线）。<strong>实现了噪声函数的周期性和连续性。</strong><br>代码实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValueNoise1D</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable constant_">MAX_VERTICES</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">vertices</span>: T[] = [];</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">MAX_VERTICES</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vertices</span>[i] = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">compute</span>(<span class="attr">x</span>: <span class="built_in">number</span>):T &#123;</span><br><span class="line">        <span class="keyword">const</span> xFloor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x);</span><br><span class="line">        <span class="keyword">const</span> xMin = xFloor  % <span class="variable language_">this</span>.<span class="property">MAX_VERTICES</span>;</span><br><span class="line">        <span class="keyword">const</span> t = x - xFloor;</span><br><span class="line">        <span class="keyword">const</span> xMax = (xMin === <span class="variable language_">this</span>.<span class="property">MAX_VERTICES</span> -<span class="number">1</span>)? <span class="number">0</span> : xMin + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">lerp</span>(xMin, xMax, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lerp&lt;T&gt;(<span class="attr">min</span>:T, <span class="attr">max</span>: T, <span class="attr">t</span>: <span class="built_in">number</span>):T &#123;</span><br><span class="line">        <span class="keyword">return</span> min*(<span class="number">1</span>-t) + max*t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平滑插值"><a href="#平滑插值" class="headerlink" title="平滑插值"></a>平滑插值</h3><p>当前版本的噪声函数还存在另外一个问题，锯齿状的函数曲线看起来不够平滑。如果观察自然界中的随机图案，例如水面波纹，海洋波浪的轮廓，它们通常没有这种锯齿感，它们的轮廓通常是自然平滑的。现在让我们改进当前版本的噪声函数，在做插值之前，先通过平滑函数（函数图像表现为“S”形，常用的有$cosine和smoothstep$），针对$t$值做映射（$remap$）。<strong>重要的是要理解插值函数不会改变，我们所作的改变只是在插值前对t值重新映射。</strong><br>伪代码如下：</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">smoothNoise</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, t: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> remapt = <span class="title function_">smoothFunc</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lerp</span>(a, b, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cosine"><a href="#Cosine" class="headerlink" title="$Cosine$"></a>$Cosine$</h4><p>取$\cos$函数在$[0,\pi]$的部分用于t值的remap，对应的输出是$[1,-1]$，但是现在有两个问题需要解决：</p><ol><li>因为t的取值范围是$[0,1]$，在用$\cos$函数remap之前，需要先乘以$\pi$</li><li>输出为$[1,-1]$，我们所期望的输出为$[0,1]$，需要对输出结果做重新映射：$\dfrac{1-\cos{(t*\pi)}}{2}$</li></ol><p><img src="5.jpg" alt="WHITEnoise"></p><pre><code>使用cos函数对t值做重映射后的噪声函数图像</code></pre><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cosineRemap</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, t: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tRemapCosine = (<span class="number">1</span>- <span class="title class_">Math</span>.<span class="title function_">cos</span>(t * <span class="title class_">Math</span>.<span class="property">PI</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lerp</span>(a, b, tRemapCosine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="smoothStep"><a href="#smoothStep" class="headerlink" title="$smoothStep$"></a>$smoothStep$</h4><p>$smoothStep$函数常用于噪声函数的实现，关于$smoothStep$函数的实现原理在之前的文章中有过推导，这里不再赘述。唯一需要注意就是将$smoothStep$函数转换为代码时，由于需要计算t的2和3的幂，可以通过以下代码稍微优化操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">smoothStep</span>(<span class="params">min: <span class="built_in">number</span>, max: <span class="built_in">number</span>, t: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rRemapSmoothStep = t * t * (<span class="number">3</span> - <span class="number">2</span> * t);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lerp</span>(min, max, rRemapSmoothStep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="6.jpg" alt="WHITEnoise"></p><pre><code>使用smoothStep函数对t做重映射后的噪声函数图像</code></pre><h3 id="完善一维噪声函数"><a href="#完善一维噪声函数" class="headerlink" title="完善一维噪声函数"></a>完善一维噪声函数</h3><p>在本小节中，我们将快速展示改变噪声函数形状的不同方法。在原始噪声函数版本中，使用10个随机数生成噪声，之后它将以10为周期循环重复。在实际应用中，如此小的周期往往无法满足实际需求，噪声函数往往需要处理更大的周期，另外代码必须处理x为负值的情况。</p><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>通过对输入值x或者输出结果应用缩放因子，可以很容易的改变函数图像的形状。对输入值$x$应用缩放因子将改变函数频率。将$x$乘以大于1的值将增加函数的周期性（增大噪声频率），简而言之，压缩函数曲线，周期变短。 如果x乘以小于1的值，将会沿着x轴拉伸曲线，延长噪声函数周期（降低频率）。</p><p><img src="7.jpg" alt="WHITEnoise"></p><pre><code>对输入值x乘以缩放因子，来提高或降低噪声函数频率</code></pre><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> frequency = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> freqNoise = valueNoise1D.<span class="title function_">compute</span>(x * frequency);</span><br></pre></td></tr></table></figure><p>第二种情况将函数结果乘以缩放因子，会改变函数图像的振幅（$amplitude$）。</p><p><img src="8.jpg" alt="WHITEnoise"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amplitude = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> amplitudenoise = valueNoise1D.<span class="title function_">compute</span>(x) * amplitude;</span><br></pre></td></tr></table></figure><h4 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h4><p>噪声函数的输入值加上某个偏移值可以实现将函数图像向左（加上正数）或者向右（加上负数）移动。这种通过向x添加偏移量来移动噪声函数的技术对于随着时间推移对函数进行动画处理（增加每帧的偏移值）非常有用。</p><p><img src="9.gif" alt="WHITEnoise"></p><h4 id="有向噪声"><a href="#有向噪声" class="headerlink" title="有向噪声"></a>有向噪声</h4><p>通常噪声函数会返回$[0,1]$范围内的值，但不一定都是这样，取决于它们是如何实现的。可以简单地对噪声函数返回值做重映射来实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signedNoise = <span class="number">2</span> * <span class="title function_">valueNoise1D</span>(x) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="10.jpg" alt="WHITEnoise"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>噪声函数会创建一个随机值数组，其中每个值都被认为位于标尺上的整数位置。这是一个非常重要的观察结果，当我们稍后过滤噪声函数时将非常有用。在本课的第一章中，我们已经提到，当噪声模式太小时，它会再次变成白噪声，并产生一种称为混叠的视觉效果。当噪声函数的频率变得太高时，可以通过过滤噪声函数来消除这种混叠。 问题是要知道什么时候“太高”。这个问题的答案恰好与标尺上每个预定义随机值之间的距离有关：两个连续的随机数相距 1 个单位。记住噪声函数的这个属性是非常重要的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1">Scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphic02-渲染管线-光栅化-采样</title>
      <link href="/2023/01/29/Computer%20Graphic02-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E5%85%89%E6%A0%85%E5%8C%96-%E9%87%87%E6%A0%B7/"/>
      <url>/2023/01/29/Computer%20Graphic02-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E5%85%89%E6%A0%85%E5%8C%96-%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<p>本系列文章将一步步深入介绍计算机在渲染输出呈现一张图片经历的各种步骤细节以及涉及到的相关其他领域的知识串联,例如:几何,渲染方程, 采样, 蒙特卡洛积分,重要性采样, 辐射度量学, 光照计算, 基于物理的渲染等等.本系列文章不涉及API(openGL directX vulkan 等),皆在带你理解这些API背后的图形学原理,理解图形API函数调用的背后到底在做些什么,有了这些知识做铺垫,可以快速上手API的学习,并且发现bug后也可以快速定位问题所在,而不会被GPU的黑盒搞得一头雾水,因为不同的API虽然架构不同,实现不一,但背后的底层逻辑都是一致的。</p><h2 id="光栅化-Rasterization-vs-光追-Ray-tracing"><a href="#光栅化-Rasterization-vs-光追-Ray-tracing" class="headerlink" title="光栅化(Rasterization) vs 光追(Ray tracing)"></a>光栅化(Rasterization) vs 光追(Ray tracing)</h2><p>在本节中，我们将看看渲染到底意味着什么，我们需要解决什么样的问题来将一个三维场景渲染成一张二维图片，以及快速回顾为解决这些问题而实现的种种技术;<strong>本质上渲染需要解决两个问题,1. 可见性, 2.着色.</strong> 我们将集中光线追踪和光栅化两种方法，这两种常用的算法用于解决可见性问题(找到哪些物体在相机视角下的视口(viewport)中是可见的).</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p><img src="1.jpg" alt="1.jpg"></p><p><strong>光栅化本质上是一种基于图元解决可见性问题的一种算法</strong>,所谓基于图元,是指对于每一个图元我们会计算屏幕上哪些像素被该图元覆盖,<strong>光栅化的外层循环为图元集合,内层循环为像素.</strong></p><ul><li>对于每一个图元,屏幕中的哪些像素会被点亮?</li><li>相较于光线追踪,光栅化计算效率很高</li><li>生成照片级图片比较困难(很难处理全局光照问题,但是可以通过其他方式近似模拟, shadow Maps , SSAO IBL SSR等)<h3 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h3></li></ul><p><img src="2.jpg" alt="2.jpg"></p><p>和光栅化从图元出发不同,光线追踪是基于屏幕像素的,从摄像机位置出发，往每个像素方向发射光线($Ray$),计算光线与场景(boundingBox/mesh/primitives)求交,找到最近相交的图元,递归计算光照信息的过程.因此我们可以说<strong>光线追踪是基于屏幕空间像素解决可见性问题的一种算法</strong></p><ul><li>对于每一个像素,能看到哪些图元?</li><li>利用光线追踪算法生成照片级图片很容易,因为它可以通过”追踪光线”递归计算光照轻易解决全局光照问题</li><li>速度要比光栅化要慢</li></ul><h2 id="渲染管线-pipeLine"><a href="#渲染管线-pipeLine" class="headerlink" title="渲染管线(pipeLine)"></a>渲染管线(pipeLine)</h2><p>我们把输入的数据通过一系列步骤最终生成图片的过程称为渲染管线(pipeLine):</p><ol><li>$inputs$: 由顶点构成的3D图元(primitives本质上几乎都是三角形图元, 顶点数据通常包含顶点位置,法线,切线,纹理坐标等等)</li><li>$stages$: 接受渲染管线前一阶段的输出作为输入,加工处理后生成新的数据,做为管线下一阶段的输入</li><li>$outputs$: 位图</li></ol><p><img src="3.jpg" alt="3.jpg"></p><p>在工业界,光栅化渲染管线通常都是由硬件GPU来执行的,GPU相比CPU有更多的处理单元,并发能力更强,可以同时处理更多像素;另外GPU对光栅化中的很多计算(例如重心坐标插值)做了很多优化处理,计算速度非常快,这也是为什么GPU可以很轻松的每秒生成60张图片的一个重要原因.</p><p><img src="6.jpg" alt="6.jpg"></p><h3 id="为什么图元几乎都是三角形"><a href="#为什么图元几乎都是三角形" class="headerlink" title="为什么图元几乎都是三角形?"></a>为什么图元几乎都是三角形?</h3><p>光栅化渲染管线会把所有图元转换成三角形,即使是点和线也不例外.</p><p><img src="5.jpg" alt="5.jpg"></p><p>为什么这样做呢?有以下几点原因:</p><ol><li>三角形能近似表达所有形状,只要三角形数量够多,近似描述任何形状都不成问题.</li></ol><p><img src="4.jpg" alt="4.jpg"></p><ol><li>三角形构成的图元永远都是一个平面, 利于法线计算(法线即为三角形平面的法线)和着色</li><li>光栅化的过程中,容易对三角形的三个顶点进行插值(重心坐标插值/barycentric coordinates)得到像素着色参数</li></ol><p>这样做还有一个很重要的原因就是,一旦所有的图元都转换为三角形,GPU可以只处理三角形,只需要做好这一件事,可以把更多的硬件资源用于优化三角形的绘制($triangle pipeline$)</p><h3 id="光栅化渲染管线"><a href="#光栅化渲染管线" class="headerlink" title="光栅化渲染管线"></a>光栅化渲染管线</h3><p><img src="7.jpg" alt="7.jpg"></p><h3 id="Coverage-amp-Occlusion"><a href="#Coverage-amp-Occlusion" class="headerlink" title="Coverage &amp; Occlusion"></a>Coverage &amp; Occlusion</h3><p>当需要在屏幕上绘制一些三角形时,需要首先考虑的两个问题是,屏幕空间中的哪些像素会被三角形所覆盖?当两个三角形叠加时,屏幕空间的每个像素应该采样哪个三角形的颜色?</p><p><img src="8.jpg" alt="8.jpg"></p><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>其实这两个问题最终解决的都是可见性问题,之前的章节提到渲染本质上需要解决两个问题,一个是可见性,另一个是着色.</p><p>举例1:回顾小孔相机原理, 从小孔朝每个像素的方向看去,我们能看到什么?</p><p><img src="9.png" alt="9.png"></p><p>举例2: 从光线的角度理解可见性问题</p><ul><li>$Coverage$: 从相机位置出发,向每个像素方向发射一条光线,场景中的哪些三角形会被光线击中,这其实间接的给了我们三角形会覆盖哪些像素的信息.</li><li>$Occlusion$: 沿着光线行进的方向,哪个三角形是第一个被击中的,解决了三角形相互遮挡的问题</li></ul><h3 id="Q1-Coverage-哪些像素会被三角形覆盖"><a href="#Q1-Coverage-哪些像素会被三角形覆盖" class="headerlink" title="Q1:Coverage(哪些像素会被三角形覆盖?)"></a>Q1:Coverage(哪些像素会被三角形覆盖?)</h3><p>光栅化阶段的输入是投影到二维屏幕空间的三角形顶点($P_{0},P_{1},P_{2}$),输出为被三角形所覆盖的像素的集合(二值, 1表示被覆盖,0表示未被覆盖,没有中间地带)</p><p><img src="10.png" alt="10.png"></p><p>但是使用二值的方式来表示像素是否被三角形所覆盖会产生很多问题,如下图:</p><p><img src="11.jpg" alt="11.jpg"></p><p>上图的像素被四个三角形中的哪一个所覆盖?使用二值的方式很难精确的回答这个问题,我们不妨改进下像素是否被覆盖的表述方式:<strong>计算像素被三角形覆盖区域占比</strong>,像素着色亮度依照百分比调整.</p><p><img src="12.jpg" alt="12.jpg"></p><p>但是这也是一种理想主义.现实中,当我们考虑三角形叠加覆盖穿插,其实很难实时计算像素被三角形覆盖的占比,如下图所示:</p><p><img src="13.jpg" alt="13.jpg"></p><p>所以与其精确计算三角形覆盖了像素多少,我们能否粗略的对其进行估算呢?<br>答案就是采样(sampling).比如一个像素内均匀划分25个采样点,计算这些采样点哪些被三角形所覆盖是很容易的,然后将被三角形覆盖的采样点数量除以总采样个数,就得到了像素被三角形所覆盖的占比(估算).</p><p>总结:</p><ol><li>现实的场景是非常复杂的,存在三角形相互遮挡,半透明等等问题…</li><li>因此计算精确的覆盖占比是很理想化的</li><li>取而代之,我们可以采用近似的方式,将计算覆盖率的问题转换为采样的问题</li><li>采样不会计算精确的覆盖率,它会测试一系列的采样点,这样在拥有足够多的采样点后,可以达到非常好的近似效果.</li></ol><p><img src="14.jpg" alt="14.jpg"></p><h2 id="采样理论"><a href="#采样理论" class="headerlink" title="采样理论"></a>采样理论</h2><p>本小节,将简单介绍广泛意义上的采样理论,涉及音频,图片,视频等信号处理,会着重介绍采样与重构,香农定理等等,下边我们从最简单的一维信号采样开始.</p><h2 id="采样-Sampling"><a href="#采样-Sampling" class="headerlink" title="采样(Sampling)"></a>采样(Sampling)</h2><h3 id="1D-singal-Sampling"><a href="#1D-singal-Sampling" class="headerlink" title="1D singal Sampling"></a>1D singal Sampling</h3><p>一维信号可以理解为一个函数$f$,参数为$x$</p><p><img src="15.jpg" alt="15.jpg"></p><p>对一维信号采样的过程可以理解为:在函数$f$定义域内取不同的$x$值,计算对应的函数返回值,<strong>采样是对原始连续信号离散化的过程.</strong></p><p><img src="16.jpg" alt="16.jpg"><br>$x_{0}$,$x_{1}$,$x_{2}$,$x_{3}$是函数$f$的一组采样点.</p><p>举一个实际生活中的例子来说明,日常生活中的音频文件(.mp3等),存储的其实就是一维原始信号的离散采样点.$f$是振幅,$x$是时间,音频文件是对时间的离散采样:</p><p><img src="17.jpg" alt="17.jpg"></p><h2 id="重建-Reconstruction"><a href="#重建-Reconstruction" class="headerlink" title="重建(Reconstruction)"></a>重建(Reconstruction)</h2><p>当我们得到一系列的采样点后,最终我们输出的其实是连续信号,如何将这些采样点重建为原始的连续信号$f(x)$?如何填补采样点之间的间隙?  我们先看看最简单的两种方式.</p><ol><li>分段常数近似(piecewise constant approximation)：寻找与当前点最近的采样点,直接使用采样点的值</li></ol><p><img src="18.jpg" alt="18.jpg"></p><ol><li>线性插值：与当前点$x$最近的两个采样点之间做线性插值</li></ol><p><img src="19.jpg" alt="19.jpg"></p><p>但是以上两种方式效果并不好,和原始信号相比差太远,重建后的信号相比原始信号丢失了很多细节,如何提高重建质量?最简单的方式就是提高采样率,这样就会很大程度上减少丢失原始信号细节的风险:</p><p><img src="20.jpg" alt="20.jpg"></p><h3 id="二维信号的采样与重建"><a href="#二维信号的采样与重建" class="headerlink" title="二维信号的采样与重建"></a>二维信号的采样与重建</h3><p>和一维信号一样,图片也是一种信号(二维的),也需要经过采样和重建的过程.如下图所示:左侧图片为原始信号,中间图片为采样/重建(piecewise const)后的信号,右侧图片为采样/重建(peicewise bi-linear)后的信号表示.</p><p><img src="21.jpg" alt="21.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>采样</strong>-是一种测量信号的方法,输入原始连续信号,输出离散的采样点.</p><ol><li>将信号编码为一组离散采样点</li><li>原则上，应该表示特定点的值(特征值)(尽管在现实中很难测量)</li></ol><p><strong>重建</strong>-和采样相反,重建是将一组离散采样点通过重建函数(各种滤波器)生成连续信号的过程.</p><ol><li>构造一个重建函数,通过插值或近似的方式生成函数值,将采样点转换为连续信号.</li><li>不管一维信号, 二维信号 三维信号的采样值,都可以做信号重建.下图分别对一维 二维 三维信号做采样/重建.</li></ol><p><img src="22.jpg" alt="22.jpg"></p><p>那么重新回到主线,对于光栅化,我们是对什么方法做了采样?光栅化为什么可以做为一个采样问题来处理?</p><p>答案是覆盖率函数:</p><p>$coverage(x, y) = \begin{cases}<br>  1, triangle\ contains\ point(x, y)\\<br>  0, otherwise<br>\end{cases}$</p><p><img src="23.jpg" alt="23.jpg"></p><p>对屏幕空间任意一个点做采样(不一定是像素中心点,可以是任意的点),用覆盖率函数判断当前三角形是否覆盖该采样点,如果覆盖则返回1,否则返回0.当然二维平面有无数个点构成(连续信号),而覆盖率函数通过屏幕空间的采样点来近似/逼近三角形对像素的覆盖情况,因此我们说<strong>光栅化本质是一个采样问题.</strong></p><h2 id="边界判定"><a href="#边界判定" class="headerlink" title="边界判定"></a>边界判定</h2><p>假设有一个采样点,正好落在三角形的公共边上,那么覆盖率函数在做采样测试时,该采样点被哪个三角形覆盖了呢?</p><p><img src="24.jpg" alt="24.jpg"></p><p>Opengl/directX定义了一些规则用于解决采样点正好落在三角形边上判定是否被包含的问题,规则如下:<br>当采样点落在三角形边上时,并且该边是三角形的上边或左边时,则判定该采样点被三角形所覆盖.</p><p><img src="25.jpg" alt="25.jpg"></p><h2 id="走样-Aliasing"><a href="#走样-Aliasing" class="headerlink" title="走样(Aliasing)"></a>走样(Aliasing)</h2><p>光栅化过程中,我们首先对屏幕空间做采样</p><p><img src="26.jpg" alt="26.jpg"></p><p>假设每个像素会发射均匀强度的光,则通过采样重建后,在屏幕上我们会看到这样的图片</p><p><img src="27.jpg" alt="27.jpg"></p><p>而实际的原始图片却是这样的</p><p><img src="28.jpg" alt="28.jpg"></p><h3 id="回顾采样和重建"><a href="#回顾采样和重建" class="headerlink" title="回顾采样和重建"></a>回顾采样和重建</h3><p>采样是将自然界 现实中的连续信号离散化为一组采样点,这些采样点其实就是一组数据,拿音频信号举例,在音乐录制时,连续的声音信号被采样录制为音频文件(离散采样点),可以被存储在电脑中,在网络中传输,当需要播放该音频时,播放设备会将采样点重建为连续信号,即我们听到的音乐.</p><p><strong>采样和重建的最终目标是尽可能的还原/逼近原始信号.</strong></p><p><img src="29.jpg" alt="29.jpg"><br>但是如上图所示,重建后的信号丢失了原始信号的很多细节表现.</p><p>那么我们应该通过什么样的角度来理解这种误差呢?<br>前边的文章中我们提到过一个重要的观点,信号是一系列拥有不同频率的信号的线性组合<a href="https://juejin.cn/post/7247342069618049061">(傅里叶变换)</a>:</p><p><img src="30.jpg" alt="30.jpg"></p><p><strong>当我们对一个原始信号做采样时,特别是高频信号,有限的采样点无法表现高频信号的所有细节,这就是造成走样问题的本质.换句话说采样频率低于原始信号频率,丢失了原始信号的细节表现,产生走样.</strong></p><p><img src="31.jpg" alt="31.jpg"></p><blockquote><p>aliasing: high frequencies in original signal masquerade as low frequencies after reconstruction(due to undersampling)</p></blockquote><h3 id="车轮效应"><a href="#车轮效应" class="headerlink" title="车轮效应"></a>车轮效应</h3><p>相机采样频率(对时间的采样)低于轮子旋转的频率(欠采样),造成轮子倒转的视觉效果:</p><p><img src="34.gif" alt="34.gif"></p><p>我们将一维信号延伸到二维空间(image),图片也可以被分解为不同频率信号的线性组合(时域-&gt;频域)</p><p><img src="32.jpg" alt="32.jpg"></p><p><img src="33.jpg" alt="33.jpg"></p><h2 id="香农定理-Nyquist-Shannon-theorem"><a href="#香农定理-Nyquist-Shannon-theorem" class="headerlink" title="香农定理(Nyquist-Shannon theorem)"></a>香农定理(Nyquist-Shannon theorem)</h2><p>考虑一个频带受限的信号，没有高于某个阈值$w_{0}$的频率</p><ul><li>一维信号:低通滤波过滤后的信号</li><li>二维信号:模糊的图片</li></ul><p>信号可以被完美重建:<br>1.<strong>当采样周期 $T = 1/2w_{0}$</strong><br>2.<strong>重建函数采用sinc滤波器(sincFilter)</strong></p><p><img src="35.jpg" alt="35.jpg"></p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>采样在图形学中面临的挑战:</p><ol><li>图形学中信号往往是非频带受限的</li><li>sinc滤波器是一种理想的滤波器,但是由于其昂贵耗时的操作,在实时渲染中往往无法使用</li></ol><p>图片走样(Aliasing artifacts) = 不完美的采样+不完美的重建</p><p>那么我们该如何做,才能减少图片走样现象呢?首先需要认识到一个现实,无论我们怎么做,走样现象都会存在,或多或少的问题,因为采样意味着失真,任何采样都无法捕获高频信号的所有细节.<br>但是我们仍然可以尽力匹配采样频率和重建函数,逼近模拟原始信号.</p><h3 id="超采样-superSampling"><a href="#超采样-superSampling" class="headerlink" title="超采样(superSampling)"></a>超采样(superSampling)</h3><p>之前对每个像素点只采样一次:</p><p><img src="26.jpg" alt="26.jpg"></p><p>现在我们提高采样频率,假设每个像素做四次采样</p><p><img src="37.jpg" alt="37.jpg"></p><p>接下来我们需要将超采样转换为最终的采样(匹配屏幕空间像素),用于重建:</p><p><img src="38.jpg" alt="38.jpg"></p><h2 id="实现coverage函数"><a href="#实现coverage函数" class="headerlink" title="实现coverage函数"></a>实现coverage函数</h2><h3 id="如何判断一个点是否在三角形内部"><a href="#如何判断一个点是否在三角形内部" class="headerlink" title="如何判断一个点是否在三角形内部?"></a>如何判断一个点是否在三角形内部?</h3><p>通过向量叉乘可以轻易计算一个点是否在三角形内,分别对每条边组成的向量和顶点与当前采样点构成的向量叉乘,如果结果一致(都为正 或 都为负),则采样点在三角形内部.</p><p><img src="39.jpg" alt="39.png"></p><h3 id="三角形包围盒"><a href="#三角形包围盒" class="headerlink" title="三角形包围盒"></a>三角形包围盒</h3><p>显然对屏幕空间的每一个像素做三角形inSide判断是非常耗时低效的,因此我们可以先计算三角形包围盒,包围盒外部的像素肯定在三角形外,仅需要对三角形内部的像素做循环判断即可.</p><p>当然对于某些极端情况采用三角形包围盒遍历像素仍然很低效:</p><p><img src="40.jpg" alt="40.jpg"></p><p>针对这种极端情况,我们可以把屏幕空间划分为不同的区块:</p><ol><li>首先判断大的区块是否和三角形相交,如果未相交,则区块包含的所有像素均可以排除.</li><li>如果区块完整的在三角形内部,则其内部的所有像素均在三角形内.</li><li>此外,再遍历区块所包含的像素,分别与三角形求交.</li></ol><p><img src="41.png" alt="41.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphic01-线性代数</title>
      <link href="/2023/01/23/Computer%20Graphic01-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/01/23/Computer%20Graphic01-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Graphic01-线性代数"><a href="#Computer-Graphic01-线性代数" class="headerlink" title="Computer Graphic01-线性代数"></a>Computer Graphic01-线性代数</h1><p>线性代数是关于向量空间以及它们之线性变换的学科</p><h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><h3 id="向量是什么"><a href="#向量是什么" class="headerlink" title="向量是什么"></a>向量是什么</h3><p>直觉上来说向量其实就是一个小箭头</p><p><img src="01.png" alt="arrow"><br>在计算机图形学中，需要处理多种类型数据，这些数据可能看起来不像一个小箭头，比如多项式，图像，辐射亮度(radiance)等，但它们的行为表现却是和向量一致的，所以这个小箭头仍然是一个有用的思维模式。</p><h3 id="向量如何表示"><a href="#向量如何表示" class="headerlink" title="向量如何表示"></a>向量如何表示</h3><h4 id="极坐标系"><a href="#极坐标系" class="headerlink" title="极坐标系"></a>极坐标系</h4><p>一个向量需要编码哪些信息可以定义它的唯一性？</p><p>从根本上说向量就是方向和大小：<br><img src="02.png" alt="arrow"></p><p>例如二维空间的一个向量可以用长度和相对于某个固定方向的角度来表达，实际上就是极坐标系。</p><h4 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h4><p>笛卡尔坐标系由法国数学家笛卡尔发明，在笛卡尔坐标系下通过测量向量在其每个轴的分量来表示：</p><p><img src="03.png" alt="arrow"></p><h3 id="向量基本操作"><a href="#向量基本操作" class="headerlink" title="向量基本操作"></a>向量基本操作</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>可以对向量首尾相连实现两个向量相加：<br><img src="04.png" alt="arrow"><br>向量加法满足交换律，也就是谁在前谁在后无关紧要结果都一样</p><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>通常可以将任意向量$\vec{u}$乘以一个数字或“标量”$a$来得到一个新的向量$a\vec{u}$<br><img src="05.png" alt="arrow"><br>乘法的行为正如我们期望的，在几何意义上是基于缩放“小箭头”的行为。向量缩放满足结合律：</p><p>$a(b\vec{u}) = (ab)\vec{u}$</p><h4 id="加法和缩放结合"><a href="#加法和缩放结合" class="headerlink" title="加法和缩放结合"></a>加法和缩放结合</h4><p>先对两个向量相加后缩放与先分别对两个向量缩放后相加结果是相同的<br><img src="06.png" alt="arrow"></p><p>$a(\vec{u} + \vec{v}) = a\vec{u} + a\vec{v}$</p><h3 id="向量空间正式定义"><a href="#向量空间正式定义" class="headerlink" title="向量空间正式定义"></a>向量空间正式定义</h3><ul><li>$\vec{u} + \vec{v} = \vec{v} + \vec{u}$</li><li>$\vec{u} + \vec{v} + \vec{w} = \vec{u} + (\vec{v} + \vec{w})$</li><li>存在一个零向量$\vec{0}$使得$\vec{v} + (-\vec{v}) = \vec{0}$</li><li>对于任意向量$\vec{v}$,必然存在一个向量$-\vec{v}$使得$\vec{v} + (-\vec{v}) = \vec{0}$</li><li>$1\vec{v} = \vec{v}$</li><li>$a(b\vec{v}) = (ab)\vec{v}$</li><li>$a(\vec{u} + \vec{v}) = a\vec{u} + a\vec{v}$</li><li>$(a+b)\vec{v} = a\vec{v} + b\vec{v}$</li></ul><p><strong>这些规则都不是凭空捏造的，每一条背后都有相应的几何意义，尝试通过几何意义去理解这些规则！</strong></p><p><strong>任何满足这些性质的对象集合都是一个向量空间(即使它们看起来不像小箭头!)</strong></p><h3 id="欧几里得向量空间"><a href="#欧几里得向量空间" class="headerlink" title="欧几里得向量空间"></a>欧几里得向量空间</h3><p>通常用$\mathbb{R}^n$来表示欧几里得n维向量空间，意思是包含n个实数<br><img src="07.png" alt="arrow"></p><h3 id="函数也是向量"><a href="#函数也是向量" class="headerlink" title="函数也是向量"></a>函数也是向量</h3><p>在计算机图形学中向量空间的另一个非常重要的例子是函数空间</p><p>为什么?因为我们在图形学中使用的很多对象都是函数(图像，光源的辐射亮度，表面，模态振动，…)<br><img src="08.png" alt="arrow"><br>以上所有这些同样都是向量，满足小箭头所有性质对这些向量同样也适用</p><h4 id="函数求和"><a href="#函数求和" class="headerlink" title="函数求和"></a>函数求和</h4><p>假设有两个函数$f(x)，g(x)$，在值域内的每个点这些函数都会返回一个实数，实数集是向量空间，因此可以通过实数相加来定义函数的相加，将函数在每个点的返回结果理解为向量的每个分量。<br><img src="09.png" alt="arrow"></p><h4 id="函数缩放"><a href="#函数缩放" class="headerlink" title="函数缩放"></a>函数缩放</h4><p>再次利用事实：实数集属于向量空间，因此可以将函数转换到向量空间<br><img src="10.png" alt="arrow"></p><h3 id="直角坐标系下的向量"><a href="#直角坐标系下的向量" class="headerlink" title="直角坐标系下的向量"></a>直角坐标系下的向量</h3><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p>分别对向量的各个分量相加即可<br><img src="11.png" alt="arrow"></p><h4 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h4><p>分别对向量的各分量乘以缩放系数<br><img src="12.png" alt="arrow"></p><h4 id="计算中点"><a href="#计算中点" class="headerlink" title="计算中点"></a>计算中点</h4><p>把向量运算结合起来，就可以构建计算机图形学所需的各种运算，比如说计算中点，<br>只需要将两点相加然后除以2即可，本质是两个向量组成的平行四边形对角线的一半<br><img src="13.png" alt="arrow"></p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>对于一个给定的向量v，我们通过给它赋予一个数字$|v|$，该数字表示了向量有多“大”。</p><p>同样向量的范数可以很自然的扩展到函数和图像.<br><img src="14.png" alt="arrow"></p><h4 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h4><p>范数是用于计算向量大小或长度的函数，以向量作为参数，返回一个标量，并且对于所有向量$\vec{u}, \vec{v}$和所有标量$a$都满足以下性质:</p><ul><li>非负性：$|\vec{v}| &gt;= 0$</li><li>齐次性：$|a\vec{v}| = a|\vec{v}|$</li><li>三角不等式： $|\vec{u}| + |\vec{v}| &gt;= |\vec{u} + \vec{v}|$</li></ul><h4 id="直角坐标系下的向量范数"><a href="#直角坐标系下的向量范数" class="headerlink" title="直角坐标系下的向量范数"></a>直角坐标系下的向量范数</h4><p>标准范数就是所谓的n维向量的欧几里德范数：<br>$\vec{u} = |(u_1,…,u_n)| := \sum\limits_{i=1}^n{u_i^2}$</p><h4 id="函数的范数"><a href="#函数的范数" class="headerlink" title="函数的范数"></a>函数的范数</h4><p>和之前的向量范数相比比较陌生的概念，但基本的直觉是一样的:所谓的$L_2$范数测量了一个函数的大小.</p><p>考虑单位区间[0,1]上的实数函数并且其平方是可积分的，则L2范数定义为：</p><p>$||f|| := \sqrt{\int_{0}^{1}f(x)^2dx}$</p><p>其实和欧几里得范数区别不大：只是在这里采用积分替换了求和而已<br><img src="15.png" alt="arrow"></p><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>inner product有时候也叫做scalar product或者dot product，用符号$&lt;\vec{u},\vec{v}&gt;$表示，或者用$\vec{u}.\vec{v}$表示也行</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>除了大小，向量还有方向，就像范数测量长度一样，点积测量两个向量方向的一致性<br><img src="16.png" alt="arrow"></p><p>向量点积满足交换律，因为点积本质上表达是两个向量方向的相似性，因此谁前谁后无关紧要.</p><p>$&lt;\vec{u},\vec{v}&gt; = &lt;\vec{v},\vec{u}&gt;$</p><h4 id="点积意义-投影和缩放"><a href="#点积意义-投影和缩放" class="headerlink" title="点积意义-投影和缩放"></a>点积意义-投影和缩放</h4><p>对于单位向量$|\vec{u}| = |\vec{v}| = 1$，点积可以表示为一个向量在另一个向量方向上的垂直投影:<br><img src="17.png" alt="arrow"></p><p>如果对任意一个向量执行缩放操作，则点积也会按照相同的系数缩放：<br><img src="18.png" alt="arrow"></p><h4 id="正式定义-1"><a href="#正式定义-1" class="headerlink" title="正式定义"></a>正式定义</h4><p>点积以任意两个向量$\vec{u},\vec{v}$作为输入参数，返回一个标量$&lt;\vec{u},\vec{v}&gt;$，满足以下性质：</p><ul><li>$&lt;\vec{u},\vec{v}&gt; = &lt;\vec{v},\vec{u}&gt;$</li><li>$&lt;\vec{u},\vec{u}&gt;$ &gt;= 0</li><li>$&lt;\vec{u},\vec{u}&gt;$ = 0 则 $\vec{u} = \vec{0}$</li><li>$&lt;\ a\vec{u},\vec{v}&gt; = a&lt;\vec{u},\vec{v}&gt;$</li><li>$&lt;\vec{u} + \vec{v},\vec{w}&gt;$ = $&lt;\vec{u},\vec{w}&gt;$ + $&lt;\vec{v},\vec{w}&gt;$</li></ul><h4 id="笛卡尔坐标系下的点积"><a href="#笛卡尔坐标系下的点积" class="headerlink" title="笛卡尔坐标系下的点积"></a>笛卡尔坐标系下的点积</h4><p>标准点积就是所谓的欧几里得点积，它作用于一对n维向量:</p><p>$&lt;\vec{u},\vec{v}&gt; = &lt;(u_1,…,u_n),(v_1,…,v_n)&gt; := \sum\limits_{i=1}^nu_iv_i$</p><p><img src="19.png" alt="arrow"></p><h4 id="函数的L2点积"><a href="#函数的L2点积" class="headerlink" title="函数的L2点积"></a>函数的L2点积</h4><p>就像函数有范数一样，我们也可以定义一个点积来衡量两个函数“方向的一致性”</p><p>例如对于在单位区间内的任意平方可积函数$f(x)和g(x)$,两个函数的点积公式如下：</p><p>$&lt;\ f,\ g&gt; := \int_{0}^{1}f(x)g(x)dx$</p><p>举例说明：</p><p>假设</p><p>$f(x) := x^2$<br>$g(x) := (1-x)^2$</p><p>那么：</p><p>$&lt;\ f,\ g&gt; = \int_{0}^{1}x^2(1-x)^2dx = … = 1/30$</p><p><img src="20.png" alt="arrow"></p><h4 id="图像和其他信号"><a href="#图像和其他信号" class="headerlink" title="图像和其他信号"></a>图像和其他信号</h4><p>有多种方式测量一个信号有“多大”(norm)或者两个信号是否“一致”(dot product)<br>具体如何选择要根据需求来看，比如说现在有两张图片，我们要找到哪张图片更有趣一些，按照正常逻辑左侧的小狗图片norm小，右侧的蓝天更亮些显然norm大，但是基于原始图片计算的norm对我们是没什么用的，在这里我们更想要的是哪张图片包含的细节更丰富，因此需要对图片的导数求范数(边缘检测):<br><img src="21.png" alt="arrow"></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="对图形学的意义"><a href="#对图形学的意义" class="headerlink" title="对图形学的意义"></a>对图形学的意义</h3><ul><li>对计算机来说线性方程组很容易求解</li><li>基础变换比如旋转、平移、缩放都可以通过线性变换来表达</li><li>所有的变换都可以在很短距离或很短时间内通过线性变换来近似表达，这种近似应用于很多领域：几何，动画，渲染，图像处理等</li></ul><h3 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h3><p>所谓线性变换就是经过变换后的几何体要满足以下两点性质：</p><ul><li>直线仍然保持直线</li><li>原点保持不变</li></ul><p><img src="22.png" alt="arrow"></p><h3 id="代数定义"><a href="#代数定义" class="headerlink" title="代数定义"></a>代数定义</h3><p>线性变换$f$以及对于任意向量$\vec{u}和\vec{v}$以及标量$a$需要满足：</p><ul><li>$f(\vec{u} + \vec{v}) = f(\vec{u}) + f(\vec{v})$</li><li>$f(a\vec{u}) = af(\vec{u})$</li></ul><p>换句话说无论先对两个向量相加应用线性变换还是先分别应用线性变换然后相加结果都是一样的<br><img src="23.png" alt="arrow"></p><h3 id="坐标下的线性变换表达"><a href="#坐标下的线性变换表达" class="headerlink" title="坐标下的线性变换表达"></a>坐标下的线性变换表达</h3><p>对于任何$\mathbb{R}^m$和$\mathbb{R}^n$之间的线性变换，我们可以给出显式定义：</p><p>$f(u_1,…,u_m) = \sum\limits_{i = 1}^mu_i\vec{a_i}$</p><p><img src="24.png" alt="arrow"></p><h3 id="线性变换vs仿射变换"><a href="#线性变换vs仿射变换" class="headerlink" title="线性变换vs仿射变换"></a>线性变换vs仿射变换</h3><p>思考以下变换是否是线性变换？</p><p><img src="25.png" alt="arrow"></p><p>看起来貌似是线性变换，但是它违反了线性变换的两条基本原则：</p><ol><li>$f(0) != 0$(违反了原点保持不变性)</li><li>$f(x_1 + x_2 ) = a(x_1 + x_2) + b = ax_1 + ax_2 + b\\<br>f(x_1) + f(x_2) = (ax_1 + b) + (bx_2 + b) = ax_1 + ax_2 + 2b$</li></ol><p>实际上这种变换叫做仿射变换($Affine\  Function$)</p><h3 id="张成的空间-Span"><a href="#张成的空间-Span" class="headerlink" title="张成的空间(Span)"></a>张成的空间(Span)</h3><p>对于给定向量$\vec{u}和\vec{v}$和任意标量$a和b$，张成的空间就是可以由这两个向量的线性组合可以表示的所有向量的集合体：</p><p>$a\vec{u} + b\vec{v}$</p><p>更泛化的表示：</p><p>$span(\vec{u_1},…\vec{u_k}) = \{ \vec{x} \in V | \vec{x} = \sum\limits_{i=1}^ka_i\vec{u_i}, a_1,…,a_k \in \mathbb{R}\}$</p><h3 id="张成空间和线性变换"><a href="#张成空间和线性变换" class="headerlink" title="张成空间和线性变换"></a>张成空间和线性变换</h3><p><strong>任何线性变换的图像就是某些向量集合张成的空间</strong></p><h3 id="基-Basis"><a href="#基-Basis" class="headerlink" title="基(Basis)"></a>基(Basis)</h3><p>张成空间和基是紧密联系在一起的</p><p>特别地，如果我们有n个向量$\vec{e_1},…\vec{e_n}$满足：</p><p>$span(\vec{e_1},…\vec{e_n}) = \mathbb{R}^n$</p><p>那么我们可以说这些向量是$\mathbb{R}^n$的基</p><h3 id="正交基-Orthonormal-Basis"><a href="#正交基-Orthonormal-Basis" class="headerlink" title="正交基(Orthonormal Basis)"></a>正交基(Orthonormal Basis)</h3><p>大多数情况下，有(i)单位长度和(ii)相互垂直的基向量是很方便的.这些基叫做正交基</p><p>换句话说如果$\vec{e_1},…\vec{e_n}$是正交基则必须满足：</p><p>$&lt;\vec{e_i},\vec{e_j}&gt; = \begin{cases} 1, i = j \\ 0, otherwise. \end{cases}$ </p><p>为什么要用正交基，有以下几个原因：</p><p><img src="26.png" alt="arrow"></p><ol><li>$u_1^2 + … + u_n^2$是有几何意义的，它代表了向量$\vec{u}$长度的平方</li><li>使操作方便</li></ol><p><strong>常见bug：将一个向量映射到一个非正交基的向量空间，然后用标准的范数和点积对其操作</strong></p><h3 id="格拉姆—施密特-Gram-Schmidt-正交化"><a href="#格拉姆—施密特-Gram-Schmidt-正交化" class="headerlink" title="格拉姆—施密特(Gram-Schmidt)正交化"></a>格拉姆—施密特(Gram-Schmidt)正交化</h3><p>如果基向量不是正交基，我们如何将其转换为正交基呢？可以通过格拉姆—施密特(Gram-Schmidt)正交化方法：</p><p>假设有两个非正交的基向量$\vec{u_1}和\vec{u_2}$</p><ul><li>首先对任意一个向量比如说$\vec{u_1}做归一化,也就是向量除以自身的长度得到\vec{e_1}$</li><li>然后用另外一个向量$\vec{u_2}$减去$\vec{u_2}在\vec{e_1}$上的投影向量得到与$\vec{e_1}$垂直的向量$\hat{u_2}$</li><li>对向量$\hat{u_2}$做归一化操作得到$\vec{e_2}$</li><li>如果有$n$个基向量，重复以上步骤</li></ul><p><img src="27.png" alt="arrow"></p><p><strong>注：对于很大的数组成的向量或者接近平行的向量，该方法可能不是最好的</strong></p><h3 id="傅里叶变换-Fourier-Transform"><a href="#傅里叶变换-Fourier-Transform" class="headerlink" title="傅里叶变换(Fourier Transform)"></a>傅里叶变换(Fourier Transform)</h3><p>对于$\mathbb{R}^n$空间的基我们已经很熟悉了，但是对于更泛化意义上的向量比如说：函数，信号，音频等，这些向量空间是否存在正交基呢？函数的范数前文已经讲过了，所以对函数归一化其实不是问题，但是两个函数彼此正交意味着什么？</p><p>这些正是傅里叶变换的背后思想</p><p>考虑周期函数($2\pi$)，函数图像如下:</p><p><img src="28.png" alt="arrow"></p><p>可以将该函数表示为一系列基础“基函数”的线性组合：$\cos(nx),\sin(nx),m,n \in \mathbb{N}$</p><p>基于此我们很自然的想到可以将一个原始信号分界为一系列不同频率的基础信号：</p><p><img src="29.png" alt="arrow"></p><p><strong>本质上傅里叶变换就是从一个基到另一个基的线性映射</strong></p><h3 id="信号的频率分解"><a href="#信号的频率分解" class="headerlink" title="信号的频率分解"></a>信号的频率分解</h3><p>更一般地说，这种将信号投射到不同“频率”的过程被称为傅里叶分解.被广泛应用于各种信号处理例如图像处理，渲染，集合，物理模拟等等</p><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><p>线性方程组就像它名字所暗示的:一堆方程，左边是线性函数，右边是常数，例如：</p><p>$x + 2y = 3$</p><p>$4x + 5y = 6$</p><p>$xy$未知数被称为自由度($DOFs$)，方程被称为约束条件，解线性方程组的过程实际上就是求解同时满足约束条件的自由度.</p><h3 id="线性方程组可视化"><a href="#线性方程组可视化" class="headerlink" title="线性方程组可视化"></a>线性方程组可视化</h3><p>当然，线性系统可以用来表示许多不同的实际任务(模拟、处理等),但是对于任意线性系统，都有一些很好的思维模型进行可视化，帮助我们理解：</p><p><img src="30.png" alt="arrow"></p><h3 id="解的存在性，唯一性"><a href="#解的存在性，唯一性" class="headerlink" title="解的存在性，唯一性"></a>解的存在性，唯一性</h3><p>当然，不是所有的线性系统都存在解!即使存在解也不一定唯一.</p><p><img src="31.png" alt="arrow"></p><h2 id="矩阵和线性变换"><a href="#矩阵和线性变换" class="headerlink" title="矩阵和线性变换"></a>矩阵和线性变换</h2><p>如何将线性变换通过矩阵的形式来表达.假设有一个线性变换：</p><p><img src="32.png" alt="arrow"><br>$f(\vec{u}) = u_1\vec{a}_1 + u_2\vec{a}_2$</p><p>首先先从几何视角理解该线变换：<br>平面上有一个向量，其坐标为$u_1和u_2$,先沿着$\vec{a}_1$方向行走$u_1$距离，然后沿着$\vec{a}_2$方向行走$u_2$距离，我们想做的是定义一个矩阵，如果将该矩阵乘以由$u_1和u_2$定义的向量，则可以完成这样的几何操作。</p><p>回忆下矩阵向量乘法，考虑矩阵向量乘法的最简单方法就是矩阵有一组列当我用一个矩阵乘以一个向量时，用所乘的向量的各个分量取这些列的线性组合，从这个角度来看，每一个”$\vec{a}$”向量最终成为了矩阵的一个列：</p><p><img src="33.png" alt="arrow"></p><p>现在矩阵向量乘法就可以推导出原始的线性变换了：</p><p><img src="34.png" alt="arrow"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（七）：阴影</title>
      <link href="/2022/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%98%B4%E5%BD%B1/"/>
      <url>/2022/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%98%B4%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（七）：阴影"><a href="#计算机图形学（七）：阴影" class="headerlink" title="计算机图形学（七）：阴影"></a>计算机图形学（七）：阴影</h1><blockquote><p>All the variety, all the charm, all the beauty of life is made up of light and shadow      - Tolstoy</p></blockquote><p>阴影对于表达场景真实感极其重要，因为它能够提供物体在空间中的相对位置关系，使物体看起来不是<strong>漂浮</strong>在空中的。本章将重点介绍计算阴影理论以及在光栅化中实时阴影算法。</p><p><img src="1.png" alt="shadows"></p><blockquote><p>《古墓丽影-暗影》 2018</p></blockquote><p>之前介绍$blinn-Phong\;Model$光照模型是<strong>局部的</strong>，仅考虑光线 着色点 视线三个因素，不考虑其它物体对于当前着色点的影响，例如遮蔽，阴影等，而现实情况是，光照是及其复杂的，需要考虑周围物体对着色点的影响（间接光照），而在传统的局部着色（直接光照）中很难实现准确的表达，往往需要通过其它技术近似的模拟，今天介绍的$shadow\;Mapping$就是其中之一。一种在光栅化成像中实现阴影的技术。</p><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="$Shadow\;Mapping$"></a>$Shadow\;Mapping$</h2><p>它是一种图像空间（$Image-Space$）算法。核心思想就是：<strong>那么一个着色点既可以被摄像机看到也可以被光源看到，那么该点不在阴影里。如果一个着色点在阴影里，那么摄像机可以看到，光源是看不到的。</strong></p><p>传统的$Shadow\;Mapping$只能处理点光源，这样的阴影都有明显的边界和锯齿，一个着色点要么在阴影里，要么不在，缺少了中间柔和的过渡。这种阴影我们称之为<strong>硬阴影</strong>。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>回顾$zBuffer$算法，$zBuffer$实际上是一张二维纹理贴图，每一个纹素记录了距离相机最近的片元深度：</p><p><img src="2.png" alt="shadows"></p><ul><li>step1：那么自然的，我们可以先将摄像机移动到光源位置和方向，<strong>看向</strong>场景，渲染一张深度图，这张深度图就代表了哪些着色点可以被光源<strong>照亮</strong>，大于这个深度的片元都是在阴影中的，这个阶段需要做两件事情，1：渲染深度图（$Shadow\;Mapping$），2：记录相机变换到光源位置的变换矩阵$M$：</li></ul><p><img src="3.png" alt="shadows"></p><blockquote><p>光照方向深度图</p></blockquote><ul><li><p>step2：将相机摆放到正常的观测方向和位置，对片元进行着色时，考虑每个片元是否有光照，方式是：用步骤1中存储的矩阵$M$将当前着色点变换到光照空间，拿到在光照空间中当前着色点$p$的深度，然后采样$Shadow\;Mapping$中对应的当前点的最小深度，对比两者，如果着色点$p$的深度大于纹理采样得到的深度，则认为当前片元被遮挡，需要在光照计算中加入shadow因子。</p></li><li><p>step3：通过以上两个步骤可以看出，一个pass无法完成$shadow\;Map$的阴影渲染，需要两个pass，第一个pass负责渲染深度图（不渲染到屏幕，渲染到一张纹理中），第二个pass对场景正常渲染，整体过程如下图所示：</p></li></ul><p><img src="4.png" alt="shadows"></p><h2 id="Shadow-Mapping-存在的问题"><a href="#Shadow-Mapping-存在的问题" class="headerlink" title="$Shadow\;Mapping$存在的问题"></a>$Shadow\;Mapping$存在的问题</h2><p>阴影贴图的一个劣势是生成阴影的质量严重依赖于阴影贴图的分辨率和$zBuffer$的浮点数精度，由于阴影图是在比较深度时进行采样的，因此算法容易出现混叠问题。一个常见的现象就是自遮挡（$surface\;acne\;or\;shadow\;acne$）：</p><p><img src="5.png" alt="shadows"></p><p>造成这种奇怪现象的原因有两个。第一：受限于处理器浮点数精度。第二：阴影图受限于它的分辨率，阴影图中一个纹素可能会覆盖离光源位置较远的多个片元。如下图很清晰的解释了分辨率造成$shadow\;acne$问题的原因：</p><p><img src="6.jpg" alt="shadows"></p><p>上图中每个黄色的倾斜面板代表深度图中的单个纹素，几个片段对相同的深度样本进行了采样。正常情况下这是没问题的，但当光源以某个角度朝向平面时，问题就开始出现了，因为这个时候，我们生成的深度图也是从同样的倾斜角度渲染的。进行深度比较时，一些片元将得到相同倾斜深度纹理像素，这样就造成了一部分片元深度高于当前纹素值（倾斜的黄色面包那），一些低于当前纹素值。形成了条纹状类似于摩尔纹的现象。</p><p>明白了原理后，问题解决就变得简单了，可以引入一个常数偏移，一般称为$Shadow\;bias$,在进行深度比较时，从深度图采样得到的数值中加上这样一个偏移量，这样就可以避免倾斜面板（单个纹素）与共享同一纹素深度的几个片元形成区域的相交：</p><p><img src="7.jpg" alt="shadows"></p><p>同样我们也可以发现，当光线与平面夹角越小，这种走样现象表现的越明显，<strong>因为夹角越小，同一纹素覆盖的像素范围更大</strong>。因此常数的$Shadow\;bias$是不可靠的，因为需要额外弥补的偏移量并不是一个常数，而是与光线入射角度相关的。更加通用的做法是，求着色点法线和和光线的点积，实现动态bias：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);</span><br></pre></td></tr></table></figure><p>但是引入$Shadow\;bias$会带来另外一个问题，当我们应用一个bias偏移到物体的实际深度后，如果偏差很大，则会看到阴影与实际物体位置偏差比较大：</p><p><img src="8.jpg" alt="shadows"></p><p>这种现象俗称$Peter\;panning$:</p><p><img src="9.jpeg" alt="shadows"></p><p>解决这个问题很简单，只需要在渲染阴影图时开启正面剔除即可，以OpenGL为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">RenderSceneToDepthMap();</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><h2 id="硬阴影-vs-软阴影"><a href="#硬阴影-vs-软阴影" class="headerlink" title="硬阴影 vs 软阴影"></a>硬阴影 vs 软阴影</h2><p><img src="10.jpg" alt="shadows"><img src="11.jpg" alt="shadows"></p><p>明显可以看出软阴影没有明显的阴影边界，过渡自然，更符合自然中观察到的实际情况。而基于之前介绍的一系列方法是无法实现右侧图所示的软阴影的。</p><p>因为日常中我们所见到的绝大多数都是面光源，生成的阴影包含了两部分:$Umbra和Penumbra$，软阴影其实就是在本影（$Umbra$）和没有阴影之间的区域有一个半影（$Umbra和Penumbra$）,产生了柔和过渡的效果：</p><p><img src="12.jpg" alt="shadows"></p><p>为了实现软阴影，我们将介绍接下来的概念:$PCF$。</p><h2 id="PCF"><a href="#PCF" class="headerlink" title="$PCF$"></a>$PCF$</h2><p>前边一系列的操作都是为了解决$Shadow\;Mapping$自遮挡的问题，但是边缘锯齿的问题仍然没有解决，本质上是因为深度图具有固定的分辨率，所以同一纹素通常会覆盖多个片元，多个片元从深度图中会提取到相同的深度值，得到相同的阴影判定，从而产生锯齿状的边缘。为了产生柔和的过渡边缘其中一个比较简单的实现就是$PCF$，全称$Percentage-closer\;filtering$.<br>$PCF$最初并不是用于实现软阴影的，而是为了使阴影边缘的抗锯齿。随后基于$PCF$的$PCSS$才是用于软阴影的。</p><p>思路很简单：原本我们在比较深度时，是基于当前着色点的深度和阴影图中采样得到的深度进行一次比对，$PCF$的做法是，基于当前着色点的深度，对阴影图进行多次采样。每次采样后比对得出一个shadow因子，然后对多个shadow因子加权平均。有点类似于纹理贴图中抗锯齿的做法。<strong>本质上计算的是这个着色点与本影的接近程度（柔和过渡）。</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5x5 PCF</span></span><br><span class="line"><span class="type">ivec2</span> ts = <span class="built_in">textureSize</span>(depthSampler, <span class="number">0</span>);</span><br><span class="line"><span class="type">vec2</span> texelSize = <span class="type">vec2</span>(<span class="number">1</span> / ts.x, <span class="number">1</span> / ts.y);</span><br><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-2</span>; x &lt;= <span class="number">2</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-2</span>; y &lt;= <span class="number">2</span>; ++y) &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(depthSampler, projCoords.xy + <span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">        shadow += currentDepth - bias  &gt; pcfDepth? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure><h2 id="shadowMap部分实现代码"><a href="#shadowMap部分实现代码" class="headerlink" title="shadowMap部分实现代码"></a>shadowMap部分实现代码</h2><p>实现了$Shadow\;bias和PCF$的$Shadow\;Map$ fragmentShader代码：</p><p>fragmentShader<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> depthSampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> randomColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightDir;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> lightSpacePosition;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> v_normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> model_Pos;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> shadowCalc(<span class="type">vec4</span> lightSpacePosition) &#123;</span><br><span class="line">    <span class="type">vec3</span> projCoords = lightSpacePosition.xyz / lightSpacePosition.w;</span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">//shadow bias</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(<span class="built_in">normalize</span>(v_normal), lightDir)), <span class="number">0.005</span>);</span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="type">ivec2</span> ts = <span class="built_in">textureSize</span>(depthSampler, <span class="number">0</span>);</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="type">vec2</span>(<span class="number">1</span> / ts.x, <span class="number">1</span> / ts.y);</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//PCF</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-2</span>; x &lt;= <span class="number">2</span>; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-2</span>; y &lt;= <span class="number">2</span>; ++y) &#123;</span><br><span class="line">            <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(depthSampler, projCoords.xy + <span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">            shadow += currentDepth - bias  &gt; pcfDepth? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shadow /= <span class="number">25.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">float</span> shadow = shadowCalc(lightSpacePosition);</span><br><span class="line">    shadow = <span class="built_in">min</span>(shadow, <span class="number">0.5</span>);</span><br><span class="line">    outColor = <span class="type">vec4</span>(randomColor * (<span class="number">1.0</span> - shadow), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=12&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=4&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES202 -高质量实时渲染</a></p><p><a href>Real-Time Rendering</a></p><p><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">learningOpenGL</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（六）：反射方程与渲染方程</title>
      <link href="/2022/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"/>
      <url>/2022/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（六）：反射方程与渲染方程"><a href="#计算机图形学（六）：反射方程与渲染方程" class="headerlink" title="计算机图形学（六）：反射方程与渲染方程"></a>计算机图形学（六）：反射方程与渲染方程</h1><h2 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数($BRDF$)"></a>双向反射分布函数($BRDF$)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>$BRDF$全称$Bidirectional\;Reflectance\;Distribution\;Function$。$BRDF$是描述了物体表面对能量反射分布特性的函数。假设物体表面单位面积$dA$接收到来自$W_i$方向光线的能量，用$E$来表示，这些能量$E$到达物体表面后，会向各个不同的方向反射（每个方向反射的能量不同），$BRDF$函数就是描述这束能量向特定方向$W_r$的反射占比。</p><p><img src="1.jpg" alt="BRDF"></p><ul><li>Differential irradiance incoming：$dE(w_i) = L(w_i)\cos\theta_i{d}w_i$</li><li>Differential intensity exiting: $dL_r(w_r)$ </li></ul><h3 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h3><p>单位面积$dA$从单位立体角$w_i$接收到的$irradiance$，会被如何反射到各个不同的方向上去。更通俗点来说就是BRDF描述的是单位面积接收单位立体角$w_i$的能量的反射分布（比例）。反射比例依赖于出射方向（$w_r$）。$BRDF$描述了光与物体表面是如何相互作用的。即物体的材质属性由$BRDF$定义。</p><p><img src="2.png" alt="BRDF"></p><p>$f_r(w_i -&gt; w_r) = \dfrac{dL_r(w_r)}{dE_i(w_i)} = \dfrac{dl_r(w_r)}{L_i(w_i)\cos\theta_i{d}w_i}$</p><h2 id="反射方程（-The-Reflection-Equation-）"><a href="#反射方程（-The-Reflection-Equation-）" class="headerlink" title="反射方程（$The\;Reflection\;Equation$）"></a>反射方程（$The\;Reflection\;Equation$）</h2><p>$BRDF$告诉了我们特定入射方向光线对特定出射方向的能量反射比例。而当观察物体表面的某一点时，该点反射的能量汇聚了各个方向的入射光线。对于每一条光线，都可以通过$BRDF$计算出其特定出射角度的反射比例。因此某一点特定出射方向的反射能量等于该点各个入射方向$BRDF$的半球积分。这就是反射方程。</p><p><img src="3.png" alt="BRDF"></p><p>$L_r(p, w_r) = \int_{H^2}f_r(p, w_i -&gt; w_r)L_i(p, w_i)\cos\theta_i{d}w_i$</p><h3 id="递归性"><a href="#递归性" class="headerlink" title="递归性"></a>递归性</h3><p>假设观察某一着色点，需要考虑到达该着色点的各个光线，这些光线有些是直接来自于光照的，有些是来自于其他物体的反射。也就是说着色点接收来自各个方向的光线经过$BRDF$计算求和形成$Radiance$，而出射的$Radiance$又可以照亮其它物体，成为照亮其它某个着色点各个不同入射方向$Radiance$的某一部分。这样就形成了递归。</p><p><img src="4.jpg" alt="BRDF"></p><h2 id="渲染方程（The-Rendering-Equation）"><a href="#渲染方程（The-Rendering-Equation）" class="headerlink" title="渲染方程（The Rendering Equation）"></a>渲染方程（The Rendering Equation）</h2><p>反射方程告诉了某一点特定出射方向的反射能量等于该点各个入射方向$BRDF$的半球积分。但是反射方程没有考虑物体自身的发光情况。而物体的自发光也是需要参与到计算中的，完善反射方程，加上自发光项就得到了渲染方程：</p><p>渲染方程 = 自发光项 + 反射方程</p><p>$L_o(p, w_o) = L_e(p, w_o) + \int_{H^2}L_i(p, w_i)f_r(p, w_i -&gt; w_o)(\hat{n}\cdot{w_i})dw_i$</p><h3 id="抽象渲染方程"><a href="#抽象渲染方程" class="headerlink" title="抽象渲染方程"></a>抽象渲染方程</h3><p>$L_o(p, w_o) = L_e(p, w_o) + \int_{H^2}L_i(p, w_i)f_r(p, w_i -&gt; w_o)(\hat{n}\cdot{w_i})dw_i$</p><p>-&gt;</p><p>$L(u) = e(u) + \int{L(v)}K(u,v)dv$</p><p>-&gt; </p><p>将积分省略，抽象为算子的形式($K$)</p><p>$L = E + KL$</p><p>-&gt;</p><p>$IL-KL = E$</p><p>$(I-K)L = E$</p><p>$L = (I-K)^{-1}E$</p><p>$L = (I +K+K^2+K^3+…)E$</p><p>$L = E + KE + K^2E + K^3E+…$</p><p><img src="6.jpg" alt="BRDF"></p><p>通过将方程用K算符简化，我们将渲染方程拆解成了自发光项，直接光照，间接光照。所有这些因子共同构成了全局光照。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（五）：纹理应用-下</title>
      <link href="/2022/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8B/"/>
      <url>/2022/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（五）：纹理应用-下"><a href="#计算机图形学（五）：纹理应用-下" class="headerlink" title="计算机图形学（五）：纹理应用-下"></a>计算机图形学（五）：纹理应用-下</h1><p>上一章介绍了凹凸贴图,凹凸贴图可以提升粗糙mesh细节表现,凹凸贴图其实没有改变表面的几何结构,仅仅是通过法线的扰动影响了着色而已,因此产生的问题就是,在特定角度观察或者观察物体边缘或阴影时,问题就暴露出来了,这是因为没有考虑高程带来的视差和遮挡。因为mesh信息没有提供对应的深度变化，在$z-buffer$深度测试时，不会对被遮挡的顶点做深度测试，因此不会产生应有的自遮挡现象。</p><p><img src="1.jpg" alt="bummmap"></p><h2 id="视差贴图-（-Parallax-Mapping-）"><a href="#视差贴图-（-Parallax-Mapping-）" class="headerlink" title="视差贴图 （$Parallax\;Mapping$）"></a>视差贴图 （$Parallax\;Mapping$）</h2><p>视差贴图解决了凹凸贴图带来的问题(凹凸贴图没有考虑自遮挡问题)，如下图当我们从相机观察到$P$点时，由于高程的存在，我们应该看到的是$p_ideal$，但实际上在凹凸贴图用的是p点的着色信息，所以看起来不够真实：</p><p><img src="2.png" alt="bummmap"></p><p>2001年，$Kaneko$引入了视差贴图的概念，并对其进行了改进并由$Welsh$普及。 视差是指当观察者移动时，对象彼此相对移动。 随着观察者的移动，凹凸应该看起来有高度。 视差映射的关键思想是采用通过实时检查像素的高度来有根据地猜测应该在像素中看到什么（遮蔽现象）。</p><p>$Parallax\;Mapping$所需要的信息通常存储在一张高度图($heightfield\;Texture$)中。当观察物体表面某一着色点时，首先会根据纹理查询该点对应的高度值，然后基于这个高度值和观察角度计算出一个偏移量$offset$，这个偏移量实际上就是$p$点的偏移量，即我们实际上应该看到的像素点$p_{adj}$，而不是$p$点。如上右图所示，所做的事情就是：根据$p$点的高程，以及 $v$的方向，对$p$点偏移一段距离到达$p_{adj}$，以接近$p_{ideal}$</p><p>$p_{adj} = p + \dfrac{h*v_{tb}}{v_n}$</p><p>当高程变化平缓时，这个方法表现很好，但当高程在p点出变化剧烈或者$v$与表面法线的角度很大时，就有可能导致$p_{adj}与p_{ideal}$相差很远，如下图所示：</p><p><img src="3.png" alt="bummmap"></p><p>为了解决这个问题，$Welsh$对此进行了改进：为了防止$p$点偏移的过于厉害， $Welsh$将偏移量限制在$h$范围内，此方法对于这种局部高程变化剧烈的撞墙图表现的很好：</p><p><img src="4.png" alt="bummmap"></p><p>如下图所示，光线有时会被更高的其他点遮挡，但是上面并没有考虑这一点：</p><p>一种类似于$Ray\;Marching$的思想，从$p$点出发，向前检查有限数量的点，看这些点的高程是否与光线相交，如果相交，取交点最近的像素点，如$p_adj$，并用此处的光照去代替$p$点的光照信息。</p><p><img src="5.jpg" alt="bummmap"></p><h2 id="浮雕贴图（-Relief-Mapping-）"><a href="#浮雕贴图（-Relief-Mapping-）" class="headerlink" title="浮雕贴图（$Relief\;Mapping$）"></a>浮雕贴图（$Relief\;Mapping$）</h2><p>关于浮雕贴图，有人把它誉为凹凸贴图的极致，$Parallax\;Mapping$是针对$Normal\;Mapping$的改进，利用HeightMap进行了近似的TextureOffset，而$Relief\;Mapping$是精确的TextureOffset,所以表现上比较完美。</p><ul><li><p>法线贴图和浮雕贴图的对比，法线贴图没有子遮挡。<br><img src="6.jpg" alt="bummmap"></p></li><li><p>视差贴图和浮雕贴图的对比，浮雕贴可以实现更深的凹凸深度：<br><img src="7.png" alt="bummmap"></p></li><li><p>法线贴图，视差贴图 ，浮雕贴图三种效果对比：<br><img src="8.png" alt="bummmap"></p></li></ul><h2 id="改变表面结构"><a href="#改变表面结构" class="headerlink" title="改变表面结构"></a>改变表面结构</h2><p>之前介绍的凹凸贴图，视差贴图，浮雕贴图，都只是在计算光照时对法线进行了扰乱，并没有修改表面结构。此处介绍的位移贴图（$Displacement\;Mapping$）则实际修改了表面结构，主要依赖于渲染管线的曲面细分。根据贴图中对三角形进行曲面细分，生成足够多更小的三角形，并对每个三角形的顶点位置都进行位移，实际上得到了更为精细的几何体。这种方法类似于法线贴图，位移贴图的每一个纹素中存储了一个向量，这个向量代表了对应顶点的位移。注意，此处的纹素并不是与像素一一对应，而是与顶点一一对应，因此，纹理的纹素个数与网格的顶点个数是相等的。在$vertexShader$阶段，获取每个顶点对应的纹素中的位移向量，施加到局部坐标系下的顶点上，然后进行mvp即可。</p><h2 id="改变光源-Textured-Light"><a href="#改变光源-Textured-Light" class="headerlink" title="改变光源($Textured\;Light$)"></a>改变光源($Textured\;Light$)</h2><p>纹理还可以被用于增加光源的细节表现（图案等），允许改变复杂的光照分布。最简单的二维光源，类似投影仪的工作原理：把一张纹理放在聚光灯下，那么光照就带有各种图案：</p><p><img src="9.jpg" alt="bummmap"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/370927083">图形学基础 - 纹理 - 纹理映射盘点</a></p><p><a href>Real-Time Rendering</a></p><p><a href="https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8AReal-Time%20Rendering%203rd%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Content/BlogPost05/README.md">《Real-Time Rendering 3rd》 提炼总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（四）：纹理应用-上</title>
      <link href="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/"/>
      <url>/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（四）：纹理应用-上"><a href="#计算机图形学（四）：纹理应用-上" class="headerlink" title="计算机图形学（四）：纹理应用-上"></a>计算机图形学（四）：纹理应用-上</h1><p>在计算机图形学中，纹理贴图是使用图像、函数或其他数据源来改变物体表面外观的技术。例如，可以将一张砖墙贴图应用到一个多边形上，而不用对砖墙的几何形状进行精确建模。通过这种方式将图像和物体表面结合起来，可以在建模、存储空间和速度方面节省很多资源。当然纹理不仅仅用于改变物体表面漫反射颜色,<strong>纹理本质上是一个数据集</strong>,可以用来存储任何我们需要的数据,因此在各方面都得到了广泛的应用.本文将介绍MaterialMap、AlphaMap、BumpMap、NormalMap、ReliefMap、DisplacementMap、ParallaxMap、TexturedLight、ShadowMap、EnvironmentMap。<br>我们将以上纹理贴图的应用划分为6个大类：</p><ul><li>控制着色信息</li><li>控制片元透明度</li><li>改变顶点法线</li><li>改变表面结构</li><li>阴影贴图</li><li>环境贴图</li></ul><h2 id="控制着色信息"><a href="#控制着色信息" class="headerlink" title="控制着色信息"></a>控制着色信息</h2><p>根据$Blinn-phong\;Model$可知，物体表面着色信息有以下因子来控制：</p><p><img src="15.png" alt="blinn-phong"></p><p>$L = L_a+L_d+L_s = K_aI_a + K_d\dfrac{I}{r^2}max(0, \hat{n}\cdot\hat{l}) + K_s\dfrac{I}{r^2}max(0, \hat{n}\cdot\hat{h})^p$</p><div class="table-container"><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>$K_a$</td><td>物体表面环境光吸收率</td></tr><tr><td>$I_a$</td><td>环境光强度</td></tr><tr><td>$\dfrac{I}{r^2}$</td><td>到达物体表面的光线</td></tr><tr><td>$K_d$</td><td>漫反射系数</td></tr><tr><td>$\hat{n}$</td><td>着色点法线</td></tr><tr><td>$\hat{l}$</td><td>光线单位向量</td></tr><tr><td>$K_s$</td><td>高光系数</td></tr><tr><td>$p$</td><td>高光衰减因子</td></tr></tbody></table></div><p>可以看到有许多可以调节的参数来控制像素的着色表现。虽然可以赋予顶点更多的属性来改变这些参数，但是要做到亚三角形的细节程度，就需要使用各种纹理，<strong>对每个片元的着色参数进行调节</strong>，这些纹理映射方法统称为材质映射（$Material\;Map$）。</p><p>最简单的就是漫反射贴图，将纹理采样得到的值直接用于$K_d$项，很直观也很简单，这里不做过多赘述。</p><p><img src="2.png" alt="漫反射贴图"></p><p>此外还可以改变镜面反射系数，如粗糙度（决定高光衰减）和高光反射系数。</p><p><img src="1.jpg" alt="漫反射贴图"></p><h2 id="控制片元透明度"><a href="#控制片元透明度" class="headerlink" title="控制片元透明度"></a>控制片元透明度</h2><p>纹理都是矩形的，但当我们要实现各种贴花（$decal$）或者镂空（$cutout$）效果时，往往不想让纹理铺满整个表面，也就是说某些地方透明度为0，这时候$alphaMap$就登场了。</p><p><img src="3.png" alt="漫反射贴图"></p><p>不需要对片元执行半透明进行混合，而是进行透明度测试 (Alpha Test)，将透明度小于阈值的texel认为是完全透明，直接抛弃片元，否则为完全不透明，测试完成后，再用z-buffer算法对所有完全不透明片元进行混合。透明度测试的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(texture.a &lt; alphaThreshold)  discard</span><br></pre></td></tr></table></figure><p>但是透明度测试在使用$mipmap$时会存在问题：如下图，第0级纹理连续四个texel的透明度为 [0.0, 1.0, 1.0, 0.0]，第1级纹理会变成[0.5, 0.5]，假设我们设定alphaThreshold为0.75，可知第0级纹理有1.5/4通过测试，但是在第一级纹理中，所有的纹素的值都变成了0.5， 0.5 &lt; 0.75所以，所有像素都被抛弃。</p><p><img src="4.png" alt="漫反射贴图"></p><p>于是在不同的$mipmap$纹理等级中，经过透明度测试留下来的像素占比也不一样，因为高等级纹理是对低等级纹理的范围平均，因此随着levelD的增大，纹素值会趋于平均化，之前在阈值之上的值，被平均化以后很有可能到阈值线之下，因此被抛弃的像素就越来越多：</p><p><img src="5.jpg" alt="漫反射贴图"></p><p>我们来看一个例子，如下图所示，当相机距离树木较近时，看起来一切正常：</p><p><img src="6.png" alt="漫反射贴图"></p><p>当相机拉远后，树叶消失了一部分（由于mimmap均值化后，导致被抛弃像素占比增加）：</p><p><img src="7.png" alt="漫反射贴图"></p><p>当相机拉远到相当一段距离后，发现树叶消失的更多：</p><p><img src="8.png" alt="漫反射贴图"></p><p>一般解决办法有两个：</p><ol><li>手动调节每级mipmap透明度，或者在shader中根据纹理等级d对透明度缩放</li><li>限制d的最大值</li></ol><p>但这两种方法都只能是近似，不能很好解决问题，出现这个问题的关键点在于：不同 $mipmap$，用同样的透明度阈值会得到不同的Coverage(代表测试留存的像素比例)</p><p>Castano提出了一种：保证coverage一致的情况下，自适应确定透明度阈值，并对原透明度缩放调整的方法。</p><p><img src="9.png" alt="漫反射贴图"></p><p>经过这种特殊处理后，我们发现远处的树木表现恢复正常了。</p><p><img src="10.png" alt="漫反射贴图"></p><p><img src="11.png" alt="漫反射贴图"></p><p>另外在对RGBA值进行线性插值时，要注意把alpha分量预乘到RGB分量，再进行插值：</p><p><img src="12.png" alt="漫反射贴图"></p><p>比较理想的情况是：希望插值后的结果更偏向于不透明纹素颜色，通常而言，预乘后插值会比较合理。</p><h2 id="凹凸贴图（-BumpMapping-）"><a href="#凹凸贴图（-BumpMapping-）" class="headerlink" title="凹凸贴图（$BumpMapping$）"></a>凹凸贴图（$BumpMapping$）</h2><p>用于改变表面片元法线的技术统称为凹凸贴图($BumpMapping$),凹凸贴图把各像素法线相关的信息存储在纹理中，各像素的的法线通过这张纹理采样得到，使用采样得到的法线代替片元自身的法线进行光照着色计算，会看到凹凸不平的效果。凹凸贴图思想最早由图形学大牛Jim Blinn提出，后来的Normal Mapping，Parrallax Mapping，Parallax Occulision Mapping，Relief Mapping，均是基于同样的思想，只是考虑的越来越全面，效果越来越逼真。</p><h3 id="存储法线的几种方式"><a href="#存储法线的几种方式" class="headerlink" title="存储法线的几种方式"></a>存储法线的几种方式</h3><h4 id="heightMap"><a href="#heightMap" class="headerlink" title="$heightMap$"></a>$heightMap$</h4><p><img src="13.jpg" alt="漫反射贴图"></p><p>$heightMap$存储的是表面的相对高度，该高度的变化实际上表现了物体表面凹凸不平的特质，但是高度值不能直接用来计算光照，必须先将其转换为法线，再通过法线计算光照，这就是$heightMap$的核心原理。但是有个问题是，我们如何通过高度值计算出法线呢?</p><p><img src="14.jpg" alt="漫反射贴图"></p><p>要计算P点的法线，可以先求p点的切线，而切线正是函数曲线在p点的导数。</p><p>先拿二维的情况举例，点p的原始法线为$(0, 1)$，假设$h$为高度函数，根据差分近似求出点p的导数为：</p><p><img src="15.jpg" alt="漫反射贴图"></p><p>$dp = c * (h(p + 1) - h(p))$</p><p>点p的切线向量为：</p><p>$tangent(p) = (1, dp) = (1, c * (h(p + 1) - h(p)))$</p><p>将切线逆时针旋转90°，得到p点扰动后的法线：</p><p>$normal(p) = \begin{bmatrix}<br>    0&amp;-1\\<br>    1&amp;0<br>\end{bmatrix}tangent(p) = \begin{bmatrix}<br>    0&amp;-1\\<br>    1&amp;0<br>\end{bmatrix}\begin{bmatrix}<br>1\\<br>dp<br>\end{bmatrix} = \begin{bmatrix}<br>    -dp\\<br>    1<br>\end{bmatrix} = \begin{bmatrix}<br>    -(c∗(h(p+1)−h(p)))\\<br>    1<br>\end{bmatrix}$</p><p>注：上述推导中$c$为常数，表示法线被扰动影响大小的因子。</p><p>将上述推导到三维过程，只需要计算uv两个方向的梯度，剩下的和二维一致，计算切线，逆时针旋转90°计算法线。</p><ul><li>原始法线$n(p) = (0,0,1)$</li><li>分别计算nv两个方向上的梯度：<ul><li>$\dfrac{dp}{du} = c_1 *(h(u + 1)- h(u))$</li><li>$\dfrac{dp}{dv} = c_2 * (h(v + 1)- h(v))$</li></ul></li><li>被扰动后的法线： $normal(p) = \begin{bmatrix}<br>  \dfrac{-d_p}{d_u}\\<br>  \dfrac{-d_p}{d_v}\\<br>  1<br>\end{bmatrix}.normalized()$</li></ul><p><strong>注：所有计算出的法线都是在切线空间下的，需要乘以$TBN$矩阵转换到世界空间！</strong></p><h4 id="BumpMapping"><a href="#BumpMapping" class="headerlink" title="$BumpMapping$"></a>$BumpMapping$</h4><p>原始的凹凸贴图技术，由jim Blinn提出，后续的凹凸贴图技术都是基于其思想改进的。想法很简单，纹理贴图上每个像素点存储两个信息，一个是$u$方向的偏移向量，一个是$v$方向上的偏移向量。这样原始法线加上这两个向量后自然得到了扰动后的法线。</p><p><img src="16.jpg" alt="漫反射贴图"></p><h4 id="NormalMap"><a href="#NormalMap" class="headerlink" title="$NormalMap$"></a>$NormalMap$</h4><p>我们知道纹理中可以存储颜色信息作为漫反射系数，自然也可以存储法线信息，利用$(u,v)$坐标查询每个点的法线，代替原始模型法线，这就是$NormalMap$。</p><p>明白了$NormalMap$的原理后，有一个问题就是，如何存储这些法线信息？一种可选方案是存储对象空间下的法线信息，这样在做完纹理查询后乘以世界空间矩阵直接就可以用了，但是不好的一点是，当对象空间发生变化时，那么该法线就不再正确了。更通用的做法是存储切线空间下的法线向量。</p><p>对象空间和切线空间中的法线贴图对比：</p><p><img src="17.jpg" alt="漫反射贴图"></p><p>切线空间的存储方式更加灵活，可以更好的复用，但是要付出的代价就是需要比较复杂的空间转换过程。</p><p>应用法线贴图后的渲染结果：</p><p><img src="18.jpg" alt="漫反射贴图"></p><p>一张图解释三种凹凸贴图的区别：</p><p><img src="19.png" alt="漫反射贴图"></p><h5 id="TBN空间"><a href="#TBN空间" class="headerlink" title="TBN空间"></a>TBN空间</h5><p><img src="20.jpg" alt="漫反射贴图"></p><p>切线空间定义于每一个顶点之中，是由切线（$Tangent$），副切线（$BiTangent$），顶点法线（$Normal$）以模型顶点为中心的坐标空间。$normalMap$中的法线在切空间中表示，其中法线总是大致指向正z方向。切线空间是一个三角形表面的局部空间:法线相对于单个三角形的局部参考系。把它想象成法向量的局部空间;它们都是指向正z方向的不管最终变换的方向是什么。使用一个特定的矩阵，我们可以将这个局部切线空间的法线转换到世界空间或观察空间，并将它们沿最终映射曲面的方向定向。这个矩阵就是$TBN$矩阵。接下来将详细推导$TBN$矩阵的构造过程。</p><p><img src="22.jpg" alt="漫反射贴图"></p><p>只需要下面两个步骤即可得到规范化的$TBN$矩阵。</p><p><img src="21.png" alt="漫反射贴图"></p><p>$E_1 = \triangle{U_1}T + \triangle{V_1}B$</p><p>$E_2 = \triangle{U_2}T + \triangle{V_2}B$</p><p>该公式的数学意义是，如何将一个点从uv空间映射到三维空间，其中TB作为基向量，以uv空间中u和v的增量作为控制参数，假设三角形中存在一点p，则$\vec{AP} = u(p) <em> \vec{B} + v(p) </em> \vec{B}$,<strong>点p可以表示为以TB为基向量的uv空间，TB轴的线性组合。</strong></p><p>根据以上公式可以快速的推导出TB：</p><p>$\vec{T} = \dfrac{\triangle{V_1}E_2 - \triangle{V_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$</p><p>$\vec{B} = \dfrac{-\triangle{U_1}E_2 + \triangle{U_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$</p><p>目前给出的TB还是不是真正的切线与副切线，需要正交化后得到$TBN$矩阵:</p><p>$\vec{t}_⊥ = normalized(\vec{t} - (\vec{t}\cdot\vec{n})\vec{n})$</p><p>$\vec{b}_⊥ = normalized(\vec{b} - (\vec{b}\cdot\vec{n})\vec{n} - (\vec{b}\cdot\vec{t}_⊥)\vec{t}_⊥)$</p><p>其中n是建模软件中规定的顶点法线，可以看到n在正交化过程中不会受到影响，该过程是对TB向量进行方向的调整以及长度的归一化。TB在此过程后会相互垂直，此时将不再一定与UV方向保持相同。特别的，当调整顶点法线后，TB平面甚至将与三维空间中的三角形平面不同,也就是说归正交化后的$TBN$矩阵，$TB$轴将不再与$uv$相等，$uv$是正交化前的$TB$轴。</p><p>通过正交化后的$Tangent(T),Bitangent(B),Normal(N)$可以推导出$TBN$矩阵：</p><p>$TBN = \begin{bmatrix}<br>    T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}$</p><p>$normalMap$中存储的法线信息是基于$TBN$空间的，而光照计算需要所有的参数在同一空间下，以上计算的$TBN$矩阵就是用于将$TBN$空间中定义的法线转换到世界空间用的。</p><p>$Normal_{world} = \begin{bmatrix}<br>     T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}Normal_{tbn}$</p><p>根据矩阵的逆的性质，$TBN$矩阵的逆矩阵可以用来将向量从世界空间转换到$TBN$空间中，而$TBN$矩阵是正交化过的，根据正交矩阵的特殊性质（正交矩阵的逆等于其转置），可以轻松求得$TBN$的逆矩阵:</p><p>$TBN^{-1} = TBN^T = \begin{bmatrix}<br>    T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}$</p><p>$Vector_{tbn} = \begin{bmatrix}<br>    T_x&amp;T_y&amp;T_z\\<br>    B_x&amp;B_y&amp;B_z\\<br>    N_x&amp;N_y&amp;N_z\\<br>\end{bmatrix}Vector_{world}$</p><h5 id="利用法线贴图的信息计算模型光照"><a href="#利用法线贴图的信息计算模型光照" class="headerlink" title="利用法线贴图的信息计算模型光照"></a>利用法线贴图的信息计算模型光照</h5><p>首先是纹理采样拿到当前像素点存储的值，如果纹理贴图是经过压缩的，需要计算（补全）三个通道值，然后将每个通道的数值范围从$[0,255]$映射到$[-1, 1]$。要做基于法线的光照计算，需要保证所有的参数（法线 光照方向 观测方向等）都在同一空间下。实现方式有两种:</p><ol><li>直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li><li>使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照参数，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li></ol><p>更常用的做法是采取第二种方式，将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为lightPos和viewPos对于每个fragment都是一样的，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上不需要在像素着色器中进行任何相关的空间变换操作，而第一种方法必须在片元着色器中做转换，因为采样出来的法线对于每个像素着色器都不一样。</p><p>所以现在不是把TBN矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。这也是为什么这种方法是一种更好的实现方式的原因。以下是shader代码；</p><p><strong>vertexShader</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line">layout (location = 1) in vec3 aNormal;</span><br><span class="line">layout (location = 2) in vec2 aTexCoords;</span><br><span class="line">layout (location = 3) in vec3 aTangent;</span><br><span class="line">layout (location = 4) in vec3 aBitangent;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vs_out.FragPos = vec3(model * vec4(aPos, 1.0));   </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">    </span><br><span class="line">    mat3 normalMatrix = transpose(inverse(mat3(model)));</span><br><span class="line">    vec3 T = normalize(normalMatrix * aTangent);</span><br><span class="line">    vec3 N = normalize(normalMatrix * aNormal);</span><br><span class="line">    T = normalize(T - dot(T, N) * N);</span><br><span class="line">    vec3 B = cross(N, T);</span><br><span class="line">    </span><br><span class="line">    mat3 TBN = transpose(mat3(T, B, N));    </span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * vs_out.FragPos;</span><br><span class="line">        </span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fragmentShader</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseMap;</span><br><span class="line">uniform sampler2D normalMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;           </span><br><span class="line">     // obtain normal from normal map in range [0,1]</span><br><span class="line">    vec3 normal = texture(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    // transform normal vector to range [-1,1]</span><br><span class="line">    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space</span><br><span class="line">   </span><br><span class="line">    // get diffuse color</span><br><span class="line">    vec3 color = texture(diffuseMap, fs_in.TexCoords).rgb;</span><br><span class="line">    // ambient</span><br><span class="line">    vec3 ambient = 0.1 * color;</span><br><span class="line">    // diffuse</span><br><span class="line">    vec3 lightDir = normalize(fs_in.TangentLightPos - fs_in.TangentFragPos);</span><br><span class="line">    float diff = max(dot(lightDir, normal), 0.0);</span><br><span class="line">    vec3 diffuse = diff * color;</span><br><span class="line">    // specular</span><br><span class="line">    vec3 viewDir = normalize(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    vec3 halfwayDir = normalize(lightDir + viewDir);  </span><br><span class="line">    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);</span><br><span class="line"></span><br><span class="line">    vec3 specular = vec3(0.2) * spec;</span><br><span class="line">    FragColor = vec4(ambient + diffuse + specular, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$NormalMap$为什么都是偏蓝色的？</p><p>法线贴图是增加细节用的，因此在以原顶点法线为z轴的切线空间中，其$（r，g，b）$必然偏向$b$分量，故法线的值基本在（0，0，1）左右，经过-1到1映射到0-1在贴图存储的过程，贴图颜色变为（0.5，0.5，1），反映到颜色上自然是常见的法线贴图颜色了。</p><p>$NormalMap$压缩</p><p> 我们通常会把法线贴图归一化成一个3元向量n（x,y,z）来表示，常识上来看，因为这个n是归一化的，所以用两个向量（x,y）已经可以表示这个3元向量了，可以减少数据存储，压缩我们的贴图量。</p><ul><li>只保留两个颜色通道<ul><li>因为normal是归一化向量，其大小为1；又因为切线空间的法线z方向总是正方向，所以可以只存x和y就可以用勾股定理计算出z值（因为正方向所以取正值）。所以只保存rg两个通道。</li><li>但是如果只有一个通道那贴图压缩质量更好。所以只用g通道，并将r通道的值存入alpha透明通道。</li></ul></li></ul><h5 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h5><p>你可能会问为什么不简单地把法线看作向量。为什么要将他们区别对待呢?在前几章中，我们已经学习了使用矩阵乘法来变换点和向量。法线的问题是，当矩阵对法线均匀缩放时，没有任何问题。但是现在让我们考虑一下将非均匀缩放应用到一个物体上的情况。让我们(在2D中)画一条经过点a =(0,1,0)和点B=(1,0,0)的直线，然后从原点到坐标(1,1,0)再画一条直线，你会发现这条直线垂直于我们的平面。假设(1,1,0)是$AB$的法线.</p><p><img src="24.jpg" alt="漫反射贴图"></p><p>现在假设我们使用以下矩阵对直线应用非均匀缩放:</p><p>$\textbf{M} = \begin{bmatrix}<br>    2&amp;0&amp;0&amp;0\\<br>    0&amp;1&amp;0&amp;0\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><p><img src="25.jpg" alt="漫反射贴图"></p><p>在对$AB$和$\vec{N}$应用同样的变换矩阵$M$后,我们发现之前垂直的两条线不再垂直了,这也从侧面说明,对法线直接应用Model矩阵结果是错误的。<strong>实际上变换法线不能直接应用和变换顶点相同的矩阵M，而需要应用其逆矩阵的转置。</strong></p><p>$\vec{N^丶} = \textbf{M}^{-1T}\vec{N}$</p><p>在进行数学推导之前，先让我们从直觉上进行解释。首先法线代表方向，是一个向量，因此平移矩阵不会对其产生影响，因此向量的w分量为0，换句话说对于一个4x4的矩阵M，我们可以忽略第四行和第四列，只考虑左上角3x3的部分（缩放和旋转）。我们将3x3的矩阵分解为两个部分，分别为旋转和缩放。旋转矩阵是正交矩阵，而正交矩阵的逆等于其转置，因此对于旋转矩阵$R$来说：</p><p>$R^T =R^{-1}$</p><p>$R = R^{-1T}$</p><p><strong>旋转矩阵逆矩阵的转置等于其自身。</strong></p><p>对于缩放部分，缩放矩阵的转置等于其自身，缩放矩阵的逆可以很容易的通过其缩放因子计算：</p><p>$M^{-1T} = \begin{bmatrix}<br>    1/2&amp;0&amp;0&amp;0\\<br>    0&amp;1&amp;0&amp;0\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><p>对上图中的$\vec{N}$应用该矩阵：</p><p><img src="26.jpg" alt="漫反射贴图"></p><p>数学推导：<br>首先澄清几个概念，</p><ul><li>两个正交向量的点积等于0</li><li>两个向量的点积可以写成1x3和3x1矩阵乘积的形式</li><li>如果两个向量点积结果为0，则对应的矩阵乘积形式的结果也为0</li></ul><p>$\textbf{v}\cdot\textbf{n} = \begin{bmatrix}<br>    v_x&amp;v_y&amp;v_z<br>\end{bmatrix}\begin{bmatrix}<br>    n_x\\<br>    n_y\\<br>    n_z\\<br>\end{bmatrix} = \textbf{v} * \textbf{n}^T = 0$</p><p>$\textbf{v}\cdot\textbf{n} = \textbf{v} <em> \textbf{n}^T = v_x</em>n_x + v_y<em>n_y + v_z</em>n_z$</p><p>$\textbf{v}<em>\textbf{n}^T = \textbf{v}</em> M <em> M^{-1} </em> \textbf{n}^T$</p><p>根据矩阵转置的性质：$(AB)^T = B^TA^T$可以推导出：</p><p>$\textbf{v}<em>\textbf{n}^T = (\textbf{v}</em> M)<em>(\textbf{n}</em>M^{-1T})^T$</p><p>注意观察以上表达式，我们注意到等号右侧第一个括号内的$\textbf{v}*M$,实际上是原始顶点$v$在经过矩阵M变换后得到的$v^丶$:</p><p>$\textbf{v}^丶 = \textbf{v}*M$</p><p>我们知道两个向量在经过变换后仍然得保持垂直，因此：</p><p>$\textbf{v}<em>\textbf{n}^T = \textbf{v}^丶</em>\textbf{n}^{丶T} = 0$</p><p>因此，等号右侧的第二部分$(\textbf{n}*M^{-1T})^T$可以重写为：</p><p>$\textbf{n}^{丶T} = (\textbf{n}*M^{-1T})^T$</p><p>$\textbf{n}^丶 = \textbf{n}*M^{-1T}$</p><p>也就是说$\textbf{n}$只有经过$M^{-1T}$变换后才能<strong>成为</strong>$\textbf{n}^丶$，才能做到变换后依然和$v^丶$垂直。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/261667233">用一篇文章理解法线变换、切线空间、法线贴图</a></p><p><a href="https://zhuanlan.zhihu.com/p/139593847">切线空间（Tangent Space）完全解析</a></p><p><a href>RealTime Rendering</a></p><p><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">learningOpenGL</a></p><p><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101</a></p><p><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry/transforming-normals">scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（三）：纹理映射</title>
      <link href="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"/>
      <url>/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（三）：纹理映射"><a href="#计算机图形学（三）：纹理映射" class="headerlink" title="计算机图形学（三）：纹理映射"></a>计算机图形学（三）：纹理映射</h1><h2 id="纹理管线-The-Texture-Pipeline"><a href="#纹理管线-The-Texture-Pipeline" class="headerlink" title="纹理管线($The\;Texture\;Pipeline$)"></a>纹理管线($The\;Texture\;Pipeline$)</h2><p>纹理映射 ($Texture Mapping$) 是一种将物体空间坐标点转化为纹理坐标，进而从纹理上获取对应纹素值，以增强着色细节的方法。</p><p>纹理管线($The\;Texture\;Pipeline$), 也就是单个纹理应用到纹理贴图的详细过程,其中每一个步骤均可以被用户灵活控制。</p><p><img src="1.png" alt="纹理映射步骤"></p><p>一个砖墙的纹理管线处理过程。</p><p><img src="9.jpg" alt="纹理映射步骤"></p><p>假设拥有三维模型空间到二维纹理空间的映射关系,只需要将每个顶点的颜色信息存储在二维纹理贴图上,在进行光照计算时根据<strong>映射关系</strong>查询每个顶点的颜色信息。所有点计算完后，就好像整个纹理被贴到了物体表面一样。但是如何建立这种映射关系呢？接下来介绍两种方式。</p><h2 id="投影映射-从物体坐标系到参数空间（-Projector-and-Mapping-）"><a href="#投影映射-从物体坐标系到参数空间（-Projector-and-Mapping-）" class="headerlink" title="投影映射-从物体坐标系到参数空间（$Projector\;and\;Mapping$）"></a>投影映射-从物体坐标系到参数空间（$Projector\;and\;Mapping$）</h2><h3 id="Projector"><a href="#Projector" class="headerlink" title="$Projector$"></a>$Projector$</h3><p>对于简单规则的几何体，通常用投影的方式。</p><p><img src="2.jpg" alt="纹理映射步骤"></p><p>这种将矩形地图纹理均匀贴到球面的投影函数称为：$Spherical$</p><p>此外还有Plane，Cubic，Cylindrical：</p><p><img src="3.png" alt="纹理映射步骤"></p><h3 id="UV-Mapping"><a href="#UV-Mapping" class="headerlink" title="$UV\;Mapping$"></a>$UV\;Mapping$</h3><p>对于更复杂的物体，往往需要建模师精心制作，将三维顶点与二维纹理坐标一一对应。<br>在实时渲染中，通常将uv信息保存在顶点中，在三角形光栅化时，通过重心坐标插值的方式计算每个片元的uv坐标。再从纹理中采样获得对应值。把这个颜色信息作为该点的漫反射系数$K_d$。</p><h2 id="纹理坐标（uv）"><a href="#纹理坐标（uv）" class="headerlink" title="$纹理坐标（uv）$"></a>$纹理坐标（uv）$</h2><p>在纹理空间内任意一个二维坐标都在$[0,1]$之内（其实本质上是百分比）。如下图右侧可视化纹理空间空间所示。u对应x轴（r），v对应y轴（g），因此我们看到的纹理空间是偏红绿色的。</p><p><img src="18.png" alt="纹理映射步骤"></p><h2 id="变换函数-从参数空间到纹理空间（-Corresponder-Function-）"><a href="#变换函数-从参数空间到纹理空间（-Corresponder-Function-）" class="headerlink" title="变换函数-从参数空间到纹理空间（$Corresponder\;Function$）"></a>变换函数-从参数空间到纹理空间（$Corresponder\;Function$）</h2><p>在上一步中，我们将三维空间坐标映射到了<strong>二维参数空间uv</strong>。在此阶段可以做三件事：坐标范围处理、坐标自由变换、转到纹理空间。</p><h3 id="坐标范围处理"><a href="#坐标范围处理" class="headerlink" title="坐标范围处理"></a>坐标范围处理</h3><p>通常拿到的uv都是在$[0, 1]$范围内的，但也有可能超出了范围。针对超出范围的值，有几种不同的处理方式，拿openGl举例来说，有以下四种方式来处理uv在$[0,1]$范围外的情况：</p><p><img src="19.png" alt="纹理映射步骤"></p><ol><li><p>$Repeat$：纹理环绕默认行为，超出范围将重复纹理：$uv = mod(uv,vec2(1.0))$</p></li><li><p>$Mirror$: 和$Repeat$相同，但是每次重复都会做镜像反转：$uv = abs(mod(uv,vec2(1.0)) - 1.0)$</p></li><li><p>$Clamp\;To\;Edge$:将坐标限制在0和1之间。所有超出1的uv将被设置为1.造成边缘图案被拉伸的效果：$uv = clamp(uv,vec2(0.0), vec2(1.0))$</p></li><li><p>$Clamp\;To\;Border$:超出$[0,1]$范围uv坐标对应的片元使用用户自定义的颜色填充：$uv = clamp(uv,vec2(0.0), vec2(1.0))$</p></li></ol><h3 id="坐标自由变换"><a href="#坐标自由变换" class="headerlink" title="坐标自由变换"></a>坐标自由变换</h3><p>除了对这些超出范围的uv值处理，还可以对其施加“变换”，比如旋转，平移，缩放，比如想要让纹理随着时间运动起来，那么就可以逐帧偏移uv值<br>但要注意的是：对uv坐标施加的变换矩阵，往往是实际想要变换的逆矩阵。<br>如：若想让纹理向右偏移0.5单位，那么则应该是$u – 0.5$而不是$u + 0.5$。就好比是通过一个窗口去看这张纹理，$uv$就是窗口，窗口向左移动，看起来就是纹理向右移动</p><h3 id="变换到纹理空间"><a href="#变换到纹理空间" class="headerlink" title="变换到纹理空间"></a>变换到纹理空间</h3><p>在对uv进行变换后，其值都落到了$[0, 1]$之间，这时只需要分别乘以纹理的宽高，就可以得到实际的纹理坐标。</p><h2 id="纹理采样（-Texture-Sampling-）"><a href="#纹理采样（-Texture-Sampling-）" class="headerlink" title="纹理采样（$Texture\;Sampling$）"></a>纹理采样（$Texture\;Sampling$）</h2><p>屏幕上的每个单元格我们称之为像素($Pixel$),与之相对应，纹理上的一个单元我们称为纹素($Texel$)。理想情况下，我们希望每个像素和每个纹素一一对应。即纹理图片分辨率和物体一致，这样渲染的结果不会失真。只需要每个texel逐个读取即可。但现实情况是，纹理往往会过大或过小。针对这两种不同的情况，需要分别来处理。</p><h3 id="footprint"><a href="#footprint" class="headerlink" title="$footprint$"></a>$footprint$</h3><p>纹理过小，一个小范围内的像素将对应同一个纹素，需要放大（$Magnification$），是一个上采样（$upsampling$）的过程。纹理过大，一个像素覆盖很多个纹素，需要缩小（$Minification$）,是一个下采样($downsampling$)的过程。</p><p><img src="11.png" alt="纹理映射步骤"></p><h3 id="纹理过小"><a href="#纹理过小" class="headerlink" title="纹理过小"></a>纹理过小</h3><p>想象将一张很小的图贴到物体上，如果使用着色点的uv取最近的纹素，物体上一个区域内的着色点将对应纹理上同一个纹素，这必然会造成失真，为此我们需要根据当前着色点uv，取周围最近4个顶点（纹理网格顶点），通过加权平均计算当前着色点的颜色，缓解这种走样现象。<br>下面介绍双线性插值，实现不同的上采样纹理插值。</p><p>（1） 计算$p$点周围四个点的位置，方法是+0.5后保留小数，用范围为$[0, 1]$的$(u^丶，v^丶)$表示<br>（2） 选取计算权重函数f，有多种函数可选择，计算横向和纵向插值的权重$(w_u,w_v)$<br>（3）先后对横向和纵向两个方向进行插值（共三次，横向两次，纵向一次）。得到最终纹理值。</p><p><img src="9.png" alt="纹理映射步骤"></p><h3 id="纹理过大"><a href="#纹理过大" class="headerlink" title="纹理过大"></a>纹理过大</h3><p><img src="20.png" alt="纹理映射步骤"></p><p>纹理过大，导致一个pixel覆盖了多个texel,会使生成的图像产生更明显的失真。近处产生锯齿，远处产生摩尔纹。为什么远处会产生摩尔纹呢？这种现象是光栅化的算法导致的。我们知道，一个三角形有顶点坐标和纹理坐标，纹理坐标范围是$[0-1]$。光栅化的过程就是把三角形在屏幕上离散化为像素的过程，插值计算三角形内部每个像素的顶点数据，包括常见的深度值与纹理坐标。如果这个三角形距离camera近,也就是说在屏幕上占了较多的像素，那么相邻两个像素的纹理坐标是接近的，这样通过纹理坐标获得纹理贴图上的纹素值也是接近的，这样这俩个像素看起来比较平滑，视觉上不突兀，同时gpu读取也快速，因为大部分纹素是在cache中读取的。而如果这个三角形距离camera较远，也就是在屏幕上只占了很少的像素，这种情况就是一个小物体应用了一个大纹理，光栅化后，相邻两个像素的纹理坐标差别会很大，读取到的纹素也会差别很大，会很突兀，尤其是camera移动时特别明显，因为很小的移动会造成纹素采样变化很大，产生闪烁现像，除此之外，gpu读取性能也很低效，因为两个相邻的像素所对应的纹素，一个可能在cache中，另一个还没有加载到cache中。</p><h4 id="superSampling"><a href="#superSampling" class="headerlink" title="$superSampling$"></a>$superSampling$</h4><p>这种现象被形象的称为屏幕像素在texture空间的footprint。一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实就是欠采样的一种表现，一种直观的解决方法就是Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？但问题是这种超采样的方式造成很大的性能问题。我们可以换种思路，不做超采样，而是求出每个像素对应footPrint里所有texel的颜色均值，而这种技术正是Mipmapping。</p><h3 id="Mipmapping"><a href="#Mipmapping" class="headerlink" title="$Mipmapping$"></a>$Mipmapping$</h3><p><img src="12.png" alt="纹理映射步骤"></p><p>$Mipmapping$基本思想就是预生成一系列不同尺寸的多级纹理，纹理采样时，计算对应的细节等级，再利用三线性插值($Trilinear interpolation$)计算获取最终纹理值。</p><p><img src="13.png" alt="纹理映射步骤"></p><p>level0代表的是原始texture，也是精度最高的纹理，随着等级的提升，每提升一级将4个相邻纹素点求均值合为一个像纹素点，因此越高等级也就代表了越大的footprint区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p><h4 id="计算像素点的-footPrint及levelD"><a href="#计算像素点的-footPrint及levelD" class="headerlink" title="计算像素点的$footPrint及levelD$"></a>计算像素点的$footPrint及levelD$</h4><p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以，<strong>一个像素的大小</strong>)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，近似得到footPrint，二者取最大值，计算公式如图中所示，那么level D就是这个距离的log2值 (D = log2L) 。</p><p><img src="14.png" alt="纹理映射步骤"></p><p><img src="15.png" alt="纹理映射步骤"></p><p><img src="16.png" alt="纹理映射步骤"></p><p>但是这里计算出的D值是一个带小数的值，而我们事先定义的levelD都是整数，这里可以通过$ceil和floor$函数分别取当前D值的上一层和下一层。分别对这两层纹理做双线性插值，最后在层与层之间再做一次线性插值，插值权重根据D值的小数部分来计算。</p><h4 id="三线性插值"><a href="#三线性插值" class="headerlink" title="三线性插值"></a>三线性插值</h4><p><img src="17.png" alt="纹理映射步骤"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在通过纹理采样取得颜色值后，并不一定直接将纹理值作为颜色使用，还有很多其他用途，例如$normalMap$中存储顶点法线，$shadowMap$第一个pass存储相机在光照空间下的深度纹理等等，在$bumpMap$中当作高度偏移值等等。</p><p>总结纹理映射的几个步骤。</p><p><img src="1.png" alt="纹理映射步骤"></p><p>1） 投影映射：将三维物体坐标转化为二维参数空间$uv$坐标，实时渲染中,$uv$坐标通常是保存在顶点信息中。</p><p>2） 变换函数：将$uv$坐标经过处理变换后，根据实际的纹理尺寸，转化为纹理空间坐标，此时也可能有小数。</p><p>3） 纹理采样：依据纹理空间坐标，对纹理进行采样，要处理放大和缩小两个情况，其中缩小的情况更为复杂，牵涉到各向异性过滤的算法。</p><p>4） 纹理转换：通过采样得到纹理值后，往往不能直接使用，还需要进行相应转换才能使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://zhuanlan.zhihu.com/p/369977849">纹理映射流程</a></p><p><a href="https://github.com/QianMo/Real-Time-Rendering-3rd-CN-Summary-Ebook">Real-Time Rendering 3rd》提炼总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（二）：着色</title>
      <link href="/2022/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%9D%80%E8%89%B2/"/>
      <url>/2022/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%9D%80%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（二）：着色"><a href="#计算机图形学（二）：着色" class="headerlink" title="计算机图形学（二）：着色"></a>计算机图形学（二）：着色</h1><p>渲染过程本质可以上分解为两个步骤:可见性测试和着色。光栅化和光线追踪本质上都是用于解决可见性问题。本章我们将介绍渲染过程的第二部分:着色。着色是一个庞大的主题。一些用于着色的技术在数学上也很复杂。本章我们将学习最基本的着色模型: $Blinn-Phong\;Reflectance\;Model$</p><h2 id="blinn-Phong-Reflectance-Model"><a href="#blinn-Phong-Reflectance-Model" class="headerlink" title="$blinn-Phong\;Reflectance\;Model$"></a>$blinn-Phong\;Reflectance\;Model$</h2><p>当我们观察一个物体时，可以明显的将物体的视觉表现分为三类：</p><ul><li>高光：表现很亮的部分，并且会随着视角的变化而变化</li><li>漫反射部分：颜色变化不明显，表示物体本身的颜色或者diffuse颜色。（物体表面吸收了部分光线，反射出的未被吸收的部分）</li><li>环境光：未被光照直接照亮的部分，<strong>模拟间接光照</strong>。在布林冯模型中简化为常量。这也是为什么布林冯模型被称为经验模型的原因。计算精确的间接光照需要$RayTracing$。</li></ul><p><img src="1.png" alt="blinn-phong"></p><p>布林冯光照模型是一个经验模型。整体思想就是按照这三部分来建模的。布林冯光照模型是一个直接光照模型（或者叫局部光照/局部性），不考虑间接光照，即不考虑周围物体反射的光线对其产生的影响。着色权重仅考虑光源。（阴影及SSAO需要多个pass处理）</p><h3 id="定义光照参数"><a href="#定义光照参数" class="headerlink" title="定义光照参数"></a>定义光照参数</h3><p>要计算物体表面着色点光照结果，需要定义一些基本的参数。</p><p><img src="2.png" alt="blinn-phong"></p><ul><li>观测方向（$view direction$）$\hat{v}$:着色点到观测点（相机）的单位向量</li><li>光照方向（$light direction$）$\hat{l}$：着色点到光源的单位向量</li><li>着色点法线（$normal$）$\hat{n}$：垂直于表面的向量，用于描述表面（或着色点）的方向。</li><li>物体表面本身着色参数（漫反射颜色 高光颜色 粗糙度…）</li></ul><h3 id="漫反射（-Diffuse-Reflection-）"><a href="#漫反射（-Diffuse-Reflection-）" class="headerlink" title="漫反射（$Diffuse\;Reflection$）"></a>漫反射（$Diffuse\;Reflection$）</h3><p>当一根光线打到物体表面后，光线会被均匀的反射到不同的方向（其实这也是一种近似）。<br><img src="4.png" alt="blinn-phong"></p><h4 id="Lambert’s-cosine-law"><a href="#Lambert’s-cosine-law" class="headerlink" title="$Lambert’s\;cosine\;law$"></a>$Lambert’s\;cosine\;law$</h4><p>当一束光到达物体表面时，表面朝向（法线方向）与光照方向的角度不同，得到的明暗也是不一样的，着色点法线与光线夹角越大，表面实际接收到的光线越少，<strong>物体表面接收到的光照能量与着色点法线和光照夹角余弦成正比。</strong>由于法线和光照方向均为单位向量。因此表面着色点接收到的能量正比于$\hat{n}\cdot\hat{l}$</p><p><img src="4.jpg" alt="blinn-phong"></p><h4 id="Lambert-Shading"><a href="#Lambert-Shading" class="headerlink" title="$Lambert\;Shading$"></a>$Lambert\;Shading$</h4><p>我们知道球体表面积公式:$A = 4\pi{r^2}$对于点光源来说，假设点光源辐射的能量是均匀的。那么随着着色点和光源距离的增加，着色点接收到的能量就越少（距离增加导致球体表面积增大，而单位时间单位立体角点光源辐射的能量是一样的，因此单位面积接收到的能量会衰减）。着色点接收到的能量与距离平方成反比。</p><p><img src="5.png" alt="blinn-phong"></p><p>漫反射分量：<br>$L_d = K_d\dfrac{I}{r^2}max(0, \hat{n}\cdot\hat{l})$</p><ul><li>Kd（漫反射系数）：光到达物体表面后，能量会被吸收一部分（不同材质的物体对不同波长的光线吸收率是不一样的），剩下的会被反射出来，漫反射系数即定义了不被物体所吸收的光照颜色（$diffuseColor$），即物体表现出的颜色。</li><li>$\dfrac{I}{r^2}$：光照能量衰减系数，抵达物体表面的能量与光源和着色点距离平方成反比。</li><li>$max(0,\hat{n}\cdot\hat{l})$:  $Lambert’s\;cosine\;law$，表面着色点接收到的能量正比于$\hat{n}\cdot\hat{l}$。为了避免负值情况使用max做了最小值约束。</li></ul><p><img src="6.png" alt="blinn-phong"></p><p><img src="7.jpg" alt="blinn-phong"></p><p>$K_d$系数对漫反射表现得影响：</p><p>随着$K_d$的增加（吸收光线减少，反射光线增加），物体表现越来越明亮。</p><p><img src="8.png" alt="blinn-phong"></p><h3 id="高光（-Specular-Reflection-）"><a href="#高光（-Specular-Reflection-）" class="headerlink" title="高光（$Specular\;Reflection$）"></a>高光（$Specular\;Reflection$）</h3><p>让我们从反射开始，反射是光与物质相互作用的一种形式。反射是光子或入射光束撞击到反射表面的结果，例如玻璃，光滑的金属，镜子都容易形成高光反射。反弹的方向与撞击点表面法线方向对称，也就是说，如果入射方向与表面法线的夹角记为$\theta_i$，反射方向与表面法线的夹角为$\theta_r$，则$\theta_i = \theta_r$。即反射定律。因此当观测方向与光线反射方向接近时，高光表现强烈，反之高光表现减弱，高光项与反射向量和观测向量的点积成正比。因此高光是与观测方向紧密相关的。</p><p><img src="9.png" alt="blinn-phong"></p><h4 id="计算反射向量"><a href="#计算反射向量" class="headerlink" title="计算反射向量"></a>计算反射向量</h4><p>接下来需要计算反射向量，然后计算反射向量和观测向量点积，即可得到从当前视角观测着色点的高光分量。那么如何计算反射向量呢？可以先计算$\hat{L}$在$\hat{n}$上的投影向量$\vec{B}$（向量点积即可），然后根据向量加法计算$\vec{A}$向量。如下：</p><p><img src="10.png" alt="blinn-phong"></p><p>$\vec{B} = \cos\theta_i||\vec{L}||\hat{n} = (\hat{L}\cdot\hat{n})\hat{n}\\ \dfrac{\vec{A}}{2} = \vec{B}-\hat{L} = (\hat{L}\cdot\hat{n})\hat{n} - \vec{L}\\<br>\vec{R} = \vec{B} + \dfrac{\vec{A}}{2} = (\hat{L}\cdot\hat{n})\hat{n} + (\hat{L}\cdot\hat{n})\hat{n} - \vec{L} =2(\hat{L}\cdot\hat{n})\hat{n} - \hat{L}$</p><h4 id="半程向量（-half-vector-）"><a href="#半程向量（-half-vector-）" class="headerlink" title="半程向量（$half\;vector$）"></a>半程向量（$half\;vector$）</h4><p>但是以上计算反射向量来计算高光系数的方式过于繁琐，有一种更简便的办法，通过<strong>半程向量</strong>（光照方向和观测方向的角平分线方向，利用向量平行四边形法则求和然后归一化处理即可）。半程向量与法线方向越接近，则观测方向与反射方向就越接近。因此可以计算半程向量和法线的点积来代替反射方向与观测方向的点积，因为半程向量好计算（只需要加法操作），节省了一次向量点积带来的运算开销。</p><p><img src="11.png" alt="blinn-phong"></p><p>$\hat{h} = \textbf{bisector(\textbf{v}, \textbf{l})} = \dfrac{\hat{l} + \hat{v}}{||\hat{l}|| + ||\hat{v}||}$</p><h4 id="高光计算公式"><a href="#高光计算公式" class="headerlink" title="高光计算公式"></a>高光计算公式</h4><p><img src="16.png" alt="blinn-phong"></p><ul><li>$K_s$（镜面反射系数）:系数越大，亮度越大。同时因为高光通常是白色，所以表示颜色通常也为白色。</li><li>$\dfrac{I}{r^2}$: 布林冯为经验模型，用抵达着色点的能量近似代替被着色点接收的能量，因此此处并没有像漫反射一样计算夹角余弦。</li><li>$bisector$: 布林冯模型对冯模型的改进，用半程向量代替反射向量，减少了一次点积计算。</li><li>$指数P$:该指数用于加快函数的衰减程度，由于在物理世界中高光存在于物体表面很小的一部分，而余弦的衰减速度太慢，通过携带指数，可以促进衰减速度，使得高光只能在与法线向量非常接近的情况下才能被视角看见.</li></ul><p><img src="13.png" alt="blinn-phong"></p><p><img src="14.png" alt="blinn-phong"></p><h3 id="环境光（-Ambient-）"><a href="#环境光（-Ambient-）" class="headerlink" title="环境光（$Ambient$）"></a>环境光（$Ambient$）</h3><p>在 Blinn-Phong 模型中，提出了一个非常大胆的假设：物体表面接收到的各种环境光都是相同强度的。当然，这并不符合常理，但是大大简化了计算环境光的步骤，强度相同，意味着反射光的强度也相同，而由于环境光来自四面八方的物体反射，所以该物体表面反射环境光的方向也是四面八方的，那么：环境光与光源的角度无关，与观察角度也无关，所以它是一个常数。</p><p>计算环境光的公式非常简单，只需要得到物体表面的环境光吸收率和环境光的强度即可：</p><p>$L_a = K_a{I_a}$</p><h3 id="总结-blinn-Phong-Reflectance-Model"><a href="#总结-blinn-Phong-Reflectance-Model" class="headerlink" title="总结$blinn-Phong\;Reflectance\;Model$"></a>总结$blinn-Phong\;Reflectance\;Model$</h3><p>最后，将漫反射、高光和环境光作用在物体表面上的效果叠加在一起，就可以得到近似于物理光照的效果。</p><p><img src="15.png" alt="blinn-phong"></p><p>$L = L_a+L_d+L_s = K_aI_a + K_d\dfrac{I}{r^2}max(0, \hat{n}\cdot\hat{l}) + K_s\dfrac{I}{r^2}max(0, \hat{n}\cdot\hat{h})^p$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=7&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（一）：辐射度量学</title>
      <link href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
      <url>/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（一）：辐射度量学"><a href="#计算机图形学（一）：辐射度量学" class="headerlink" title="计算机图形学（一）：辐射度量学"></a>计算机图形学（一）：辐射度量学</h1><h2 id="辐射度量学（-Radiometry-）"><a href="#辐射度量学（-Radiometry-）" class="headerlink" title="辐射度量学（$Radiometry$）"></a>辐射度量学（$Radiometry$）</h2><p> 辐射度量学是基于物理光照的基础，是基于几何光学来定义的，提供了精准的关于光的各种物理量，光与物体表面的作用，光线传播方法的定义等。辐射度量学是反射方程、渲染方程的基础。</p><p> <img src="10.png" alt="Irradiance"></p><h2 id="1-辐射能量（-Radiant-energy-）"><a href="#1-辐射能量（-Radiant-energy-）" class="headerlink" title="1.辐射能量（$Radiant\;energy$）"></a>1.辐射能量（$Radiant\;energy$）</h2><p>在辐射度量学中最基本的单位是辐射能量，表示为$Q$,单位是$J(焦耳)$，辐射能量$Q$以辐射的形式发射，传播或接收的能量。每个光子都携带一定的能量，这个能量正比于它的频率：</p><p>$Q = hv$</p><p>其中$h = 6.62620\times (10^{-34})J$.光子的频率（或者说能量）影响着光子与物体表面的交互，更重要的是，它影响着光与感应器之间的作用，使不同频率的光被察觉为不同的颜色。</p><h2 id="2-辐射通量（-Radiant-flux-）"><a href="#2-辐射通量（-Radiant-flux-）" class="headerlink" title="2.辐射通量（$Radiant\;flux$）"></a>2.辐射通量（$Radiant\;flux$）</h2><p>辐射通量，记为为$Φ$，表示单位时间 发射/反射/传播/接受的能量(功率-power)。单位为（$watt$）W或者($lumen$)lm，在辐射测量中，都是基于这个辐射通量来测量能量的，而不是使用能量$Q$。</p><p>$Φ = \dfrac{dQ}{dt}$</p><h2 id="3-辐射强度（-Radiant-intensity-）"><a href="#3-辐射强度（-Radiant-intensity-）" class="headerlink" title="3.辐射强度（$Radiant\;intensity$）"></a>3.辐射强度（$Radiant\;intensity$）</h2><p>辐射强度，记为$I$,<strong>表示一个点光源在单位立体角上发射能量的功率</strong>。表示光源在某一方向上的辐射功率。单位为$(candela)$cd.</p><p><img src="1.png" alt="radiant intensity"></p><h3 id="角度和立体角"><a href="#角度和立体角" class="headerlink" title="角度和立体角"></a>角度和立体角</h3><p>二维空间中的角度等于对应弧长除以圆的半径。</p><p><img src="11.png" alt="radiant intensity"></p><p>扩展到三维空间，三维空间中的立体角等于对应球体的表面积除以球体半径平方。</p><p><img src="12.png" alt="radiant intensity"></p><p>在辐射度量学里，通常用$\omega$表示三维空间中的某个方向。$\omega$可以用$\theta和\phi$两个参数定义它的位置。并且可以通过$\sin\theta{d}\theta{d}\phi$表示它的单位立体角。</p><p><img src="14.png" alt="radiant intensity"></p><p>$I(w) = \dfrac{dΦ}{dw}$</p><p>对于空间中的一个点光源，$Radiant\;intensity$表示光源在任意方向上的发射功率。</p><p><img src="2.png" alt="radiant intensity"></p><h3 id="各向同性点光源"><a href="#各向同性点光源" class="headerlink" title="各向同性点光源"></a>各向同性点光源</h3><p>对于空间中各向同性（各方向发射功率相同）的点光源。任意方向辐射功率都是相同的。因此：</p><p>光源所有方向单位立体角的$Radiant\;intensity$的积分等于光源的总功率。</p><p>$Φ = \int_{s^2}Idw$</p><p>任意方向上单位立体角的$Radiant\;intensity$等于</p><p>$I = \dfrac{Φ}{4\pi}$</p><p><img src="13.png" alt="radiant intensity"></p><h2 id="4-辐射照度（-Irradiance-）"><a href="#4-辐射照度（-Irradiance-）" class="headerlink" title="4. 辐射照度（$Irradiance$）"></a>4. 辐射照度（$Irradiance$）</h2><p>辐射照度，记为$E$，表示单位投影面积的能量功率，用于描述物体表面单位面积接收到的辐射功率。单位为$lux$。</p><p><img src="4.png" alt="Irradiance"></p><p>$E(x) = \dfrac{dΦ(x)}{dA}$</p><h2 id="5-辐射亮度（-Radiance-）"><a href="#5-辐射亮度（-Radiance-）" class="headerlink" title="5. 辐射亮度（$Radiance$）"></a>5. 辐射亮度（$Radiance$）</h2><p>用于描述光线在传播过程中的属性。记为$L$，<strong>表示为单位投影面积 单位立体角被发射/反射/转换/接收的辐射功率（一条光线所携带的功率）。</strong>.单位为$nit$</p><p>$L(p,w) = \dfrac{d^2Φ(p,w)}{dwdA\cos\theta}$</p><p>$Radiance$做两次微分，一次是单位立体角，一次是投影面积，两次微分后，将功率收束为一条光线。</p><p><img src="5.png" alt="Radiance"></p><h3 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h3><p>1.$Radiant\;intensity$</p><p>$Radiant\;intensity$是点光源在某一方向单位立体角的辐射功率，是一个由点及面的过程。</p><p><img src="6.jpg" alt="Radiance"></p><p>$Radiance$可以理解为$Radiant\;intensity$在单位投影面积上的微分，将光源从$w$方向单位立体角辐射的功率收束为一条光线。描述了光线发射过程中，光线传播的性质。</p><p>一句话描述$Radiance$等于单位投影面积上的$Radiant\;intensity$</p><p>$L(p,w) = \dfrac{dI(p,w)}{dA\cos\theta}$</p><p>2.$Irradiance$</p><p><img src="7.png" alt="Radiance"></p><p>$Radiance$也可以理解为$Irradiance$在某一方向$W$单位立体角上接收的光照辐射功率，是物体表面单位面积$dA$接收的各个方向的辐射功率（$Irradiance$）在某一单位立体角上的微分。描述了物体接收光照辐射过程中光线的“形状”。</p><p>一句话描述$Radiance$等于单位立体角上的 $Irradiance$。</p><p>$L(p,w) = \dfrac{dE(p)}{dw\cos\theta}$</p><p>总结：</p><p>$L(p,w) = \dfrac{dI(p,w)}{dA\cos\theta} = \dfrac{dE(p)}{dw\cos\theta} = \dfrac{d^2Φ(p,w)}{dwdA\cos\theta}$</p><h2 id="Irradiance-vs-Radiance"><a href="#Irradiance-vs-Radiance" class="headerlink" title="$Irradiance\;vs\;Radiance$"></a>$Irradiance\;vs\;Radiance$</h2><p>$Irradiance$: 单位面积$dA$接收到的所有能量</p><p>$Radiance$：单位面积$dA$从方向$dw$上接收到的能量。</p><p>$E(p) =  \int_{H^2}L_i(p,w)\cos\theta{dw}$</p><p>$dE(p,w) = L_i(p,w)\cos\theta{dw}$</p><p><strong>单位面积$dA$上的$Irradiance$等于各个角度$Radiance$的半球积分。</strong></p><p><img src="8.png" alt="Radiance"></p><h2 id="辐射度测量术语表"><a href="#辐射度测量术语表" class="headerlink" title="辐射度测量术语表"></a>辐射度测量术语表</h2><div class="table-container"><table><thead><tr><th>名称</th><th>符号</th><th>En</th><th>SI单位</th><th>描述</th></tr></thead><tbody><tr><td>辐射能量</td><td>$Q$</td><td>$Radiant\;Energy$</td><td>$J$</td><td>一段时间内辐射的总能量</td></tr><tr><td>辐射通量</td><td>$Φ$</td><td>$Radiant\;flux$</td><td>$Watt$或$lm$</td><td>单位时间 发射/反射/传播/接受的能量(功率-power)</td></tr><tr><td>辐射强度</td><td>$I$</td><td>$Radiant\;intensity$</td><td>$candela$</td><td>点光源在单位立体角上的辐射功率</td></tr><tr><td>辐射照度</td><td>$E$</td><td>$Irradiance$</td><td>$lux$</td><td>单位投影面积接收到的辐射功率</td></tr><tr><td>辐射强度</td><td>$L$</td><td>$Radiance$</td><td>$nit$</td><td>单位投影面积 单位立体角被发射/反射/转换/接收的辐射功率（一条光线所携带的功率）</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.thegibook.com/">全局光照技术：从离线到实时渲染</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十五）：贝塞尔曲线</title>
      <link href="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
      <url>/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十五）：贝塞尔曲线"><a href="#图形学的数学基础（十五）：贝塞尔曲线" class="headerlink" title="图形学的数学基础（十五）：贝塞尔曲线"></a>图形学的数学基础（十五）：贝塞尔曲线</h1><h2 id="贝塞尔曲线-Bezier-curve"><a href="#贝塞尔曲线-Bezier-curve" class="headerlink" title="贝塞尔曲线($Bézier\;curve$)"></a>贝塞尔曲线($Bézier\;curve$)</h2><p>用一系列控制点定义的曲线,如下图所示:曲线由四个控制点定义(三阶贝塞尔曲线),从$P_0$开始,沿着$P_0-P_1$切线方向行进,结束时沿着<br>$P_2-P_3$方向,结束于$P_3$点。</p><p><img src="1.png" alt="贝塞尔曲线"></p><h2 id="参数方程-de-Casteljau-Algorithm"><a href="#参数方程-de-Casteljau-Algorithm" class="headerlink" title="参数方程-$de\;Casteljau\;Algorithm$"></a>参数方程-$de\;Casteljau\;Algorithm$</h2><p>首先考虑由三个控制点组成的二次贝塞尔曲线（ $quadratic\;Bézier$）：</p><p><img src="2.png" alt="贝塞尔曲线"></p><p>假设有一颗沿着曲线运动的小球，当$t = 0$,球体在$b_0$点，当$t = 1$，球体在$b_1$点 定义曲线关于时间$t$的参数方程，实质上就是求在任意时间$t$（$0&lt;=t&lt;=1$）,球体的位置。这就是$de\;Casteljau$算法的核心思想，将曲线方程转换成了求一个点位置。</p><p>求解步骤：</p><p>1&gt; 三个控制点$b_0,b_1,b_2$组成了两条线段，假设时间为$t$,分别去计算两条线段$b_0-b_1和b_1-b_2$在时间$t$上的位置（实际上是线性插值）,得到$b^1_0和b^1_1$.</p><p><img src="4.png" alt="贝塞尔曲线"></p><p>2&gt; 将$b^1_0和b^1_1$连成一条线，在该线段上继续找$t$的位置，得到$b^2_0$ :</p><p><img src="5.png" alt="贝塞尔曲线"></p><p>3&gt; 最终收敛的点$b^2_0$即是我们要找的在时间$t$球体在曲线上的位置。</p><p>由此可见，$de\;Casteljau$算法是一个递归的线性插值的过程，每次递归将减少一个控制点，最终收敛到一个点，即是我们要寻找的答案。</p><h3 id="三阶贝塞尔曲线（-cubic-Bezier-curve-）"><a href="#三阶贝塞尔曲线（-cubic-Bezier-curve-）" class="headerlink" title="三阶贝塞尔曲线（$cubic\;Bézier\;curve$）"></a>三阶贝塞尔曲线（$cubic\;Bézier\;curve$）</h3><p>套用二阶贝塞尔曲线的思路，三阶贝塞尔曲线无非是多了一个控制点而已，每次计算多了一次递归而已。</p><p><img src="6.png" alt="贝塞尔曲线"></p><p><img src="11.gif" alt="贝塞尔曲线"></p><h2 id="代数形式"><a href="#代数形式" class="headerlink" title="代数形式"></a>代数形式</h2><p>从金字塔底部开始，每两个相邻的点做一次线性插值，形成新的点，对新的点继续做同样规则的线性插值，最终收敛到一个点。</p><p><img src="7.png" alt="贝塞尔曲线"></p><p>拿二阶贝塞尔曲线举例：</p><p><img src="9.png" alt="贝塞尔曲线"></p><p>$b^1_0(t) = (1-t)b_0 +tb_1$</p><p>$b^1_1(t) = (1-t)b_1 +tb_2$</p><p>$b^2_0(t) = (1-t)b^1_0 +tb^1_1$</p><p>$b^2_0(t) = (1-t)^2b_0 + 2t(1-t)b_1 + t^2b_2$</p><p>由此可见，二阶贝塞尔曲线在时间$t$上的点，是$b_0,b_1,b_2$和时间$t$的某种组合。类似于二项式$(a+b)^2 = a^2 + 2ab + b^2$的展开形式。</p><h3 id="伯恩斯坦多项式"><a href="#伯恩斯坦多项式" class="headerlink" title="伯恩斯坦多项式"></a>伯恩斯坦多项式</h3><p>由$n+1$个控制点组成的$n$阶贝塞尔曲线，在时间$t$上点的位置是一个跟时间有关的多项式，由以下公式定义：</p><p>$b^n(t) = b^n_0(t) = \sum\limits_{j=0}^n{b_j}B^n_j(t)$</p><p>其中$b_j$代表第j个控制点，$B^n_j(t)$正是伯恩斯坦多项式。</p><p>$B^n_i(t) = \begin{matrix}<br>    n\\<br>    i<br>\end{matrix}t^i(1-t)^{n-i}$</p><p><img src="10.png" alt="贝塞尔曲线"></p><p><strong>总结：n阶贝塞尔曲线是由伯恩斯坦多项式对每个控制点的加权。</strong></p><h2 id="三维空间中的贝塞尔曲线"><a href="#三维空间中的贝塞尔曲线" class="headerlink" title="三维空间中的贝塞尔曲线"></a>三维空间中的贝塞尔曲线</h2><p>假设在三维空间中，我们有4个控制点$b_0 = (0, 2, 3), b_1 = (2, 3, 5), b_2 = (6, 7, 9), b_3 = (3, 4, 5)$</p><p>由这些控制点定义的三维贝塞尔曲线仍然满足以上规则：</p><p>$b^n(t) = b_0(1-t)^3 + b_13t(1-t)^2 + b_23t^2(1-t)+b_3t^3$</p><p>贝塞尔曲线的多项式公式不局限于二维空间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=11&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十四）：插值</title>
      <link href="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/"/>
      <url>/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十四）：插值"><a href="#图形学的数学基础（十四）：插值" class="headerlink" title="图形学的数学基础（十四）：插值"></a>图形学的数学基础（十四）：插值</h1><h2 id="线性插值（-Linear-Interpolation-）"><a href="#线性插值（-Linear-Interpolation-）" class="headerlink" title="线性插值（$Linear\;Interpolation$）"></a>线性插值（$Linear\;Interpolation$）</h2><p>在图形学领域插值是一项广泛应用的技术，多数时候，数据是在规则网格上生成的（值写在 2D 或 3D 网格的顶点位置）或在一条线上（在 1D 情况下），但是程序需要计算任意一点的值。如果采样点刚好落在网格顶点处，那么可以读取数值直接使用，但是如果采样点落在其他地方，考虑到那里并没有存储数值，我们需要基于周围顶点计算数值。这种技术称为插值，因为其关键思想是“插值”，通过固定网格顶点的现有值计算网格上其他任意位置的值。</p><p>在二维中这种技术叫双线性插值，与之对应的三维插值称为三线性插值。“线性插值”是一种类似于以下形式的方程：</p><p>$a(1-t) +bt\;\;\;with\; 0 &lt;=t\;&lt;=\;1$</p><p>其他形式的线性插值都是以此为基础的。</p><p><img src="1.jpg" alt="线性插值"></p><p>插值技术通常用于图像处理（例如上采样/下采样）。 三维空间也可以使用3D或2D网格（纹理可以看作2D网格），例如流体模拟、体积渲染、纹理映射和辐照度缓存等等，无论何时涉及网格，通常也需要插值技术。</p><h2 id="双线性插值（-Bilinear-Interpolation-）"><a href="#双线性插值（-Bilinear-Interpolation-）" class="headerlink" title="双线性插值（$Bilinear\;Interpolation$）"></a>双线性插值（$Bilinear\;Interpolation$）</h2><p>双线性插值是一种用于在二维规则网格中计算任意值的方法。此网格也可以是图像或纹理贴图。思路是取二维平面上周围最近的四个网格顶点作为参照，首先水平方向做两次线性插值，得到两个插值结果，根据这两个值，在垂直方向再做一次线性插值。即可拿到p点的值。</p><p><img src="2.png" alt="线性插值"></p><p>线性插值基本公式：</p><p>$lerp(t, v_0, v_1) = v_0 + t(v_1-v_0)$</p><p>计算x方向两次线性插值，得到a和b：</p><p>$a = C_{00} + s(C_{10} - C_{00})$</p><p>$b = C_{01} + s(C_{01} - C_{11})$</p><p>根据ab的值，再进行一次线性插值，计算p的值：</p><p>$p = a + t(b - a)$</p><p>这也是名称双线性插值的由来，总共做了两轮线性插值，水平方向上一轮，垂直方向上一轮。</p><h2 id="三线性插值（-Bicubic-Interpolation-）"><a href="#三线性插值（-Bicubic-Interpolation-）" class="headerlink" title="三线性插值（$Bicubic\;Interpolation$）"></a>三线性插值（$Bicubic\;Interpolation$）</h2><p>双线性插值采用周围临近4个点作为参照，而三线性插值是采用周围8个点。</p><p>$W(x) = \begin{cases}<br>    (a+2)|x|^3 - (a+3)|x|^2 +1 \;for\;|x| &lt;= 1\\<br>    a|x|^3 - 5a|x|^2 + 8a|x|-4a\;for 1&lt; |x| &lt; 2\\<br>    0\;otherwise<br>\end{cases}$</p><p>其中$a = -0.5$</p><h2 id="三线性插值（-Trilinear-Interpolation-）"><a href="#三线性插值（-Trilinear-Interpolation-）" class="headerlink" title="三线性插值（$Trilinear\; Interpolation$）"></a>三线性插值（$Trilinear\; Interpolation$）</h2><p>三线性插值是双线性插值在三维空间的扩展。可以看作是两个双线性插值的“线性插值”。三线性插值双线性插值具有相同的有点和缺点，首先它非常简单，实现容易，速度也很快。但是它产生的结果不是非常平滑。然后对于体积渲染或流体模拟，需要在三维网格中处理大量插值时，它仍然是一个非常好的选择。</p><p><img src="3.png" alt="线性插值"></p><p>step1:</p><p>$a = C_{010}+t(C_{110} - C_{010})$</p><p>$b = C_{000}+t(C_{100} - C_{000})$</p><p>$c = C_{011}+t(C_{111} - C_{011})$</p><p>$d = C_{001}+t(C_{101} - C_{001})$</p><p>step2:</p><p>$e = b + s(a - b)$</p><p>$f = d + s(c - d)$</p><p>step3:</p><p>$p = e + w(f-e)$</p><h2 id="阶梯函数-Step"><a href="#阶梯函数-Step" class="headerlink" title="阶梯函数($Step$)"></a>阶梯函数($Step$)</h2><p>$step$函数接受两个参数,一个边界值$edge$,一个输入变量$x$,当$x &gt;= edge$时,返回1, 否则返回0。</p><p><img src="12.png" alt="线性插值"></p><p>函数图像如下:</p><p><img src="11.jpg" alt="线性插值"></p><h2 id="平滑阶梯函数-SmoothStep"><a href="#平滑阶梯函数-SmoothStep" class="headerlink" title="平滑阶梯函数($SmoothStep$)"></a>平滑阶梯函数($SmoothStep$)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$smoothStep$函数用来生成0到1的平滑过渡值.先看smoothStep函数实现:</p><p><img src="4.png" alt="线性插值"></p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>通过$smoothStep$函数定义,我们知道:</p><ul><li>$res = 3t^2 - 2t^3$</li><li>$t = \dfrac{(x-a)}{(b-a)}$</li></ul><p>接下来我们一步步通过函数图像来解释$smoothStep$背后的数学原理.</p><p><1> 对于函数$y = x$这个函数,其实就是一条直线:</1></p><p><img src="5.jpg" alt="线性插值"></p><p><2>对于函数$y = x^2$,可以看到它比$y = x$有一个更平滑的过渡:</2></p><p><img src="6.jpg" alt="线性插值"></p><p>但是我们发现$y = x^2$的函数图像仍然是不够“平滑的”，为什么呢？我们知道曲线的切线表示了这条曲线的变化率。通过观察我们明显发现，在0附近的变化率要低于1附近的变化率。</p><p><3> $y = 1 - (x-1)^2$我们在$y = x^2$的基础上构造另外一条曲线.首先先将$下^2$反转.得到:</3></p><p><img src="7.jpg" alt="线性插值"></p><p>将$y = -x^2$向右移动一个单位得到:</p><p><img src="8.jpg" alt="线性插值"></p><p>然后再向上移动一个单位得到以下函数图像:</p><p><img src="9.jpg" alt="线性插值"></p><p>此时$y = 1- (x-1)^2$</p><p>可以看到我们构造的第二条曲线在接近1的部分开始变缓,和$y = x^2$从0开始变缓一样.因此我们将这两条曲线混合到一起即可以得到理想情况下的“平滑过渡”：</p><p>利用线性插值混合两条曲线：</p><p>$y = xf(x) + (1-x)g(x) = x(1-(x-1)^2) + (1-x)x^2 = 3x^2 - 2x^3$</p><p>最终形成的函数图像如下:</p><p><img src="10.jpg" alt="线性插值"></p><h2 id="函数图像"><a href="#函数图像" class="headerlink" title="函数图像"></a>函数图像</h2><p><img src="13.png" alt="线性插值"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation">Scratchapixel</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://zhuanlan.zhihu.com/p/424589478">SmoothStep函数/节点到底做了什么？</a></p><p><a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">bilinear Interpolation</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十三）：立体角</title>
      <link href="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
      <url>/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十三）：立体角"><a href="#图形学的数学基础（十三）：立体角" class="headerlink" title="图形学的数学基础（十三）：立体角"></a>图形学的数学基础（十三）：立体角</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>立体角，常用字母$\Omega$表示，是一个物体对特定点在三维空间中的角度表示，是平面角在三维空间中的扩展。因此，立体角是单位球面上的一块面积，这和“平面角是单位圆上的一段弧长”类似。</p><h2 id="平面角"><a href="#平面角" class="headerlink" title="平面角"></a>平面角</h2><p>平面角等于张角对应圆上的弧长除以圆的半径，即：</p><p><img src="1.png" alt="平面角"></p><p>$\theta = \dfrac{l}{r}$</p><p>而圆的周长等于$2\pi{r}$,因此完整圆<br>对应的角度为：</p><p>$\dfrac{2\pi{r}}{r} = 2\pi\;\;radians$</p><h2 id="立体角（-Solid-angle-）"><a href="#立体角（-Solid-angle-）" class="headerlink" title="立体角（$Solid\;angle$）"></a>立体角（$Solid\;angle$）</h2><p>平面角在三维空间的延申。在三维空间中某一个球体，从球心出发，形成具有一定大小的锥体，锥体会打到球面上，形成一定的面积。而立体角就是锥体形成的面积$A$除以球体半径的平方。</p><p>$\omega = \dfrac{A}{r^2}$</p><p>球体的表面积等于$4\pi{r^2}$</p><p>因此完整球体的立体角为$4\pi\;\;steradians$</p><p><img src="2.jpg" alt="平面角"></p><h3 id="微分立体角（-Differential-Solid-angles-）"><a href="#微分立体角（-Differential-Solid-angles-）" class="headerlink" title="微分立体角（$Differential\;Solid\;angles$）"></a>微分立体角（$Differential\;Solid\;angles$）</h3><p>由立体角的定义可知，三维空间中的某一立体角等于锥体在球面形成的面积处于半径的平方。因此微分立体角等于球体上极小面积处于半径平方，而极小面积是由球体上某一点在$\theta和\phi$两个方向上的微小移动形成的。</p><p>$d\phi$是立体角$d\omega$在底面上展开的微小平面夹角范围，$d\theta$是$d\omega$与垂直方向的微小平面夹角范围。极小面积如下图所示：</p><p><img src="3.png" alt="平面角"></p><p>极小面积可以近似看作矩形，因此极小面积近似等于$AB\times{BC}$如下图：</p><p><img src="4.jpg" alt="平面角"></p><p>$d\omega = \dfrac{dA}{r^2}$</p><p>$OBC$可以看作二维扇面，根据平面角的定义：</p><p>$d\theta = \dfrac{BC}{r}$</p><p>$BC = d\theta{r}$</p><p>BD垂直于n轴，OBD形成直角三角形，根据正弦定理：</p><p>$BD = r\sin\theta$</p><p>DAB形成二维扇面：</p><p>$d\phi = \dfrac{AB}{DB} = \dfrac{AB}{r\sin\theta}$</p><p>$AB = r\sin\theta{d}\phi$</p><p>$dA = AB\times{BC} = r\sin\theta{d}\phi\times {d\theta{r}} = \sin\theta{d}\theta{d}\phi{r^2}$</p><p>$d\omega = \dfrac{dA}{r^2} = \dfrac{\sin\theta{d}\theta{d}\phi{r^2}}{r^2} = \sin\theta{d}\theta{d}\phi$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.youtube.com/watch?v=VmnkkWLwVsc">Understanding the concept of Solid Angle</a></p><p><a href="https://zhuanlan.zhihu.com/p/450731138">立体角 （Solid Angle）</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AB%8B%E9%AB%94%E8%A7%92">立体角wiki （Solid Angle）</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十二）：几何图元-包围盒</title>
      <link href="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
      <url>/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十二）：几何图元-包围盒-Bounding-Box"><a href="#图形学的数学基础（十二）：几何图元-包围盒-Bounding-Box" class="headerlink" title="图形学的数学基础（十二）：几何图元-包围盒($Bounding Box$)"></a>图形学的数学基础（十二）：几何图元-包围盒($Bounding Box$)</h1><p>包围盒是一种求解离散点集最优包围空间的算法,基本思想是用体积稍大且特性简单的几何形状来近似代替复杂的几何对象。包围盒常用于几何物体的碰撞检测，ray-tracing中光线求交等。常用的包围盒有两种，$AABB与OBB$，AABB包围盒是轴对齐的，而$OBB$是有向的。</p><h2 id="AABB"><a href="#AABB" class="headerlink" title="$AABB$"></a>$AABB$</h2><p>$AABB$是$Axially\;Aligned\;Bounding\;Box$的缩写，三维$AABB$是一个简单的6面盒子，每一面都与一个基向量形成的面平行，这个盒子不一定是立方体，盒子的长度宽度高度可以各自不同。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>几何体$AABB$包围盒内的点满足以下不等式：</p><p>$x_{min} &lt;= x &lt;= x_{max}$</p><p>$y_{min} &lt;= y &lt;= y_{max}$</p><p>$z_{min} &lt;= z &lt;= z_{max}$</p><p>两个具有特殊意义的点：</p><ul><li><p>最小值：$\textbf{P}_{min} = [x_{min}, y_{min}, z_{min}]$</p></li><li><p>最大值：$\textbf{P}_{max} = [x_{max}, y_{max}, z_{max}]$</p></li></ul><p>中心点可以通过最小值和最大值的中点计算得出：</p><p>$\textbf{c} = \dfrac{(\textbf{P}_{min} + \textbf{P}_{max})}{2}$</p><p>大小向量($Size\;Vector$)$s$是从$\textbf{P}_{min}$到$\textbf{P}_{max}$的向量，该向量的三个分量分别代表了包围盒的长宽高信息。</p><h3 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h3><p>一般情况下会使用$\textbf{P}_{min}$和$\textbf{P}_{max}$表示包围盒。</p><p><img src="1.png" alt="AABB"></p><h3 id="计算-AABB"><a href="#计算-AABB" class="headerlink" title="计算$AABB$"></a>计算$AABB$</h3><p>针对一组点计算$AABB$是一个很简单的过程，首先初始化min和max两个值，初始值分别设置为最大值和最小值，遍历点位集合，分别比较判断$min,max$的三个分量，将当前最小值赋给$min$最大值赋给$max$。</p><p><img src="2.png" alt="AABB"></p><h3 id="变换-AABB"><a href="#变换-AABB" class="headerlink" title="变换$AABB$"></a>变换$AABB$</h3><p>有时候我们需要将$AABB$从一个坐标空间转换为另一个坐标空间。假如已知对象空间的$AABB$,现在期望获取世界空间的$AABB$,其中一种做法就是，可以基于变换后的几何体顶点，重新计算包围盒，但是针对复杂的几何体，顶点数量特别多，这种计算开销太大，因此在世界空间中获得$AABB$，就需要考虑变换对象空间的$AABB$。<br>要为变换后的对象计算$AABB$，仅变换$\textbf{P}_{min}和\textbf{P}_{max}$是不够的，这可能导致假的包围盒，<br>在经过变换后，通常导致包围盒大于原始包围盒。而通过变换后的对象重新计算$AABB$将与原始的$AABB$大致相同。</p><p><img src="3.png" alt="AABB"></p><h4 id="矩阵变换-AABB"><a href="#矩阵变换-AABB" class="headerlink" title="矩阵变换$AABB$"></a>矩阵变换$AABB$</h4><p>当我们对空间中一个点做变换时，可以采用矩阵形式：</p><p>$\begin{bmatrix}<br>x^丶\\ y^丶\\ z^丶\\<br>\end{bmatrix} = \begin{bmatrix}<br>m_{11}&amp;m_{12}&amp;m_{13}\\<br>m_{21}&amp;m_{22}&amp;m_{23}\\<br>m_{31}&amp;m_{32}&amp;m_{33}\\<br>\end{bmatrix}\begin{bmatrix}<br>x\\ y\\ z\\<br>\end{bmatrix}$</p><p>$x^丶 = m_{11}x + m{12}y+m_{13}z$</p><p>$y^丶 = m_{21}x + m{22}y+m_{23}z$</p><p>$z^丶 = m_{31}x + m{32}y+m_{33}z$</p><p>假设$x,y,z$是原始八个顶点中的任何一个，我们的工作是找出变换后哪些顶点具有最小的$x$值。最小化整个总和的技巧是单独最小化3个乘积的每一个。我们来看第一个乘积$m_{11}x$，我们必须决定用$x_{min}或x_{max}$中的哪一个来代替$x$以便最小化乘积。显然如果$m_{11} &gt; 0$,则二者中较小的$x_{min}$将导致较小的乘积。</p><p><img src="4.png" alt="AABB"></p><h3 id="光线与-AABB-求交"><a href="#光线与-AABB-求交" class="headerlink" title="光线与$AABB$求交"></a>光线与$AABB$求交</h3><p>包围盒常用来做物体的碰撞监测，光线的相交测试等。尤其在光线追踪中，包围盒常用来做光线与物体相交测试。基本思想是这样的，我们将包围盒的长方体看做是三对互相平行的平面相交所形成的区域。尤其对于$AABB$，每一对平行面都是与一个轴对齐的。根据这个特性，先以二维空间举例：</p><p><img src="5.jpg" alt="AABB"></p><p>$AABB$由两对平面构成，分别是平行于$x轴和y轴$。根据光线公式可知：</p><p>$Ray = \textbf{o} + \textbf{d}t$</p><p>其中$o$为光线起点，$d$为光线方向，Ray是光线经过t时间到达的位置。 </p><p>如何判定光线是否与包围盒相交呢？我们可以通过分解，将问题简化，将光线分别穿过每对无限延申的平面，分别求出其$T_{min}和T_{max}$：</p><p>与$x$轴垂直的一对平面的交点：</p><p><img src="6.png" alt="AABB"></p><p>$T_{xmin}d_x + o_x = x_0$</p><p>=&gt;</p><p>$T_{xmin} = \dfrac{x_0 - o_x}{d_x}$</p><p>$T_{xmax}d_x + o_x = x_1$</p><p>=&gt; </p><p>$t_{xmax} = \dfrac{x_1 - o_x}{d_x}$</p><p>与$y$轴垂直的一对平面的交点：</p><p><img src="7.png" alt="AABB"></p><p>$T_{ymin}d_y + o_y = y_0$</p><p>=&gt;</p><p>$T_{ymin} = \dfrac{y_0 - o_y}{d_y}$</p><p>$T_{ymax}d_y + o_y = y_1$</p><p>=&gt; </p><p>$t_{ymax} = \dfrac{y_1 - o_y}{d_y}$</p><p>现在我们想象空间中的一条光线，只有当光线进入了所有的“平面对”，才算进入了盒子，光线只要离开了任何“平面对”，就算离开了盒子，因此光线进入盒子的时间实际上是进入所有“平面对”的最大值，即<strong>最小时间的最大值</strong>，而离开盒子的时间是光线离开“平面对”的最小值，即<strong>最大时间的最小值</strong>。（求交）</p><p><img src="8.jpg" alt="AABB"></p><p>考虑三维情况下光线与$AABB$求交。关键点：</p><ul><li>当且仅当光线进入了所有“平面对”，光线进入盒子。</li><li>只要光线离开了一组“平面对”，光线就离开了盒子。</li></ul><p>对于三维空间，我们有三组“平面对”，分别计算$t_{min}和t_{max}$，因此有：</p><p>$t_{enter} = max(t_{minx}, t_{miny}, t_{minz})$</p><p>$t_{exit} = min(t_{maxx}, t_{maxy}, t_{maxz})$</p><p>当且仅当$t_{enter} &lt; t_{exit}$时，我们认为“光线在盒子里停留了一段时间”，即光线与盒子相交。</p><p>但是以上推断没有考虑t为负值的情况，当$t_{exit} &lt; 0$时，盒子在光线背面，必然不会出现交点（光线是单向的），当 $t_{exit} &gt;= 0 并且t_{enter} &lt; 0时$，光线起点在盒子里边，那么光线必然与盒子相交。因此得出结论：</p><p>光线$Ray$与$AABB$相交，当且仅当：</p><p>$t_{enter} &lt; t_{exit}$<br>$t_{exit} \;\;&gt;= 0$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十一）：几何图元-重心坐标</title>
      <link href="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
      <url>/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十一）：几何图元-重心坐标"><a href="#图形学的数学基础（十一）：几何图元-重心坐标" class="headerlink" title="图形学的数学基础（十一）：几何图元-重心坐标"></a>图形学的数学基础（十一）：几何图元-重心坐标</h1><p><img src="1.jpg" alt="重心坐标"></p><h2 id="定义重心坐标-Barycentric-Coordinates"><a href="#定义重心坐标-Barycentric-Coordinates" class="headerlink" title="定义重心坐标($Barycentric\;Coordinates$)"></a>定义重心坐标($Barycentric\;Coordinates$)</h2><p>对于空间内的三角形$\triangle{v_1v_2v_3}$和任意一点$\textbf{p}$，必定唯一存在三个数$b_1,b_2,b_3$,满足：</p><p>$b_1+b_2+b_3 = 1$</p><p>$\textbf{p} = b_1\textbf{v}_1 + b_2\textbf{v}_2+ b_3\textbf{v}_3$</p><p>则$b_1,b_2,b_3$就称为$\textbf{p}$点在此三角形$\triangle{v_1v_2v_3}$上的重心坐标.</p><p>重心坐标表示了三角形每个顶点对该点的权重（贡献），重心坐标可以用来三角形光栅化顶点的属性插值，比如说uv 颜色 法线的线性插值。</p><p>重心坐标也是一种坐标系统，类似于普通笛卡尔坐标系，但有一个区别就是，重心坐标的三个分量之和为1：</p><p>$b_1 + b_2 + b_3 = 1$</p><p><strong>这种归一化的约束消除了一个自由度，因此即使有三个坐标，它仍然是一个二维空间。</strong></p><p>重心坐标不仅适用于三角形内的点，对于边上的点甚至三角形外的点都是适用的，三角形内的重心坐标都是被限制到[0,1]范围内，三角形外的任何点都至少有一个负坐标。</p><p>还有一种解释重心坐标的角度，丢弃$b_3$,将$(b_1,b_2)$解释为常规的二维坐标，原点位于$\textbf{v}_3$,x轴是$\textbf{v}_1-\textbf{v}_3$,y轴是$\textbf{v}_2-\textbf{v}_3$</p><p><img src="2.jpg" alt="重心坐标的几何意义"></p><p>$(b_1,b_2,b_3)\\=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + b_3\textbf{v}_3\\<br>=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + (1-b_1-b_2)\textbf{v}_3\\<br>=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + \textbf{v}_3 - b_1\textbf{v}_3-b_2\textbf{v}_3\\<br>=&gt; \textbf{v}_3 + b_1(\textbf{v}_1 -\textbf{v}_3) + b_2(\textbf{v}_2 - \textbf{v}_3)<br>$</p><h2 id="计算重心坐标"><a href="#计算重心坐标" class="headerlink" title="计算重心坐标"></a>计算重心坐标</h2><p><img src="3.png" alt="重心坐标"></p><p>已知p的坐标和$v_1,v_2,v_3$的顶点坐标，求p的重心坐标$(b_1,b_2,b_3)$,只需要求解线性方程组即可：</p><p>$\begin{cases}<br>    b_1x_1 +b_2x_2 + b_3x_3 = p_x\\<br>    b_1y_1 +b_2y_2 + b_3y_3 = p_x\\<br>    b_1+b_2+b_3 = 1<br>\end{cases}$</p><p>求解该方程组得到：</p><p>$b_1 = \dfrac{(p_y-y_3)(x_2-x_3)+(y_2-y_3)(x_3-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>$b_1 = \dfrac{(p_y-y_1)(x_3-x_1)+(y_3-y_1)(x_1-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>$b_1 = \dfrac{(p_y-y_2)(x_1-x_2)+(y_1-y_2)(x_2-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>可以看到每个表达式中的分母是相同的，根据三角形的面积公式可得：</p><p>$A = \dfrac{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}{2}$</p><p>它等于三角形面积的两倍，而且对于每个重心坐标$b_i$来说，其分子等于“子三角形”$T_i$的面积的两倍：</p><p>$b_1 = \dfrac{A(T_1)}{A(T)}, b_2 = \dfrac{A(T_2)}{A(T)}, b_3 = \dfrac{A(T_3)}{A(T)}$</p><p>因此得出结论：<strong>重心坐标等于对面子三角形与大三角形的比例。</strong></p><p>所以计算重心坐标可先叉乘计算面积，再求面积比。另外因为公用底边三角形面积比等于高(有向高)的比，因此：</p><p><img src="4.png" alt="重心坐标"></p><p>$\begin{cases}<br>    b_1 = \dfrac{h_1}{H_1}\\<br>    b_2 = \dfrac{h_2}{H_2}\\<br>    b_3 = \dfrac{h_3}{H_3}\\<br>\end{cases}$</p><h2 id="重心-内心-外心"><a href="#重心-内心-外心" class="headerlink" title="重心 内心 外心"></a>重心 内心 外心</h2><h3 id="重心（-Center-of-Gravity-）"><a href="#重心（-Center-of-Gravity-）" class="headerlink" title="重心（$Center of Gravity$）"></a>重心（$Center of Gravity$）</h3><p>重心，也称为质心($Centroid$)，是三角形完美平衡的点。它是中线的交点（中线是从一个顶点到对边中点的直线）。如下图：</p><p><img src="5.png" alt="重心坐标"></p><p>重心是三个顶点的几何平均值：</p><p>$C_{gravity} = \dfrac{\textbf{v}_1 + \textbf{v}_2 + \textbf{v}_3}{3}$</p><p>重心的重心坐标为：$(\dfrac{1}{3},\dfrac{1}{3},\dfrac{1}{3})$</p><h3 id="内心（-Incenter-）"><a href="#内心（-Incenter-）" class="headerlink" title="内心（$Incenter$）"></a>内心（$Incenter$）</h3><p>内心是三角形三条角平分线的交点。它也是三角形内切圆的圆心。由此可知，内心与三角形各条边的距离是相等的：</p><p><img src="6.jpg" alt="内心"></p><p>假设$P = l_1 + l_2 + l_3$为三角形的周长,$l_1,l_2,l_3为每条边长$，则内心的重心坐标可是表示为边长与周长比：</p><p>$(\dfrac{l_1}{p},\dfrac{l_2}{p},\dfrac{l_3}{p})$</p><p>内心的坐标：</p><p>$C_{Incenter} = \dfrac{l_1\textbf{v}_1 + l_2\textbf{v}_2+ l_3\textbf{v}_3}{p}$</p><p>内切圆半径为三角形面积除以三角形周长：</p><p>$r_{Incenter} = \dfrac{A}{p}$</p><h3 id="外心（-Circumcenter-）"><a href="#外心（-Circumcenter-）" class="headerlink" title="外心（$Circumcenter$）"></a>外心（$Circumcenter$）</h3><p>外心是三角形中与顶点等距的点。它是围绕三角形的外接圆的圆心。外心构造为各条边的垂直平分线的交点。</p><p><img src="7.jpg" alt="内心"></p><h4 id="外心的计算"><a href="#外心的计算" class="headerlink" title="外心的计算"></a>外心的计算</h4><p>$d_1 = -\vec{e_2}\cdot\vec{e_3}$</p><p>$d_2 = -\vec{e_3}\cdot\vec{e_1}$</p><p>$d_3 = -\vec{e_1}\cdot\vec{e_2}$</p><p>$c_1 = d_2d_3$</p><p>$c_2 = d_3d_1$</p><p>$c_3 = d_1d_2$</p><p>$c = c_1 + c_2 + c_3$</p><p>外心重心坐标：$(\dfrac{c_2+c_3}{2c},\dfrac{c_3+c_1}{2c},\dfrac{c_1+c_2}{2c})$</p><p>外心坐标：$C_Circumcenter = \dfrac{(c_2+c_3)\textbf{v}_1+(c_3+c_1)\textbf{v}_2+(c_1+c_2)\textbf{v}_3}{2c}$</p><p>外接圆半径：$r_Circumcenter = \dfrac{\sqrt{(d_1+d_2)(d_2+d_3)(d_3+d_1)}}{2}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十）：几何图元-三角形</title>
      <link href="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十）：几何图元-三角形"><a href="#图形学的数学基础（十）：几何图元-三角形" class="headerlink" title="图形学的数学基础（十）：几何图元-三角形"></a>图形学的数学基础（十）：几何图元-三角形</h1><p>三角形在图形学中具有重要意义。复杂三维对象的表面都是由庞大三角形网格组成（$Triangle\;Mesh$），本章将介绍三角形基本属性，重点是重心坐标。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个三角形，只需要三个顶点即可，这些点的顺序至关重要，因为它们的顺序决定了三角面的正反，在右手系中，当从三角形正面看时，通常按逆时针方向枚举点（右手螺旋定则）。</p><p><img src="1.jpg" alt="三角形定义"></p><p>边向量，边长 顶点定义如下：</p><p>$\vec{e_1} = \textbf{v}_3 - \textbf{v}_2$</p><p>$\vec{e_2} = \textbf{v}_1 - \textbf{v}_3$</p><p>$\vec{e_3} = \textbf{v}_2 - \textbf{v}_1$</p><p>$l_1 = ||\vec{e_1}||$</p><p>$l_2 = ||\vec{e_2}||$</p><p>$l_3 = ||\vec{e_3}||$</p><h2 id="三角形常用公式"><a href="#三角形常用公式" class="headerlink" title="三角形常用公式"></a>三角形常用公式</h2><ul><li><p>正弦定理：$\dfrac{\sin\theta_1}{l_1} = \dfrac{\sin\theta_2}{l_2} = \dfrac{\sin\theta_3}{l_3}$</p></li><li><p>余弦定理：$\begin{cases}<br>  {l_1}^2 = {l_2}^2 + {l_3}^2-2l_2l_3\cos\theta_1\\<br>  {l_2}^2 = {l_1}^2 + {l_3}^2-2l_1l_3\cos\theta_2\\<br>  {l_3}^2 = {l_1}^2 + {l_2}^2-2l_1l_2\cos\theta_3\\<br>\end{cases}$</p></li><li><p>三角形周长：$p = l_1+l_2+l_3$</p></li></ul><h2 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h2><h3 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h3><p><img src="2.png" alt="三角形定义"></p><p>由上图可知，平行四边形的面积等于底乘高，而三角形占据了平行四边形面积的一半，因此三角形面积为：</p><p>$\textbf{A} = \dfrac{base.h}{2}$</p><h3 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h3><p>求解三角形面积的第二种方式是海伦公式。</p><p>$s = \dfrac{l_1+l_2+l_3}{2} = \dfrac{p}{2}$</p><p>$\textbf{A} = \sqrt{s(s-l_1)(s-l_2)(s-l_3)}$</p><h3 id="顶点坐标"><a href="#顶点坐标" class="headerlink" title="顶点坐标"></a>顶点坐标</h3><p>一般来说,边的高度或长度不太好计算,因为所有的已知条件都是顶点的笛卡尔坐标(当然我们总是可以通过坐标计算边长,但在有些情况下我们尽量避免这种相对昂贵的计算).接下来将介绍通过顶点坐标计算三角形面积的方法。</p><p>基本思想就是为三角形的每条边计算梯形的有符号面积，该面积由边和下方的x轴所界定。</p><p><img src="3.jpg" alt="边向量面积"></p><p>根据梯形面积公式：</p><p>$\textbf{A} = \dfrac{(上底 + 下底).高}{2}$</p><p>则三角形三条边的面积公式分别为：</p><p>$\textbf{A}(e_1) = \dfrac{(y_2+y_3)(x_2-x_3)}{2}$</p><p>$\textbf{A}(e_2) = \dfrac{(y_3+y_1)(x_3-x_1)}{2}$</p><p>$\textbf{A}(e_3) = \dfrac{(y_2+y_1)(x_2-x_1)}{2}$</p><p><strong>可以通过对三个梯形的有符号面积求和，获得三角形本身的面积。实际上可以用这个思路求解任意多边形面积。</strong></p><p>$\textbf{A} = \textbf{A}(e_1) + \textbf{A}(e_2) + \textbf{A}(e_3)\\<br>    =\dfrac{(y_2+y_3)(x_2-x_3) + (y_3+y_1)(x_3-x_1) + (y_2+y_1)(x_2-x_1)}{2}\\<br>    =\dfrac{y_1(x_3-x_2) + y_2(x_1-x_3) + y_3(x_1-x_2)}{2}<br>$</p><p>平移三角形不会改变三角形面积，因此我们可以将每个$y$坐标减去$y_3$,进一步做简化：</p><p>$\textbf{A} = \dfrac{(y_1-y_3)(x_3-x_2) + (y_2-y_3)(x_1-x_3) + (y_3-y_3)(x_1-x_2)}{2}\\<br>        \ \ \ \ =\dfrac{(y_1-y_3)(x_3-x_2) + (y_2-y_3)(x_1-x_3)}{2}\\<br>$</p><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>三维中可以使用叉积计算三角形的面积，根据叉积的定义，两个向量的叉积的大小等于通过向量两条边形成的平行四边形的面积。由于三角形的面积是平行四边形面积的一半，因此：</p><p>$\textbf{A} = \dfrac{||\vec{e_1}\times\vec{e_2}||}{2}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（九）：几何图元-球体圆形和平面</title>
      <link href="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/"/>
      <url>/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（九）：几何图元-球体圆形和平面"><a href="#图形学的数学基础（九）：几何图元-球体圆形和平面" class="headerlink" title="图形学的数学基础（九）：几何图元-球体圆形和平面"></a>图形学的数学基础（九）：几何图元-球体圆形和平面</h1><pre><code>转载请注明出处</code></pre><h2 id="球体和圆形"><a href="#球体和圆形" class="headerlink" title="球体和圆形"></a>球体和圆形</h2><p>球体是一个三维对象，定义与给定点具有固定距离的所有点的集合。从球体中心到点的距离称为球体半径（$Radius$），球体的直接表示方式是描述其中心$\textbf{c}$和半径$r$。</p><h3 id="球体的隐式表述"><a href="#球体的隐式表述" class="headerlink" title="球体的隐式表述"></a>球体的隐式表述</h3><p>$||\textbf{p} - \textbf{c}|| = r$</p><p>$(x-x_c)^2 + (y-y_c)^2 + (z-z_c)^2 = r^2$</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><ul><li>直径 $D = 2r$</li><li>圆周长 $C = 2\pi{r}$</li><li>圆面积 $A = \pi{r^2}$</li><li>球体表面积 $S = 4\pi{r^2}$</li><li>球体体积 $S = \dfrac{4}{3}\pi{r^3}$</li></ul><p><strong>圆面积对r的导数是圆周长，球体的体积对r的导数是其表面积。</strong></p><h2 id="三维平面-Plane"><a href="#三维平面-Plane" class="headerlink" title="三维平面($Plane$)"></a>三维平面($Plane$)</h2><p>平面是三维空间中扁平的二维子空间。平面的定义类似于二维中直线的定义。定义中的种种相似性暗示了三维中的平面与二维中的无限直线有许多共同属性的事实。</p><h3 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h3><p>三维空间的平面方程是由一个法线$\vec{n}$($normal\;vector$)和平面上的一个点$p_1$来定义的。</p><p><img src="1.jpg" alt="平面定义"></p><p>由于$\hat{n}$与平面垂直，所以从平面上任意一点$\textbf{P}$到$\textbf{P}_1$所形成的向量$\vec{P} - \vec{P_1}$必然与$\hat{n}$垂直。</p><p>$\vec{P} - \vec{P_1} = (x-x_1,y-y_1,z-z_1)$</p><p>$\hat{n}\cdot(\vec{P} - \vec{P_1}) = 0$</p><p>$\begin{bmatrix}<br>    a\\ b\\ c\\<br>\end{bmatrix}\cdot\begin{bmatrix}x-x_1\\ y-y_1\\ z-z_1\\ \end{bmatrix} = 0$</p><p>$a(x-x_1) + b(y-y_1) + c(z-z_1) = 0$</p><p>$ax + by + cz -(ax_1 + by_1 + cz_1) = 0$</p><p>假设常量项$-(ax_1 + by_1 + cz_1) = d$,则：</p><p>$ax+by+cz+d = 0$</p><h4 id="平面方程的几何解释"><a href="#平面方程的几何解释" class="headerlink" title="平面方程的几何解释"></a>平面方程的几何解释</h4><p>$\textbf{p}\cdot\hat{n} = d$</p><p>由向量点积的几何意义可知，上式说明了向量$\vec{p}$到$\hat{n}$的投影长度都为固定长度d。</p><p>向量$\vec{n}$称为平面法线（$Normal$），因为它与平面垂直，法线决定了平面的方向性，d则定义了从原点到平面的有符号垂直距离（跟直线的定义很相似，只不过拓展到了三维空间），增加d将使平面朝法线方向滑动，如果 d &gt; 0，则原点位于平面的背面，如果d &lt; 0则原点位于正面。</p><p>通常认为平面具有正面和背面，平面的正面就是$\hat{n}$所指的方向。</p><p><img src="2.jpg" alt="平面定义"></p><h3 id="三个点定义平面"><a href="#三个点定义平面" class="headerlink" title="三个点定义平面"></a>三个点定义平面</h3><p>定义平面的另一种方式是给出位于平面的三个非共线点。三个共线的点无法定义平面，因为会有无数个包含该直线的平面，并且无法确定我们指的是其中哪一个。</p><p>假设三个非共线点$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$,要确定一个平面，必须求出$\hat{n}和d$，首先计算$\hat{n}$，$\hat{n}$会朝哪个方向呢？在左手系中执行此操作的标准方法是假设从平面的正面观察时，$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$按顺时针方向列出（右手系为逆时针方向）：</p><p><img src="3.jpg" alt="三点定义平面"></p><p>注：<strong>按照右手系方式定义</strong></p><p>按照逆时针方向构造两个向量$\vec{e_1}和\vec{e_2}$,$\hat{n}$与$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$构造的平面垂直，那么必然也与$\vec{e_1}和\vec{e_2}$垂直。因此自然可以想到向量叉积.</p><p>$\vec{e_3} = \textbf{p}_2 - \textbf{p}_1$</p><p>$\vec{e_1} = \textbf{p}_3 - \textbf{p}_2$</p><p>$\hat{n} = \dfrac{\vec{e_3}\times\vec{e_1}}{||\vec{e_3}\times\vec{e_1}||}$</p><p> 计算出了$\hat{n}$，剩下的就是计算$d$，取$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$中任意一点，和$\hat{n}$做点积即可。</p><p> 完整计算过程如下：</p><p>$\vec{e_3} = \textbf{p}_2 - \textbf{p}_1$</p><p>$\vec{e_1} = \textbf{p}_3 - \textbf{p}_2$</p><p>$\hat{n} = \dfrac{\vec{e_3}\times\vec{e_1}}{||\vec{e_3}\times\vec{e_1}||}$</p><p>$d = \vec{p_1}\cdot\hat{n} = \vec{p_1}\dfrac{(\textbf{p}_2 - \textbf{p}_1)\times(\textbf{p}_3 - \textbf{p}_1)}{||(\textbf{p}_2 - \textbf{p}_1)\times(\textbf{p}_3 - \textbf{p}_1)||}$</p><h2 id="平面距原点的最短（垂直）距离"><a href="#平面距原点的最短（垂直）距离" class="headerlink" title="平面距原点的最短（垂直）距离"></a>平面距原点的最短（垂直）距离</h2><p>如果平面的法线是单位向量,则平面方程的常数项$d$是原点到平面的有符号距离。</p><p><img src="4.jpg" alt="原点距平面距离"></p><p>假设单位向量$\hat{n}$ = $\begin{bmatrix}a\\ b\\ c\\ \end{bmatrix}$,则平面上的一点$\textbf{P}_1$可以写成$\begin{bmatrix}Da\\ Db\\ Dc\end{bmatrix}$的形式，D是从原点到平面的垂直有符号距离。因此我们可以将平面方程重写如下：</p><p>$\begin{bmatrix}a\\ b\\ c\\\end{bmatrix}\cdot\begin{bmatrix}x-Da\\ y-Db\\ z-Dc\\\end{bmatrix} = 0$</p><p>$a(x-Da) + b(y-Db) + c(z-Dc) = 0$</p><p>$ax + by + cz -D(a^2 + b^2 + c^2) = 0$</p><p>$ax + by + cz -D||\vec{n}|| = 0$</p><p>因此原点到平面的垂直有符号距离 $D = \dfrac{d}{||\vec{n}||}$,其中$\textbf{d}$为平面方程的常数项。</p><h2 id="任意点到平面的最短（垂直）距离"><a href="#任意点到平面的最短（垂直）距离" class="headerlink" title="任意点到平面的最短（垂直）距离"></a>任意点到平面的最短（垂直）距离</h2><p>很多时候我们可能会有一个平面和一个不在平面内的点$\textbf{q}$，然后想要计算从该平面到$\textbf{q}$的距离。如果该距离为负数，则$\textbf{q}$在平面的背面，反之在正面。为此我们假设平面中的一个点$\textbf{p}$，它是该平面中与$\textbf{q}$最近的点，显然从$\textbf{p}到\textbf{q}$的向量垂直于平面，因此它是$a\vec{n}$的另外一种形式。</p><p>对于平面$ax + by + cz+d = 0$，任意一点$\textbf{q}$到平面的最短距离推导如下：</p><p>$\textbf{p} + a\vec{n} = \textbf{q}$</p><p>$(\textbf{p} + a\vec{n})\cdot\vec{n} = \textbf{q}\cdot\vec{n}$</p><p>$\textbf{p}\cdot\vec{n} + a\vec{n}\cdot\vec{n} = \textbf{q}\cdot\vec{n}$</p><p>$d||\vec{n}|| + a||\vec{n}||^2 = \textbf{q}\cdot\vec{n}$</p><p>$d||\vec{n}|| + a||\vec{n}||^2 = \textbf{q}\cdot\hat{n}||\vec{n}||$</p><p>$d + a||\vec{n}|| = \textbf{q}\cdot\hat{n}$</p><p>$a = \dfrac{\textbf{q}\cdot\hat{n} - d}{||\vec{n}||}$</p><p>对于单位向量则有：</p><p>$a = \textbf{q}\cdot\hat{n} - d$</p><h2 id="求解三平面的交点"><a href="#求解三平面的交点" class="headerlink" title="求解三平面的交点"></a>求解三平面的交点</h2><p>求解三平面相交交点，我们只需要解三个平面方程组成的线性方程组即可：</p><p>$\begin{cases}<br>    a_1x+b_1y+c_1z + d_1 = 0\\<br>    a_2x+b_2y+c_2z + d_2 = 0\\<br>    a_3x+b_3y+c_3z + d_3 = 0\\<br>\end{cases}$<br>可以写成矩阵的形式：</p><p>$\begin{bmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{bmatrix}\begin{bmatrix}<br>    x\\ y\\ z\\<br>\end{bmatrix} = \begin{bmatrix}<br>    -d_1\\<br>    -d_2\\<br>    -d_3\\<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>    x\\ y\\ z\\<br>\end{bmatrix} = \begin{bmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{bmatrix}^{-1}\begin{bmatrix}<br>    -d_1\\<br>    -d_2\\<br>    -d_3\\<br>\end{bmatrix}$</p><h2 id="平面直线相交"><a href="#平面直线相交" class="headerlink" title="平面直线相交"></a>平面直线相交</h2><p>空间中的平面和直线可能会相较于某一点，交点可以通过平面和直线的线性方程组求解：</p><p>$\begin{cases}<br>    \textbf{Plane}, &amp; ax+by+cz+d = 0\\<br>    \textbf{Line}, &amp; \textbf{p}_1 + t\vec{v} = (x_1+tv_x,y_1+tv_y,z_1+tv_z)<br>\end{cases}$</p><p>$t = \dfrac{-(ax_1+by_1+cz_1+d)}{av_x+bv_y+cv_z}=\dfrac{-(\vec{n}\cdot\textbf{p}_1+d)}{\vec{n}\cdot\vec{v}}$</p><h3 id="克莱默法则（-Cramer’s-Rule-）"><a href="#克莱默法则（-Cramer’s-Rule-）" class="headerlink" title="克莱默法则（$Cramer’s\;Rule$）"></a>克莱默法则（$Cramer’s\;Rule$）</h3><p>克莱默法则，用于求解具有n个线性方程的方程组。</p><p>$\begin{cases}<br>   a_{11}x_1+a_{12}x_2 +…+ a_{1n}x_n = b_1\\<br>   a_{21}x_1+a_{22}x_2 +…+ a_{2n}x_n = b_2\\<br>   …………………………………..\\<br>   a_{n1}x_1+a_{n2}x_2 +…+ a_{nn}x_n = b_n<br>\end{cases}$</p><p>若线性方程组的系数行列式不等于0，即$\det{A} =\begin{vmatrix}<br>    a_{11}…a_{1n}\\<br>    …………\\<br>    a_{n1}…a_{nn}\\<br>\end{vmatrix} != 0$</p><p>则线性方程组的解可以用行列式来表示：</p><p>$x_1 = \dfrac{\det{A_1}}{\det{A}}, x_2 = \dfrac{\det{A_2}}{\det{A}}, x_n = \dfrac{\det{A_n}}{\det{A}}$</p><p>其中$\det{A_n}$是把行列式$\det{A}$中第n列的所有元素，依次用方程组右端的常数项替换。</p><h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p>根据克莱默法则，可知：</p><p>$x = \dfrac{\det{A_x}}{\det{A}},y = \dfrac{\det{A_y}}{\det{A}},z = \dfrac{\det{A_z}}{\det{A}}$</p><p>$\det{A} = \begin{vmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{vmatrix}$</p><p>$\det{A_x} = \begin{vmatrix}<br>    -d_1&amp;b_1&amp;c_1\\<br>    -d_2&amp;b_2&amp;c_2\\<br>    -d_3&amp;b_3&amp;c_3\\<br>\end{vmatrix},\det{A_y} = \begin{vmatrix}<br>    a_1&amp;-d_1&amp;c_1\\<br>    a_2&amp;-d_2&amp;c_2\\<br>    a_3&amp;-d_3&amp;c_3\\<br>\end{vmatrix},\det{A_z} = \begin{vmatrix}<br>    a_1&amp;b_1&amp;-d_1\\<br>    a_2&amp;b_2&amp;-d_2\\<br>    a_3&amp;b_3&amp;-d_3\\<br>\end{vmatrix}$</p><p>$p = \dfrac{-d_1(\vec{n_2}\times\vec{n_3}) -d_2(\vec{n_3}\times\vec{n_1})-d_3(\vec{n_1}\times\vec{n_2})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{n_3})}$</p><h2 id="求两平面相交的直线方程"><a href="#求两平面相交的直线方程" class="headerlink" title="求两平面相交的直线方程"></a>求两平面相交的直线方程</h2><p>两个非平行平面会相交与一条线，直线方程可以用一个方向向量$\vec{v}$和一个点$\textbf{p}_o$来表示：$\textbf{p}_o + t\vec{v}$,<br>$\vec{v}$垂直于两个平面的法线$\vec{n_1}和\vec{n_2}$，因此$\vec{v} = \vec{n_1}\times\vec{n_2}$</p><p>现在需要找到直线上的任意一点$\textbf{p}_o$,根据上节内容，三个平面相交于一点，因此我们只需要构造出第三个平面（法线为$\vec{v}$并且d = 0），因此第三个平面方程为：</p><p>$v_xx+v_yy+v_zz = 0$</p><p>根据上节三平面求交点公式：</p><p>$\textbf{p}_o = \dfrac{-d_1(\vec{n_2}\times\vec{n_3}) -d_2(\vec{n_3}\times\vec{n_1})-d_3(\vec{n_1}\times\vec{n_2})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{n_3})}$</p><p>$\textbf{p}_o = \dfrac{-d_1(\vec{n_2}\times\vec{v})-d_2(\vec{v}\times\vec{n_1})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{v})}$</p><p>$\textbf{p}_o =\dfrac{(-d_1\vec{n_2} + d_2\vec{n_1})\times\vec{v}}{\vec{v}\cdot\vec{v}}$</p><p>$\textbf{Line} = \textbf{p}_o + t\vec{v}\\<br>= \dfrac{(-d_1\vec{n_2} + d_2\vec{n_1})\times\vec{v}}{\vec{v}\cdot\vec{v}} + t\vec{v}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D图形数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="http://www.songho.ca/math/plane/plane.html">songho-openGL</a></p><p><a href="https://zhuanlan.zhihu.com/p/161429987">克莱默法则</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（八）：几何图元-直线和光线</title>
      <link href="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/"/>
      <url>/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="几何图元-直线和光线"><a href="#几何图元-直线和光线" class="headerlink" title="几何图元-直线和光线"></a>几何图元-直线和光线</h1><h2 id="几何表述"><a href="#几何表述" class="headerlink" title="几何表述"></a>几何表述</h2><p>在计算机图形学中，描述几何形状的主要策略有两大类：隐式几何和显示几何。</p><h3 id="隐式几何（-implicit-Geometry-）"><a href="#隐式几何（-implicit-Geometry-）" class="headerlink" title="隐式几何（$implicit\ Geometry$）"></a>隐式几何（$implicit\ Geometry$）</h3><p>通过隐函数的方式描述一个对象,一般采用$f(x,y,z) = 0$的定义方式，告诉了我们$x,y,z$需要满足的关系。例如对于三维空间以原点为圆心的单位球可以这表示：</p><p>$x^2+y^2+z^2 = 1$</p><p>隐函数形式可以方便的通过将点带入函数，判断点是否在几何表面上，之内或之外。但是隐函数无法直观的告诉有哪些点是满足这种关系的。</p><p><img src="1.jpg" alt="隐式几何"></p><p>隐式几何代表：</p><ul><li>代数方法</li><li>CSG</li><li>distance Function</li><li>level Set Methods</li><li>Fractals</li></ul><h3 id="显示几何（-explicit-Geometry-）"><a href="#显示几何（-explicit-Geometry-）" class="headerlink" title="显示几何（$explicit\ Geometry$）"></a>显示几何（$explicit\ Geometry$）</h3><p>描述几何的另外一种方式是参数方程。同样地，几何仍由函数定义，但这一次$x,y,z$不是作为输入，而是作为输出。我们以二维平面的单位圆为例：</p><p>$x(t) = \cos2\pi{t}$</p><p>$y(t) = \sin2\pi{t}$</p><p>当t从0变为1时，点$(x(t),y(t))$将显示要描述的形状的轮廓:</p><p><img src="2.jpg" alt="显示几何-单位元"></p><p>另外一个例子，uv坐标映射为三维空间的$x,y,z$：</p><p><img src="3.jpg" alt="隐式几何-马鞍"></p><p>通常情况下，参数会被归一化为$[0,1]$之间。</p><p>显式几何正好和隐式几何相反，它可以直观的告诉空间中的哪些点满足要求，但是对于空间中的一个点，它不好判定点是否在几何表面。</p><h2 id="光线（-Ray-）"><a href="#光线（-Ray-）" class="headerlink" title="光线（$Ray$）"></a>光线（$Ray$）</h2><p>从现在开始将逐步展开介绍特定的几何图元。首先从最基本也是最重要的一个开始，线（$Linear Segment$），有三种基本类型的线，分别为：</p><ul><li>直线：可以在两个方向上无限延伸</li><li>线段：具有两个端点的直线的有限部分</li><li>光线：具有原点并在一个方向上无限延申</li></ul><h3 id="光线定义"><a href="#光线定义" class="headerlink" title="光线定义"></a>光线定义</h3><p>光线有两个属性，分别为起点和方向,那么在任意时间t（$0 &lt;= t &lt;\infin$）,光线到达的位置由以下方程定义：</p><p>$\textbf{Ray}(t) = \textbf{origin} + t\textbf{d}\;\;\;\;(0 &lt;= t &lt;\infin)$</p><p><img src="4.jpg" alt="隐式几何-马鞍"></p><p>尽管向量格式更紧凑，并且具有很好的属性，但是也可以为每个坐标写出一个单独的标量函数：</p><p>$x(t) = origin_x + td_x$</p><p>$y(t) = origin_y + td_y$</p><p>$z(t) = origin_z + td_z$</p><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>直线虽然简单，却有好几种不同的定义方式，这些定义分别会从从不同的角度去理解。</p><h3 id="斜截式（-Slope-Intercept-）"><a href="#斜截式（-Slope-Intercept-）" class="headerlink" title="斜截式（$Slope-Intercept$）"></a>斜截式（$Slope-Intercept$）</h3><p>斜截式是一种在二维中表达直线的形式，符号$m$表示竖直高度与水平高度的比率（斜率），$y_0$表示y轴截距，是直线与y轴交叉的位置。</p><p>$y = mx + y_0$</p><p><img src="5.jpg" alt="斜截式"></p><p>注：垂直线有无限斜率（$x = n$），无法用$y = mx + y_0$的方式表达，可以通过以下略有不同的隐函数解决这个奇点问题：</p><p>$ax + by = d$</p><h3 id="点乘法"><a href="#点乘法" class="headerlink" title="点乘法"></a>点乘法</h3><p>$ax + by = d$可以看作$点p\begin{bmatrix}<br>    x\\ y\\<br>\end{bmatrix}$和向量$n\begin{bmatrix}<br>    a\\ b\\<br>\end{bmatrix}$的点积，即：</p><p>$\textbf{p}\cdot\textbf{n} = d$</p><p>根据向量点积的定义，$\textbf{p}\cdot\textbf{n}$等于$\textbf{p}$在$\textbf{n}$上投影的长度：</p><p><img src="6.jpg" alt="点乘法"></p><p><strong>向量$\hat{n}$是与直线垂直的的单位向量。d是从原点到直线的有符号垂直距离。任何投影到$\hat{n}$的长度等于$d$的点都满足直线方程。这里之所以采用有符号距离，意思是如果直线位于和法线点相同的原点的一侧，则$d$为正，随着$d$的增加，直线将沿着$\hat{n}$的方向移动。</strong></p><h3 id="垂直平分线（-Perpendicular-Bisector-）"><a href="#垂直平分线（-Perpendicular-Bisector-）" class="headerlink" title="垂直平分线（$Perpendicular\;Bisector$）"></a>垂直平分线（$Perpendicular\;Bisector$）</h3><p>定义直线的最后一种方式是作为两点的垂直平分线：</p><p><img src="7.jpg" alt="点乘法"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（七）：极坐标系</title>
      <link href="/2022/06/15/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/2022/06/15/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（七）：极坐标系"><a href="#图形学的数学基础（七）：极坐标系" class="headerlink" title="图形学的数学基础（七）：极坐标系"></a>图形学的数学基础（七）：极坐标系</h1><p>笛卡尔坐标系不是精确绘制空间和定义位置的唯一坐标系统。笛卡尔系统的替代方案是极坐标系($Polar\;Coordinate\;System$)</p><h2 id="二维极坐标系"><a href="#二维极坐标系" class="headerlink" title="二维极坐标系"></a>二维极坐标系</h2><p>二维笛卡尔坐标系有一个原点和两个穿过原点的轴$（x，y）$。二维极坐标空间也有一个原点，称为极点（$Pole$）-定义了坐标空间的中心,不同的是,极坐标系只有一个轴,称为极轴（$Polar\; Axis$）,</p><p><img src="1.png" alt="二维极坐标系"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在极坐标系中,我们通常用$(r,\theta)$定义一个点,r为距离原点的长度,$\theta$为相对于极轴旋转的角度(逆时针方向).</p><p><img src="2.jpg" alt="二维极坐标系"></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>极坐标系中有一个不同于笛卡尔坐标系的显著特征.笛卡尔坐标系中空间中一个点对应唯一的坐标(x,y)，而在极坐标中，空间中的一个点可能对应多个坐标.原因就在于极坐标系的定义($r, \theta$)。$\theta与\theta + 360^°$指定的是同一个方向。也可以将$\theta + 180^°$同时r取反来实现。</p><p>因此：<br>$(r,\theta) = (r, \theta + 360^°) = ((-1)^kr, \theta + k180^° )$</p><p>尽管存在别名，但是我们尽可能需要采用最优的描述点的方式。描述任何给定点的“首选”方式称为该点的规范（$Canonical$）坐标,规范化坐标需要满足以下三个条件：</p><ul><li>$r&gt;=0$</li><li>$-180^° &lt; \theta &lt;= 180^°$</li><li>$如果 r = 0，则 \theta = 0$</li></ul><h3 id="二维笛卡尔坐标系和极坐标转换"><a href="#二维笛卡尔坐标系和极坐标转换" class="headerlink" title="二维笛卡尔坐标系和极坐标转换"></a>二维笛卡尔坐标系和极坐标转换</h3><p>假设二维空间中的一点$P$，笛卡尔坐标为$(x, y)$，极坐标为$(r, \theta)$,则它们之间的转换关系如下：</p><p><img src="3.jpg" alt="二维极坐标系"></p><p><strong>笛卡尔坐标系和极坐标转换主要用到了三角函数</strong>.</p><h4 id="二维极坐标系转换为笛卡尔坐标系"><a href="#二维极坐标系转换为笛卡尔坐标系" class="headerlink" title="二维极坐标系转换为笛卡尔坐标系"></a>二维极坐标系转换为笛卡尔坐标系</h4><p>$x = r\cos\theta$</p><p>$y = r\sin\theta$</p><h4 id="笛卡尔坐标系转换极坐标系"><a href="#笛卡尔坐标系转换极坐标系" class="headerlink" title="笛卡尔坐标系转换极坐标系"></a>笛卡尔坐标系转换极坐标系</h4><p>$r = \sqrt{x^2 + y^2}$</p><p>$\theta = \arctan2(y,x)$</p><h2 id="三维极坐标系"><a href="#三维极坐标系" class="headerlink" title="三维极坐标系"></a>三维极坐标系</h2><p>极坐标系同样适用于三维空间，三维极坐标系有三个值，是从二维极坐标系拓展而来的，第三个坐标值可以是角度也可以是另外个长度。这样就衍生出了两种极坐标系。</p><h3 id="圆柱坐标（-Cylindrical-Coordinate-）"><a href="#圆柱坐标（-Cylindrical-Coordinate-）" class="headerlink" title="圆柱坐标（$Cylindrical\;Coordinate$）"></a>圆柱坐标（$Cylindrical\;Coordinate$）</h3><p>如果第三个极坐标值添加的是线性距离（$z$），那么得到的就是一个圆柱坐标。</p><p><img src="4.jpg" alt="二维极坐标系"></p><h4 id="球面坐标和三维笛卡尔坐标转换"><a href="#球面坐标和三维笛卡尔坐标转换" class="headerlink" title="球面坐标和三维笛卡尔坐标转换"></a>球面坐标和三维笛卡尔坐标转换</h4><p>由上图可知，球面坐标和三维笛卡尔坐标的z值是相同的，因此只需要按照二维极坐标的转换逻辑转换xy值即可</p><p>圆柱坐标转换为三维坐标：</p><p>$x = r\cos\theta$</p><p>$y = r\sin\theta$</p><p>$z = z$</p><p>三维坐标转换为圆柱坐标：</p><p>$r = \sqrt{x^2+y^2}$</p><p>$\theta = \arctan2(y, x)$</p><p>$z = z$</p><h3 id="球面坐标（-Spherical-Coordinate-System-）"><a href="#球面坐标（-Spherical-Coordinate-System-）" class="headerlink" title="球面坐标（$Spherical\;Coordinate\;System$）"></a>球面坐标（$Spherical\;Coordinate\;System$）</h3><p>更常见的三维极坐标系是球坐标系，球面坐标有两个角度和一个距离$(r, \theta, \phi)$。三维球形空间中有两个极轴：  第一个水平轴，对应二维极坐标中的极轴，另一个垂直轴 对应三维笛卡尔坐标的$+y$。</p><h4 id="三维极坐标定位方式"><a href="#三维极坐标定位方式" class="headerlink" title="三维极坐标定位方式"></a>三维极坐标定位方式</h4><ul><li>站在原点，面向水平极轴方向（$x$），垂直轴的指向从脚指向头部。右臂向上。指向垂直极轴。</li><li>逆时针旋转$\theta$</li><li>将手臂向下旋转角度$\phi$，右臂现在指向极角$\theta和\phi$的方向。</li><li>沿着该方向从原点移动距离r，这时你到达了球面坐标$(r,\theta,\phi)$描述的点。</li></ul><p><img src="6.jpg" alt="二维极坐标系"></p><p>水平角$\theta$称为方位角（$Azimuth$）,$\phi$称为天顶($Zenith$)。我们日常使用的经纬度其实也是一种球面坐标系。经度($Longitude$)与$\theta$相同，维度($Latitude$)是$90^° - \phi$。由于我们通常只描述行星表面的点，所以r是个常数。</p><h4 id="球面坐标规范化条件"><a href="#球面坐标规范化条件" class="headerlink" title="球面坐标规范化条件"></a>球面坐标规范化条件</h4><ul><li>$r &gt;= 0$</li><li>$180^° &lt; \theta &lt;= 180^°$</li><li>$-90^° &lt; \phi &lt;= 90^°$</li><li>$如果r = 0，则\theta = 0^° \phi = 0^°$</li><li>$如果|\phi| = 90^°，则\theta = 0^°$</li></ul><h4 id="球面坐标和三维笛卡尔坐标的转换（右手系）"><a href="#球面坐标和三维笛卡尔坐标的转换（右手系）" class="headerlink" title="球面坐标和三维笛卡尔坐标的转换（右手系）"></a>球面坐标和三维笛卡尔坐标的转换（右手系）</h4><p><img src="7.jpg" alt="二维极坐标系"></p><p>由上图可知：<br><strong>球面坐标-&gt;三维笛卡尔坐标：</strong></p><p>$d = r\sin\phi$</p><p>$x = d\cos\theta = r\sin\phi\cos\theta$</p><p>$y = d\sin\theta = r\sin\phi\sin\theta$</p><p>$z = r\cos\phi$</p><p><strong>三维笛卡尔坐标-&gt;球面坐标：</strong></p><p>$r=\sqrt{x^2+y^2+z^2}$</p><p>$\theta = \arctan2(y,x)$</p><p>$\phi = \arctan2(r, z)$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（六）：mvp变换</title>
      <link href="/2022/06/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2/"/>
      <url>/2022/06/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（六）：mvp变换"><a href="#图形学的数学基础（六）：mvp变换" class="headerlink" title="图形学的数学基础（六）：mvp变换"></a>图形学的数学基础（六）：mvp变换</h1><p>图形学的一个重要任务是将三维空间中的模型映射到二维平面(以像素为单位)，这是一个复杂的过程，取决于许多因素，包括但不限于相机的位置，方向，投影的类型（正交/透视），fov，和viewport宽高，对于所有复杂的矩阵变换，最好的做法是将其分解为几个更简单的矩阵乘积。大多数图形系统通过使用四个转换序列来实现mvp变换,以openGL为例：</p><p><img src="1.png" alt="mvp变换"></p><ol><li><p><strong>worldMatrix</strong>：将视图从模型空间转换到世界空间。直白的说就是将模型摆放到世界坐标空间。这一步确立了世界空间中各模型的相对布局，摆放位置。</p></li><li><p><strong>viewMatrix</strong>：将视图从世界空间转换到相机空间。简单来讲就是：我们从何处，以什么样的视角观察世界。</p></li><li><p><strong>Projection</strong>：将视图从相机空间映射到$[-１,１]^３$，的单位立方体中，为下一步viewport变换做准备。</p></li><li><p><strong>viewport</strong>: 将视图从单位立方体映射到所需的屏幕空间（$screenSpace$），取决于输出图像的大小和位置。</p></li></ol><p><img src="2.png" alt="mvp变换"></p><h2 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h2><p>现实生活中，如果相机和所有物体一起移动（相对位置关系不变），则拍出来的照片也都是一样的。根据这个原理我们得出：将相机移动到原点，朝向-z方向，构造出一个变换矩阵$\textbf{M}_{view}$，其他物体随着相机一起移动（应用$\textbf{M}_{view}$）。即可完成viewTransform。如何构造$\textbf{M}_{view}$？将视图从世界空间转换到相机空间？首先需要定义相机参数：</p><ul><li>位置（eye Position）：$\mathbf{e}$</li><li>观测方向（gaze Direction）：$\vec{g}$</li><li>向上方向（up Direction）：$\vec{t}$</li></ul><p>根据这些信息，我们可以构造一个以$\mathbf{e}$为原点的uvw标准正交基。</p><ul><li>向量正交化</li><li>将$\mathbf{e}$移动到原点</li><li>旋转$\vec{g}$ 到-z方向</li><li>旋转$\vec{t}$到y方向</li><li>旋转$\vec{g}\times \vec{t}$到x方向。</li></ul><p>因此我们可以将$\textbf{M}_{view}$拆解成平移和旋转两个部分.首先需要对相机参数的向量正交化。</p><p>$\textbf{M}_{view}$ = $\textbf{R}_{view}$$\textbf{T}_{view}$</p><p><img src="3.png" alt="mvp变换"></p><h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><p>根据前边章节讲过的矢量叉乘正交化的方法，可以计算出：</p><p>$\hat{w} = -\dfrac{\vec{g}}{||g||}$</p><p>$\hat{u} = \dfrac{\mathbf{t}\times \mathbf{w}}{||\mathbf{t}\times \mathbf{w}||}$</p><p>$\hat{v} = \mathbf{w}\times \mathbf{u}$</p><h3 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h3><p>$\textbf{T}_{view}$ = $\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-x_{e}\\<br>    0&amp;1&amp;0&amp;-y_{e}\\<br>    0&amp;0&amp;1&amp;-z_{e}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>旋转矩阵不好写，但是我们可以反过来思考这个问题，将x（1，0，0），y（0，1，0），z（0，0，1）分别旋转到$\hat{u}$,$\hat{v}$, $-\hat{w}$是很好写的，由于这两个矩阵互为逆矩阵，根据旋转矩阵的性质，旋转矩阵都是正交的，而正交矩阵的逆矩阵等于其转置。所以我们可以先求$\textbf{R}_{view}$的逆矩阵，然后将其转置，即可得到$\textbf{R}_{view}$：</p><p>$\textbf{R}_{view}^{-1}$ = $\begin{bmatrix}<br>    x_u&amp;x_v&amp;x_w&amp;0\\<br>    y_u&amp;y_v&amp;y_w&amp;0\\<br>    z_u&amp;z_v&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><p>$\textbf{R}_{view}$ = $\begin{bmatrix}<br>    x_u&amp;y_u&amp;z_u&amp;0\\<br>    x_v&amp;y_v&amp;z_v&amp;0\\<br>    x_w&amp;y_w&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="合到一起"><a href="#合到一起" class="headerlink" title="合到一起"></a>合到一起</h3><p>$\textbf{M}_{view} = \textbf{R}_{view}\textbf{T}_{view} = \begin{bmatrix}<br>    x_u&amp;y_u&amp;z_u&amp;0\\<br>    x_v&amp;y_v&amp;z_v&amp;0\\<br>    x_w&amp;y_w&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-x_{e}\\<br>    0&amp;1&amp;0&amp;-y_{e}\\<br>    0&amp;0&amp;1&amp;-z_{e}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><p>接下来我们实现mvp变换中的投影变换（$projection Transform$和视口变换($viewport)，投影变换有两种方式，分为正交投影（$Orthographic projection$）和透视投影（$perspective projection$）.两种投影方式最终都将视锥体内的物体投影到近平面上（将视图从相机空间映射到$[-１,１]^３$的标准立方体中），也是3D空间映射到2D屏幕空间最为关键的一步，如下图所示：</p><p><img src="6.png" alt="正交投影和透视投影"></p><h3 id="正交投影（-Orthographic-projection-）"><a href="#正交投影（-Orthographic-projection-）" class="headerlink" title="正交投影（$Orthographic projection$）"></a>正交投影（$Orthographic projection$）</h3><p>正交投影会保持几何图元相对位置关系不变，平行的线永远平行。不满足透视关系。又叫做平行投影。<br>正交投影的视锥体是一个长方形，由top bottom left right near far6个参数定义。如下图所示：</p><p><img src="7.png" alt="正交投影和透视投影"></p><p>如何将该长方体映射到$[-1,1]^3$呢?和$\textbf{M}_{view}$类似,我们先将立方体中心移动到原地,然后根据每个方向的长度,缩放到[-1,1]之间.即$\textbf{M}_{scale}$$\textbf{M}_{translate}$.需要一次平移变换 + 一次缩放变换.</p><p><img src="8.jpg" alt="正交投影和透视投影"></p><h4 id="textbf-M-translate-平移矩阵"><a href="#textbf-M-translate-平移矩阵" class="headerlink" title="$\textbf{M}_{translate}$平移矩阵"></a>$\textbf{M}_{translate}$平移矩阵</h4><p>根据正交投影视锥体的6个参数,可以计算出它的中心位置.即:</p><p>$\textbf{center} = \begin{bmatrix}<br>    \dfrac{r+l}{2}\\<br>    \dfrac{t+b}{2}\\<br>    \dfrac{n+f}{2}\\<br>\end{bmatrix}$</p><p>$\textbf{M}_{translate} = \begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h4 id="textbf-M-scale-缩放矩阵"><a href="#textbf-M-scale-缩放矩阵" class="headerlink" title="$\textbf{M}_{scale}$缩放矩阵"></a>$\textbf{M}_{scale}$缩放矩阵</h4><p>同样根据视锥体6个参数,可以计算出立方体的长宽高(假设z方向的边为长,y方向的边为高)分别为:<br>$n-f, r-l, t-b$.</p><p>根据缩放矩阵的定义可知:</p><p>$\textbf{M}_{scale} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h4 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h4><p>$\textbf{M}_{orthographic} = \textbf{M}_{scale}$$\textbf{M}_{translate} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="透视投影（-perspective-projection-）"><a href="#透视投影（-perspective-projection-）" class="headerlink" title="透视投影（$perspective projection$）"></a>透视投影（$perspective projection$）</h3><p>透视投影满足透视关系，即近大远小效果。平行线在远处会相交于某一点，符合人眼视觉系统。计算机图形学中绝大部分都使用透视投影，来模拟人自然看到物体的样子。</p><p><img src="5.png" alt="正交投影和透视投影"></p><h4 id="视锥体（-Frustum-）定义"><a href="#视锥体（-Frustum-）定义" class="headerlink" title="视锥体（$Frustum$）定义"></a>视锥体（$Frustum$）定义</h4><p>和正交投影不同,透视投影的视锥体是个截锥体(Frustum)<br><img src="9.jpg" alt="正交投影和透视投影"></p><p>视锥体由以下几个参数定义：</p><ul><li>$fov（field of view）$: 视角范围</li><li>$aspectRatio（长宽比）$：定义近平面的宽高比</li><li>$n（近平面距离）$：近平面距离原点距离</li></ul><p><img src="11.jpg" alt="正交投影和透视投影"></p><p>由视锥体的参数可以推导出$l,r,b,t$：</p><p>$\tan\dfrac{fov}{2} = \dfrac{t}{|n|}$</p><p>$aspectRatio = \dfrac{r}{t}$</p><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>观察上图我们发现,透视投影远平面比近平面要大些,除了这些两个视锥体几乎是一样的。所以在我们做透视投影变换时，不妨先将其转换为右侧的长方体，然后再做一次正交投影变换即可：</p><p>$\textbf{M}_{perspective} = \textbf{M}_{orthographic}\textbf{M}_{persp-&gt;ortho}$</p><h4 id="“挤压变换”"><a href="#“挤压变换”" class="headerlink" title="“挤压变换”"></a>“挤压变换”</h4><p><img src="10.jpg" alt="正交投影和透视投影"></p><p>任选一点P，如果将其“挤压”至P1点，我们观察$\triangle{OPR}和\triangle{NPP1}$,不难发现两个三角形是相似三角形，根据相似三角形定律: $y^丶 = \dfrac{ny}{z}$,同理 $x^丶 = \dfrac{nx}{z}$.</p><p>在齐次坐标下：</p><p>$\textbf{M}_{persp-&gt;ortho}\begin{bmatrix}<br>    x\\ y\\ z\\ 1\\<br>\end{bmatrix} = \begin{bmatrix}\dfrac{nx}{z}\\ \dfrac{ny}{z}\\ unknown \\1 \end{bmatrix} = \begin{bmatrix}nx\\ ny\\ unknown \\z \end{bmatrix}$</p><p>$\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    ?&amp;?&amp;?&amp;?\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><p>近平面的任意一点在挤压后的z值不会改变：</p><p>$\begin{bmatrix}\dfrac{nx}{n}\\ \dfrac{ny}{n}\\ n \\1 \end{bmatrix} = \begin{bmatrix}nx\\ ny\\ n^2  \\n\end{bmatrix}$</p><p>$\begin{bmatrix}<br>    0&amp;0&amp;A&amp;B<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ n\\ 1\\ \end{bmatrix} = n^2$</p><p>$An + B = n^2$</p><p>远平面的任意一点挤压后z值不会改变,更特殊的是，远平面的中心点（0，0，f）在挤压后仍然在（0，0，f），根据这一特性我们能够得到：</p><p>$\begin{bmatrix}0\\ 0\\ f \\1 \end{bmatrix} = \begin{bmatrix}0\\ 0\\ f^2  \\f\end{bmatrix}$</p><p>$Af + B = f^2$</p><p>解二元一次方程组：</p><p>$An + B = n^2$</p><p>$Af + B = f^2$</p><p>$A = n+f$  </p><p>$B = -nf$</p><p>$\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    ?&amp;?&amp;?&amp;?\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix} \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;A&amp;B\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;n+f&amp;-nf\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><p>$\textbf{M}_{perspective} = \textbf{M}_{orthographic}\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;n+f&amp;-nf\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><h2 id="视口变换-viewport"><a href="#视口变换-viewport" class="headerlink" title="视口变换($viewport$)"></a>视口变换($viewport$)</h2><p>经过复杂的投影变换后，我们将空间中的一个视锥体映射到了$[-1,1]^3$的标准立方体中，接下来我们将通过视口变换将其映射到屏幕空间。</p><h3 id="屏幕空间（-screenSpace-）定义"><a href="#屏幕空间（-screenSpace-）定义" class="headerlink" title="屏幕空间（$screenSpace$）定义"></a>屏幕空间（$screenSpace$）定义</h3><p><img src="10.jpg" alt="正交投影和透视投影"></p><ul><li>屏幕左下角为原点（0，0）</li><li>向右为x，向上为y</li><li>像素（pixel）的坐标以（x，y）表示，xy均为整数</li><li>像素坐标的范围 （0，0） ~ （width - 1，height - 1）</li><li>Pixel（x，y）的中心点位于（x+0.5，y+0.5）</li><li>每个像素形成单位宽高的“正方体”</li><li>屏幕空间覆盖范围为（0，0）~（width，height）</li></ul><h3 id="推导-1"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h3><p>原地缩放 $\begin{bmatrix}<br>     \dfrac{width}{2}\\<br>    \dfrac{height}{2}<br>\end{bmatrix}$，然后平移到$\begin{bmatrix}<br>    \dfrac{width}{2}\\<br>    \dfrac{height}{2}<br>\end{bmatrix}$</p><p>$\textbf{M}_{viewport} = \begin{bmatrix}<br>    \dfrac{width}{2}&amp;0&amp;0&amp;\dfrac{width}{2}\\<br>    0&amp;\dfrac{height}{2}&amp;0&amp;\dfrac{height}{2}\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://item.jd.com/10037953813770.html">fundamentals-of-computer-graphics</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（五）：矩阵进阶</title>
      <link href="/2022/05/25/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/05/25/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（五）：矩阵进阶"><a href="#图形学的数学基础（五）：矩阵进阶" class="headerlink" title="图形学的数学基础（五）：矩阵进阶"></a>图形学的数学基础（五）：矩阵进阶</h1><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>对于方形矩阵，有一个特殊的标量称为矩阵的行列式（$Determinant$。方形矩阵$\textbf{M}$的行列式表示为$|\textbf{M}|$,也表示为“det M”。非方形矩阵的行列式是未定义的。</p><h3 id="2-times-2-和-3-times-3-矩阵的行列式"><a href="#2-times-2-和-3-times-3-矩阵的行列式" class="headerlink" title="$2\times 2$和$3\times 3$矩阵的行列式"></a>$2\times 2$和$3\times 3$矩阵的行列式</h3><p>$2\times 2$矩阵行列式：</p><p>$\begin{vmatrix}M\end{vmatrix} = \begin{vmatrix}m_{11}&amp;m_{12}\\ m_{21}&amp;m_{22}\end{vmatrix} = m_{11}m_{22} - m_{12}m_{21}$</p><p>$3\times 3$矩阵行列式：</p><p>$\begin{vmatrix}M\end{vmatrix} = \begin{vmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\ m_{21}&amp;m_{22}&amp;m_{23}\\ m_{31}&amp;m_{32}&amp;m_{33}\end{vmatrix} = m_{11}m_{22} - m_{12}m_{21} = m_{11}m_{22}m_{33} + m_{12}m_{23}m_{31} + m_{13}m_{21}m_{32} - m_{13}m_{22}m_{31} - m_{12}m_{21}m_{33} - m_{11}m_{23}m_{32} = m_{11}(m_{22}m_{33} - m_{23}m_{32}) + m_{12}(m_{23}m_{31} - m_{21}m_{33}) + m_{13}(m_{21}m_{32} - m_{22}m_{31})$</p><p><img src="1.png" alt="3x3矩阵行列式"></p><p>如果将$X\times 3$矩阵的行解释为3个向量，那么该矩阵的行列式等价于3个向量的三重积。</p><p>$\begin{vmatrix}<br>    a_x&amp;a_y&amp;a_z\\ b_x&amp;b_y&amp;b_z\\ c_x&amp;c_y&amp;c_z<br>\end{vmatrix}$ = $(a_yb_z -a_zb_y)c_x + (a_zb_x - a_xb_z)c_y + (a_xb_y - a_yb_x)c_z = (\mathbf{a}\times \mathbf{b})\cdot \mathbf{c}$</p><h3 id="子矩阵行列式-Minor-和余子式-Cofactor"><a href="#子矩阵行列式-Minor-和余子式-Cofactor" class="headerlink" title="子矩阵行列式($Minor$)和余子式($Cofactor$)"></a>子矩阵行列式($Minor$)和余子式($Cofactor$)</h3><h3 id="子矩阵行列式"><a href="#子矩阵行列式" class="headerlink" title="子矩阵行列式"></a>子矩阵行列式</h3><p>假设$\textbf{M}$具有$r$行和$c$列的矩阵，考虑通过$\textbf{M}$中删除行i和列j而获得的矩阵。该矩阵具有r-1行和c-1列。这个矩阵的行列式表示为$\textbf{M}^{ij}$,被称为$\textbf{M}$的子矩阵行列式。</p><h4 id="余子式"><a href="#余子式" class="headerlink" title="余子式"></a>余子式</h4><p>给定行和列的方形矩阵$\textbf{M}$的余子式与相应的子矩阵行列式相同，但余子式会交替变负，正负取决于因子$(-1)^{i + j}$.矩阵的余子式用来计算$n\times n$任意维度矩阵的行列式。</p><p>$C^{ij} = (-1)^{i+j}M^{ij}$</p><p>我们使用$C^{ij}$表示行i列j中的$\textbf{M}$的余子式。<br>+&amp;-&amp;+&amp;-&amp;…\\<br>$\begin{bmatrix}<br>    +&amp;-&amp;+&amp;-&amp;…\\ -&amp;+&amp;-&amp;+&amp;…\\ +&amp;-&amp;+&amp;-&amp;…\\  -&amp;+&amp;-&amp;+&amp;…\\ …&amp;…&amp;…&amp;…&amp;…<br>\end{bmatrix}$</p><h3 id="行列式的数学定义"><a href="#行列式的数学定义" class="headerlink" title="行列式的数学定义"></a>行列式的数学定义</h3><p>对于任意维度$n\times n$矩阵的行列式，可以通过它的余子式计算。这个定义是递归的，因为<strong>余子式本质上是有符号的行列式</strong>。首先从矩阵中任意选择一行或一列。对于行或列中的每个元素，将此元素乘以相应的余子式，对这些乘积求和可得出最终的行列式：</p><p>$\begin{vmatrix}<br>    \textbf{M}<br>\end{vmatrix} = \sum\limits_{j=1}^n{m_{ij}C^{ij}} = \sum\limits_{j=1}^n{m_{ij}(-1)^{i + j}M^{ij}}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>．任何维度的单位矩阵行列式为1：$\begin{vmatrix}I\end{vmatrix} = 1$</p><p>．矩阵乘积的行列式等于矩阵行列式的乘积：　$\begin{vmatrix}AB\end{vmatrix} = \begin{vmatrix}A\end{vmatrix}\begin{vmatrix}B\end{vmatrix}$</p><p>. 矩阵转置的行列式等于原始矩阵行列式：$\begin{vmatrix}M^T\end{vmatrix} = \begin{vmatrix}M\end{vmatrix}$<br>. 如果矩阵中的任何行或者列包含全0元素，则该矩阵的行列式为0<br>. 交换任意行会让行列式变负</p><h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p><strong>在几何上行列式表示了当前变换矩阵对空间的压缩或者拉伸程度。</strong>。即经过一次变换后，空间被压缩或者拉伸了多少。二维中，行列式等于具有基向量作为两条边的平行四边形的有符号面积。三维中，行列式是平行六面体的体积。</p><p><img src="2.webp" alt="行列式的几何意义"></p><h2 id="逆矩阵（Inverse）"><a href="#逆矩阵（Inverse）" class="headerlink" title="逆矩阵（Inverse）"></a>逆矩阵（Inverse）</h2><p>对于方形矩阵来说，另一个重要运算是逆矩阵。方形矩阵$\textbf{M}$的逆矩阵表示为$\textbf{M}^{-1}$.</p><p>并非所有矩阵都有逆矩阵。如果某个矩阵有逆矩阵，则称其为可逆或者非奇异（$Nonsingular$）矩阵。没有逆的矩阵被认为是不可逆或奇异矩阵。<strong>可逆矩阵的列是先行独立的，列也如此。奇异矩阵的行和列是线性相关的。</strong></p><p>奇异矩阵的行列式为零。非奇异矩阵的行列式为非零。一般情况下检查行列式的大小是最常用的可逆性测试。但是也有极端情况，本文对此暂不讨论。</p><h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><h4 id="经典伴随矩阵（-Classical-Adjoint-）"><a href="#经典伴随矩阵（-Classical-Adjoint-）" class="headerlink" title="经典伴随矩阵（$Classical\;Adjoint$）"></a>经典伴随矩阵（$Classical\;Adjoint$）</h4><p>本小节会实用经典伴随矩阵的方法，计算矩阵的逆。<br><strong>矩阵$\textbf{M}$的经典伴随矩阵，表示为“adj M”,被定义为$\textbf{M}$的余子式的矩阵的转置</strong></p><p>$adj M(3\times 3) = \begin{bmatrix}<br>    C^{11}&amp;C^{12}&amp;C^{13}\\<br>    C^{21}&amp;C^{22}&amp;C^{23}\\<br>    C^{31}&amp;C^{32}&amp;C^{33}<br>\end{bmatrix}^T$</p><p><strong>矩阵的逆等于经典伴随矩阵除以行列式</strong></p><p>$\textbf{M}^{-1} = \dfrac{adj\;M}{\begin{vmatrix}<br>    \textbf{M}<br>\end{vmatrix}}$</p><p>注：上式同时也证明了，矩阵行列式为0，则不可逆，其实也可以从几何角度做出解释，行列式为0，表示空间至少被压缩了一个维度,因此无法从低维度恢复到高纬度，因为不是1对1的关系。</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol><li>矩阵逆矩阵的逆等于原始矩阵：$(\textbf{M}^{-1})^{-1} = \textbf{M}$</li><li>矩阵转置的逆等于矩阵逆的转置：$(\textbf{M}^T)^{-1} = (\textbf{M}^{-1})^T$</li><li>矩阵乘积的逆等于矩阵逆的乘积：$(\textbf{AB})^{-1} = \textbf{B}^{-1}\textbf{A}^{-1}$</li><li>逆矩阵的行列式是原矩阵行列式的倒数：$\begin{vmatrix}M^{-1}\end{vmatrix} = \dfrac{1}{\begin{bmatrix}M\end{bmatrix}}$</li></ol><h3 id="几何解释-1"><a href="#几何解释-1" class="headerlink" title="几何解释"></a>几何解释</h3><p>从几何视角来看，逆矩阵通常代表了“反向”或“撤销”操作。</p><h2 id="正交矩阵（-Orthogonal-Matrix-）"><a href="#正交矩阵（-Orthogonal-Matrix-）" class="headerlink" title="正交矩阵（$Orthogonal\;Matrix$）"></a>正交矩阵（$Orthogonal\;Matrix$）</h2><h3 id="数学定义-1"><a href="#数学定义-1" class="headerlink" title="数学定义"></a>数学定义</h3><p>当且仅当矩阵及其转置乘积是单位矩阵时，方形矩阵$\textbf{M}$才是正交的。定义如下：</p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}\textbf{M}^T = \textbf{I}$</p><p>根据逆矩阵的定义，矩阵与其逆相乘等于单位矩阵（$\textbf{M}\textbf{M}^{-1} = \textbf{I}$）,因此，<strong>如果矩阵是正交的，则其转置矩阵等于其逆矩阵</strong></p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}^T = \textbf{M}^{-1}$</p><p>利用正交矩阵的这一特性,可以轻易得到矩阵的逆,只要证明其是正交矩阵即可,这样就避免了复杂的的逆矩阵计算过程(使用转置矩阵即可)。图形学中有很多正交矩阵，例如旋转矩阵和反射矩阵都是正交的。</p><h3 id="几何解释-2"><a href="#几何解释-2" class="headerlink" title="几何解释"></a>几何解释</h3><p>在很多情况下，我们可能会获得矩阵构造方式的信息，因此可以先验地知道矩阵仅包含旋转或反射。但如果事先对矩阵一无所知，如何判断矩阵的正交性呢？</p><p>根据正交矩阵的定义可知：</p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}\textbf{M}^T = \textbf{I}$</p><p>$\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\ m_{21}&amp;m_{22}&amp;m_{23}\\ m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix}\begin{bmatrix}m_{11}&amp;m_{21}&amp;m_{31}\\ m_{12}&amp;m_{22}&amp;m_{32}\\ m_{13}&amp;m_{23}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\end{bmatrix}$</p><p>设以下向量$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$代表$\textbf{M}$的行：</p><p>$\textbf{M} = \begin{bmatrix}-&amp;r_1&amp;-\\ -&amp;r_2&amp;-\\ -&amp;r_3&amp;-\\ \end{bmatrix}$</p><p>简化上述矩阵和转置相乘的表达式可得：</p><p>$\mathbf{r_1}\cdot\mathbf{r_1} = 1\;\;\;\;\;\;\mathbf{r_1}\cdot\mathbf{r_2} = 0\;\;\;\;\;\;\mathbf{r_1}\cdot\mathbf{r_3} = 0$</p><p>$\mathbf{r_2}\cdot\mathbf{r_1} = 0\;\;\;\;\;\;\mathbf{r_2}\cdot\mathbf{r_2} = 1\;\;\;\;\;\;\mathbf{r_2}\cdot\mathbf{r_3} = 0$</p><p>$\mathbf{r_3}\cdot\mathbf{r_1} = 0\;\;\;\;\;\;\mathbf{r_3}\cdot\mathbf{r_2} = 0\;\;\;\;\;\;\mathbf{r_3}\cdot\mathbf{r_3} = 1$</p><p>通过上述式子我们推导出正交矩阵需要满足以下几个条件：</p><ol><li>当且仅当向量为单位向量时，向量与自身的点积才为1。 因此$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$为单位向量。即矩阵的每一行必须是单位向量。</li><li>当且仅当两个向量相互垂直时，点积才为0， 因此$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$相互垂直，即矩阵的行相互垂直。</li></ol><p><strong>结论： 当且仅当矩阵每一行都为单位向量且相互垂直的矩阵才是正交矩阵。可以对矩阵的列做同样的描述。因为如果$\textbf{M}$是正交的，$\textbf{M}^T$必然也是正交的。</strong></p><h3 id="矩阵的正交化"><a href="#矩阵的正交化" class="headerlink" title="矩阵的正交化"></a>矩阵的正交化</h3><p>用于构造一组标准正交基向量的算法是$Gram-Schmidt$正交化。基本思想是按顺序遍历基向量。对每个基向量，减去与基向量平行的向量，这必然会产生垂直向量，具体推导细节可以参考之前的文章。</p><p>$\textbf{Gram-Schmidt}\begin{cases}<br>    \vec{v_1} = \vec{x_1}\\<br>    \vec{v_2} = \vec{v_∥} = \vec{x_2} - \vec{x_⊥} = \vec{x_2} - \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}\\<br>    \vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2} = \vec{x_3} - \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}\hat{v_1} - \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}\hat{v_2}<br>\end{cases}$</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（四）：矩阵线性变换</title>
      <link href="/2022/05/20/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
      <url>/2022/05/20/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（四）：矩阵线性变换"><a href="#图形学的数学基础（四）：矩阵线性变换" class="headerlink" title="图形学的数学基础（四）：矩阵线性变换"></a>图形学的数学基础（四）：矩阵线性变换</h1><p>我们可以通过将点的坐标加上一个偏移值来实现平移。 我们还可以利用三角函数来旋转一个向量。 简而言之，<strong>矩阵只是将所有这些变换(缩放、旋转、反射、错切、平移)通过统一结构来表达的一种方式。</strong> 通过矩阵可以方便对空间中的点或向量进行各种变换，而不用写一大堆的公式。这就是矩阵为何在图形学中如此重要的原因。<strong>图形学中的任意变换都可以通过一个矩阵完成</strong> 对同一个对象的多次变换可以通过矩阵相乘转换为单个矩阵。如下图：</p><p><em>注：本文所有推导和公式均使用列向量形式。</em></p><p><img src="1.jpg" alt="alt"></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="缩放（Scale）"><a href="#缩放（Scale）" class="headerlink" title="缩放（Scale）"></a>缩放（Scale）</h3><h3 id="沿主轴缩放"><a href="#沿主轴缩放" class="headerlink" title="沿主轴缩放"></a>沿主轴缩放</h3><p>最简单的缩放是沿每个轴线应用单独的或均匀缩放。</p><h4 id="均匀缩放"><a href="#均匀缩放" class="headerlink" title="均匀缩放"></a>均匀缩放</h4><p>保留原始对象的角度和比例， 使被缩放对象统一增大或者减少s因子。</p><p><img src="2.jpg" alt="alt"></p><p>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}S&amp;0\\0&amp;S\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>同理三维空间中采用以下形式:</p><p>$\begin{bmatrix}x^丶\\y^丶\\z^丶\end{bmatrix} = \begin{bmatrix}S&amp;0&amp;0\\0&amp;S&amp;0\\0&amp;0&amp;S\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h4 id="非均匀缩放"><a href="#非均匀缩放" class="headerlink" title="非均匀缩放"></a>非均匀缩放</h4><p>如果希望”拉伸”或者”挤压”对象,则可以在不同方向上应用不同的缩放因子，这样会实现非均匀缩放。非均匀缩放不会保留原始对象的比例。</p><p><img src="3.jpg" alt="alt"></p><p>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}S_x&amp;0\\0&amp;S_y\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>同理三维空间中采用以下形式:</p><p>$\begin{bmatrix}x^丶\\y^丶\\z^丶\end{bmatrix} = \begin{bmatrix}S_x&amp;0&amp;0\\0&amp;S_y&amp;0\\0&amp;0&amp;S_z\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h3 id="任意方向缩放"><a href="#任意方向缩放" class="headerlink" title="任意方向缩放"></a>任意方向缩放</h3><p>除了沿主轴线缩放外，还可以按照任意方向缩放。设$\hat{n}$为缩放方向（缩放沿着$\hat{n}$执行），缩放因子s。以下将逐步实现沿任意方向缩放的方法。</p><p><strong>step1</strong>:  推导表达式，给定任意矢量$\mathbf{v}$，用$\mathbf{v},s,\hat{n}$计算$\mathbf{v^丶}$。基本思路是将矢量$\mathbf{v}$在$\hat{n}$上投影，分解为$\vec{v_∥}和\vec{v_⊥}$。其中$\vec{v_∥}$根据k因子缩放，$\vec{v_⊥}$保持不变。以下为推导过程：</p><p><img src="4.png" alt="alt"></p><p>$\vec{v} = \vec{v_∥} + \vec{v_⊥}$</p><p>$\vec{v_∥} = (\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶_⊥} = \vec{v_⊥} = \vec{v} - \vec{v_∥} = \vec{v} - (\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶_∥} = s\vec{v_∥} = s(\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶} = \vec{v^丶_⊥} + \vec{v^丶_∥} = \vec{v} - (\vec{v}.\hat{n})\hat{n} + s(\vec{v}.\hat{n})\hat{n} = \vec{v} + (s-1)(\vec{v}.\hat{n})\hat{n}$</p><p><strong>step2</strong>: 既然我们知道了如何缩放任意矢量，则可以计算出缩放后的基矢量值，将原始基矢量$x = \begin{bmatrix}1\\0\end{bmatrix},y = \begin{bmatrix}0\\1\end{bmatrix}$带入上式可得：</p><p>$\vec{x^丶} = \vec{x} + (s-1)(\vec{x}.\hat{n})\hat{n}\\\quad\quad= \begin{bmatrix}1\\0\end{bmatrix} + (s-1)(\begin{bmatrix}1\\0\end{bmatrix}.\begin{bmatrix}n_x\\n_y\end{bmatrix}).\begin{bmatrix}n_x\\n_y\end{bmatrix} \\\quad\quad= \begin{bmatrix}1\\0\end{bmatrix} + (s-1)n_x.\begin{bmatrix}n_x\\n_y\end{bmatrix}\\\quad\quad= \begin{bmatrix}1 + (s-1){n_x}^2\\ (s-1)n_xn_y\end{bmatrix}$</p><p>$\vec{y^丶} = \begin{bmatrix}(s-1)n_xn_y\\1 + (s-1)(n_y)^2\end{bmatrix}$</p><p>推导出二维和三维矢量空间沿任意方向$\hat{n}$缩放s的矩阵为：</p><p>$\textbf{Scale}^2(\hat{n},s) = \begin{bmatrix}1 + (s-1)(n_x)^2&amp;&amp;(s-1)n_xn_y\\  (s-1)n_xn_y&amp;&amp;1+(s-1){n_y}^2\end{bmatrix}$</p><p>$\textbf{Scale}^3(\hat{n},s) = \begin{bmatrix}1 + (s-1)(n_x)^2&amp;&amp;(s-1)n_xn_y&amp;&amp;(s-1)n_xn_z\\ (s-1)n_xn_y&amp;&amp;1+(s-1){n_y}^2&amp;&amp;(s-1)n_yn_z\\ (s-1)n_xn_z&amp;&amp;(s-1)n_yn_z&amp;&amp;1+(s-1){n_z}^2\end{bmatrix}$</p><h3 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h3><p><strong>反射其实是一种特殊的缩放，即按照某个轴线执行-1缩放。</strong></p><h4 id="沿主轴反射"><a href="#沿主轴反射" class="headerlink" title="沿主轴反射"></a>沿主轴反射</h4><p><img src="5.png" alt="alt"><br>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}-1&amp;0\\0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><h4 id="沿任意轴反射"><a href="#沿任意轴反射" class="headerlink" title="沿任意轴反射"></a>沿任意轴反射</h4><p>根据沿任意轴缩放得到的矩阵公式，将-1带入，可得沿任意轴反射的矩阵公式：</p><p>$\textbf{Reflection}^2(\hat{n}) = \begin{bmatrix}1 + (-1-1)(n_x)^2&amp;&amp;(-1-1)n_xn_y\\ (-1-1)n_xn_y&amp;&amp;1+(-1-1){n_y}^2\end{bmatrix}$</p><p>$\textbf{Reflection}^3(\hat{n}) = \begin{bmatrix}1 + (-1-1)(n_x)^2&amp;&amp;(-1-1)n_xn_y&amp;&amp;(-1-1)n_xn_z\\ (-1-1)n_xn_y&amp;&amp;1+(-1-1){n_y}^2&amp;&amp;(-1-1)n_yn_z\\ (-1-1)n_xn_z&amp;&amp;(-1-1)n_yn_z&amp;&amp;1+(-1-1){n_z}^2\end{bmatrix}$</p><h3 id="错切（Shaearing）"><a href="#错切（Shaearing）" class="headerlink" title="错切（Shaearing）"></a>错切（Shaearing）</h3><p>错切是一种“倾斜”坐标空间的变形。它将不均匀的拉伸空间，不保留角度。但是保留面积和体积。基本思路是将一个坐标的倍数添加到另一个坐标上。<br><img src="6.jpg" alt="alt"><br>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}1&amp;a\\0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>二维错切矩阵公式：</p><p>$\textbf{H}_x(s) = \begin{bmatrix}1&amp;s\\0&amp;1\end{bmatrix}$ (沿x轴方向拉拽)</p><p>$\textbf{H}_y(s) = \begin{bmatrix}1&amp;0\\s&amp;1\end{bmatrix}$ (沿y轴方向拉拽)</p><p>三维错切矩阵公式：</p><p>$\textbf{H}_{xy}(s,t) = \begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\s&amp;t&amp;1\end{bmatrix}$</p><p>$\textbf{H}_{xz}(s,t) = \begin{bmatrix}1&amp;0&amp;0\\s&amp;1&amp;t\\s&amp;t&amp;1\end{bmatrix}$</p><p>$\textbf{H}_{yz}(s,t) = \begin{bmatrix}1&amp;s&amp;t\\0&amp;1&amp;0\\s&amp;t&amp;1\end{bmatrix}$</p><h3 id="旋转（Rotation）"><a href="#旋转（Rotation）" class="headerlink" title="旋转（Rotation）"></a>旋转（Rotation）</h3><h4 id="二维空间绕原点的旋转"><a href="#二维空间绕原点的旋转" class="headerlink" title="二维空间绕原点的旋转"></a>二维空间绕原点的旋转</h4><p>在二维空间中只能绕点旋转，本小节公式和实例将旋转点限定为坐标系原点（绕任意点的旋转需要先平移 再旋转 再平移回去，涉及到齐次坐标，暂不讨论）。<br>定义二维空间中旋转角度为$\theta$，根据三角函数的定义可知，基向量$\vec{x},\vec{y}$绕原点旋转后得到$\vec{x^丶},\vec{y^丶}$如下图所示：</p><p><img src="7.png" alt="alt"></p><p>$\textbf{R}(\theta) = \begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}$</p><h4 id="三维空间绕主轴线的旋转"><a href="#三维空间绕主轴线的旋转" class="headerlink" title="三维空间绕主轴线的旋转"></a>三维空间绕主轴线的旋转</h4><p>和二维不同，三维旋转是绕某个轴线进行的。本小节将介绍围绕主轴线（$\mathbf{x}，\mathbf{y}，\mathbf{z}$）的旋转.<br>和缩放矩阵的推导类似，首先对三个基向量变换,以围绕$\mathbf{x}$轴旋转为例：</p><p><strong>step1</strong>：对基向量应用旋转变换：</p><p>$\mathbf{x^丶} =  \mathbf{x} = \begin{bmatrix}1\\0\\0\end{bmatrix}$</p><p>$\mathbf{y^丶} = \begin{bmatrix}0\\\cos\theta\\\sin\theta\end{bmatrix}$</p><p>$\mathbf{z^丶} = \begin{bmatrix}0\\ -\sin\theta\\\cos\theta\end{bmatrix}$</p><p><strong>step2</strong>:组合基向量形成旋转矩阵：</p><p>$\textbf{R}_x(\theta) = \begin{bmatrix}1&amp;0&amp;0\\0&amp;\cos\theta&amp;-\sin\theta\\0&amp;\sin\theta&amp;\cos\theta\end{bmatrix}$</p><p>同理可推导出沿$\mathbf{y},\mathbf{z}$轴的旋转矩阵公式如下：</p><p>$\textbf{R}_y(\theta) = \begin{bmatrix}\cos\theta&amp;0&amp;\sin\theta\\0&amp;1&amp;0\\ -\sin\theta&amp;0&amp;\cos\theta\end{bmatrix}$</p><p>$\textbf{R}_z(\theta) = \begin{bmatrix}\cos\theta&amp;-\sin\theta&amp;0\\\sin\theta&amp;\cos\theta&amp;0\\0&amp;0&amp;1\end{bmatrix}$</p><h4 id="三维空间绕任意轴的旋转"><a href="#三维空间绕任意轴的旋转" class="headerlink" title="三维空间绕任意轴的旋转"></a>三维空间绕任意轴的旋转</h4><p><img src="8.jpg" alt="alt"></p><p>让我们推导出一个围绕$\hat{n}$旋转$\theta$角度的矩阵$\textbf{R}(\hat{n},\theta)$,使得当矩阵$\textbf{R}(\hat{n},\theta)$乘以矢量$\mathbf{v}$得到的矢量$\mathbf{v^丶}$是将$\mathbf{v}$围绕$\hat{n}$旋转$\theta$角度的结果.</p><p>$\mathbf{v^丶} = \textbf{R}(\hat{n},\theta)\mathbf{v}$</p><p><strong>推导思路</strong></p><ol><li>为了得到矩阵$\textbf{R}(\hat{n},\theta)$,需要用$\mathbf{v}, \hat{n}, \theta$来表达$\mathbf{v^丶}$,基本思路是解决垂直于$\hat{n}$的平面中的问题,为此,将$\mathbf{v}$分解为$\mathbf{v_∥}和\mathbf{v_⊥}$两个矢量,分别平行和垂直于单位矢量$\hat{n}$.通过单独旋转每个分量,剋将矢量作为一个整体旋转.即: $\mathbf{v^丶} = \mathbf{v_∥^丶} + \mathbf{v_⊥^丶}$.</li><li>由于$\mathbf{v_∥}$与$\hat{n}$平行,因此它不受旋转影响.即: $\mathbf{v^丶_∥} = \mathbf{v_∥}$</li><li>根据矢量的投影计算可得: $\mathbf{v_∥} = (\mathbf{v}.\hat{n})\hat{n}$     $\mathbf{v_⊥} = \mathbf{v} - \mathbf{v_∥}$</li><li>利用矢量叉积构造$\mathbf{w}$: $\mathbf{w} = \hat{n}\times\mathbf{v_⊥} = \hat{n}\times\mathbf{v}$</li><li>注意上图所示,矢量$\mathbf{w}和\mathbf{v_⊥}$构成了一个二维空间.$\mathbf{v_⊥}$作为x轴,$\mathbf{w}$作为y轴.$\mathbf{v^丶_⊥}$是在这个平面上按角度$\theta$旋转$\mathbf{v_⊥}$的结果.</li></ol><p><strong>推导过程</strong></p><p>$\mathbf{v_∥} = (\mathbf{v}.\hat{n})\hat{n}$</p><p>$\mathbf{v_⊥} = \mathbf{v} - \mathbf{v_∥} = \mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}$</p><p>$\mathbf{w} = \hat{n}\times\mathbf{v_ ⊥} = \hat{n}\times\mathbf{v}$</p><p>$\mathbf{v^丶_⊥} = \cos\theta\mathbf{v_⊥} + \sin\theta\mathbf{w} = \cos\theta(\mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}) + \sin\theta(\hat{n}\times\mathbf{v})$</p><p>$\mathbf{v^丶} = \mathbf{v^丶_⊥} + \mathbf{v_∥} = \cos\theta(\mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}) + \sin\theta(\hat{n}\times\mathbf{v}) + (\mathbf{v}.\hat{n})\hat{n}$</p><p>接下来,计算变换后的基向量，简单带入上式即可.</p><p>$\mathbf{x^丶} = \begin{bmatrix}{n_x}^2(1-\cos\theta) + \cos\theta\\{n_x}{n_y}(1-\cos\theta)+{n_z}\sin\theta\\{n_x}{n_z}(1-\cos\theta)-{n_y}\sin\theta\end{bmatrix}$</p><p>$\mathbf{y^丶} = \begin{bmatrix}{n_x}{n_y}(1-\cos\theta) - {n_z}\sin\theta\\{n_y}^2(1-\cos\theta)+\cos\theta\\{n_y}{n_z}(1-\cos\theta)+{n_x}\sin\theta\end{bmatrix}$</p><p>$\mathbf{z^丶} = \begin{bmatrix}{n_x}{n_z}(1-\cos\theta) + {n_y}\sin\theta\\{n_y}{n_z}(1-\cos\theta)-{n_x}\sin\theta\\{n_z}^2(1-\cos\theta)+\cos\theta\end{bmatrix}$</p><p>通过变换后基矢量的简单组合,即可构造出旋转矩阵</p><p>$\textbf{R}(\hat{n},\theta) = \begin{bmatrix}|&amp;|&amp;|\\ \mathbf{x^丶}&amp;\mathbf{y^丶}&amp;\mathbf{z^丶}\\ |&amp;|&amp;|\end{bmatrix} = \begin{bmatrix}{n_x}^2(1-\cos\theta) + \cos\theta&amp;{n_x}{n_y}(1-\cos\theta) - {n_z}\sin\theta&amp;{n_x}{n_z}(1-\cos\theta) + {n_y}\sin\theta\\{n_x}{n_y}(1-\cos\theta)+{n_z}\sin\theta&amp;{n_y}^2(1-\cos\theta)+\cos\theta&amp;{n_y}{n_z}(1-\cos\theta)-{n_x}\sin\theta\\{n_x}{n_z}(1-\cos\theta)-{n_y}\sin\theta&amp;{n_y}{n_z}(1-\cos\theta)+{n_x}\sin\theta&amp;{n_z}^2(1-\cos\theta)+\cos\theta\end{bmatrix}$.</p><p>至此绕任意轴的三维旋转矩阵推导完毕.</p><h2 id="仿射变换和齐次坐标"><a href="#仿射变换和齐次坐标" class="headerlink" title="仿射变换和齐次坐标"></a>仿射变换和齐次坐标</h2><p>上一节中我们讨论了很多利用矩阵变换向量的例子，在二维空间中这些变换具有以下形式：</p><p>$\mathbf{x^丶} = m_{11}\mathbf{x} + m_{12}\mathbf{y}$</p><p>$\mathbf{y^丶} = m_{21}\mathbf{x} + m_{22}\mathbf{y}$</p><p>这种形式的变换都满足矩阵中某个元素和x，y的线性组合，原点(0,0)在线性变换下始终保持不变，这种变换我们称为“<strong>线性变换</strong>”。但无法通过这种方式实现平移。平移只能添加额外的表达式，无法在一个矩阵中完成。如下：</p><p>$\begin{bmatrix}<br>    x^丶\\ y^丶<br>\end{bmatrix}$ = $\begin{bmatrix}<br>    a&amp;b\\ c&amp;d<br>\end{bmatrix}$ $\begin{bmatrix}<br>    x\\ y<br>\end{bmatrix}$ + $\begin{bmatrix}<br>    t_x\\ t_y<br>\end{bmatrix}$</p><p>这种变换方式称为“<strong>仿射变换($Affine Transformations$)</strong>”。简而言之就是“线性变换” + “平移”。这种方式存在的问题就是写法过于繁琐，不简洁，无法在一个矩阵中完成。因此引入了“齐次坐标”的概念。</p><h3 id="齐次坐标（Homogenous-Coordinates）"><a href="#齐次坐标（Homogenous-Coordinates）" class="headerlink" title="齐次坐标（Homogenous Coordinates）"></a>齐次坐标（Homogenous Coordinates）</h3><p>无法通过$\begin{bmatrix}x\\ y\end{bmatrix}$乘以一个2 × 2的矩阵来实现平移。 一个在线性变换矩阵中加入平移的可能性方案是简单地将一个单独的平移列添加到变换矩阵中，让矩阵负责缩放和旋转而平移列负责平移操作。</p><p>这样就可以通过一次简单的矩阵乘法完成所有变换操作。方法是将点$\begin{bmatrix}x\\ y\end{bmatrix}$增加额外的维度（$\mathbf{w}$分量）$\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$来表达。矩阵增加额外的一列用于表示平移，这样平移分量和x y的线性关系完全独立出来了。</p><p>$\begin{bmatrix}<br>    x^丶\\  y^丶\\ 1<br>\end{bmatrix}$ = $\begin{bmatrix}<br>    m_{11}&amp;m_{12}&amp;t_x\\ m_{21}&amp;m_{22}&amp;t_y\\ 0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$ = $\begin{bmatrix}<br>    m_{11}x + m_{12}y + t_x\\ m_{21}x + m_{22}y + t_y\\ 1<br>\end{bmatrix}$.</p><p>这个单一的矩阵实现了一个线性变换 + 平移。这种变换叫做仿射变换，这种<br>通过添加额外维度实现仿射变换的方法被称为齐次坐标（(Roberts, 1965; Riesenfeld, 1981; Penna &amp; Patterson,1986）。</p><p>当我们需要变换的是向量时，表示方向或偏移量的向量不应该改变，可以简单的将$\mathbf{w}$分量设置为0.  </p><p>$\begin{bmatrix}<br>    1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ 0\end{bmatrix} = \begin{bmatrix}x\\ y\\ 0\end{bmatrix}$.</p><p>因此齐次坐标对于向量和点有不同的表达方式，向量的$\mathbf{w}$分量为0，而点的$\mathbf{w}$分量为1.</p><ol><li><p>$vector$: $\begin{bmatrix}x\\ y\\ 0\end{bmatrix}$</p></li><li><p>$pointer$: $\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$</p></li></ol><h3 id="齐次坐标的几何解释"><a href="#齐次坐标的几何解释" class="headerlink" title="齐次坐标的几何解释"></a>齐次坐标的几何解释</h3><p>接下来让我们从几何的视角观察齐次坐标代表的含义。<br>当在三维空间中做基于$z$的切变时，我们会得到如下形式：</p><p>$\begin{bmatrix}1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\ y\\ z\end{bmatrix} = \begin{bmatrix}x+{t_x}z\\ y+{t_y}z\\ z\end{bmatrix}$.</p><p>这种形式和我们在二维空间中做平移变换非常相似。仅仅是z所代表的含义不同。关键点来了，让我们把z设为1.得到了二维平移仿射变换：</p><p>$\begin{bmatrix}1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\ y\\ 1\end{bmatrix} = \begin{bmatrix}x+{t_x}\\ y+{t_y}\\ 1\end{bmatrix}$.<br><img src="9.gif" alt="alt"></p><p><strong>结论：低维度的仿射变换(<script type="math/tex">Affine\;Transformations</script>)可以被认为是高纬度的错切变换($Shearing\;Transformations$)</strong></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=3&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.scratchapixel.com/">scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（三）：矩阵</title>
      <link href="/2022/05/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5/"/>
      <url>/2022/05/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（三）：矩阵"><a href="#图形学的数学基础（三）：矩阵" class="headerlink" title="图形学的数学基础（三）：矩阵"></a>图形学的数学基础（三）：矩阵</h1><blockquote><p>不幸的是，没有人能够告诉我们矩阵是什么。你必须亲自去看看。 -墨菲斯《黑客帝国》</p></blockquote><p>矩阵在图形学中具有重要意义，它们主要用于描述两个坐标空间之间的转换关系，通过矩阵和向量相乘，可以将向量从某一坐标空间转换到另一个坐标空间。通过矩阵和矩阵相乘，可以描述一系列的变换动作。</p><h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>在线性代数中，矩阵是排列成行和列的矩形数字网格。矩阵可以定义为数字的二维数组。因此向量是标量的数组，而矩阵是向量的数组。</p><h3 id="矩阵维度和表示法"><a href="#矩阵维度和表示法" class="headerlink" title="矩阵维度和表示法"></a>矩阵维度和表示法</h3><p>通过计算矩阵包含的行数和列数来定义矩阵的大小，对于具有$r$行和$c$列的矩阵，称为 $r \times c$矩阵。<br>当希望引用矩阵中的各个元素时，可以使用下标表示法。符号$m_{ij}$表示矩阵$Mi行j列$对应的元素。需要注意的是，矩阵初始索引为1,并不是0.</p><h3 id="方阵（Square-Matrice）"><a href="#方阵（Square-Matrice）" class="headerlink" title="方阵（Square Matrice）"></a>方阵（Square Matrice）</h3><p>具有相同行数和列数的矩阵称为方形矩阵，方阵的对角元素是行和列索引相同的元素。例如 $3\times3$矩阵M的对角元素是$m_{11},m_{22},m_{33}$。<br>如果矩阵中所有的非对角元素都为零，则该矩阵为对角矩阵（Diagonal Matrix）。</p><h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>有一类特殊的对角矩阵叫单位矩阵（Identity Matrix）。其对角线上的值为1，其它元素均为0.单位矩阵记作$I$.单位矩阵有一个重要的性质，即它是矩阵乘法中的单位元素。如果将矩阵乘以单位矩阵，结果不变。单位矩阵对于矩阵的意义，相当于标量中的数字1.</p><h3 id="作为矩阵的向量"><a href="#作为矩阵的向量" class="headerlink" title="作为矩阵的向量"></a>作为矩阵的向量</h3><p>矩阵可以包含任何正数的行和列，包括一个，维数$n$的向量可以被视为$1\times n$矩阵，或者被视为$n\times 1$矩阵。$1\times n$矩阵称为行向量（$Row Vector$），$n\times 1$矩阵被称为列向量（$Column Vector$）</p><p>$1\times 3$矩阵 $\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}$</p><p>$3\times 1$矩阵 $\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h3 id="矩阵转置（Transpose）"><a href="#矩阵转置（Transpose）" class="headerlink" title="矩阵转置（Transpose）"></a>矩阵转置（Transpose）</h3><p>给定$r\times c$矩阵M，它的转置表示为$M^T$,是$c\times r$矩阵，其中列由M的行构成，即 $M^T_{ij} = M_{ji}$</p><p>$\begin{bmatrix}a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i\end{bmatrix}^T$ = $\begin{bmatrix}a&amp;d&amp;g\\b&amp;e&amp;h\\c&amp;f&amp;i\end{bmatrix}$</p><p>对于矢量，转置会将行矢量转换为列矢量，反之亦然。</p><h4 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h4><ul><li>对于任意矩阵转置的转置等于其自身：$(M^T)^T = M$</li><li>对于任意对角矩阵D，其转置等于自身：$D^T = D$</li></ul><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="矩阵与标量相乘"><a href="#矩阵与标量相乘" class="headerlink" title="矩阵与标量相乘"></a>矩阵与标量相乘</h3><p>矩阵$M$与标量$k$相乘，得到与M相同维度的矩阵。结果矩阵$k\textbf{M}$中的每个元素是$k$与$\textbf{M}$中对应元素的乘积。</p><p>$k\textbf{M} = k\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}km_{11}&amp;km_{12}&amp;km_{13}\\km_{21}&amp;km_{22}&amp;km_{23}\\km_{31}&amp;km_{32}&amp;km_{33}\end{bmatrix}$</p><h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><p>相较矩阵和标量乘法简单和宽松的定义，矩阵之间的相乘需要满足一定条件。具体规则如下：设矩阵$\textbf{A}为r \times m$, 矩阵$\textbf{B}为 n \times c$矩阵，只有当$m == n$时，$\textbf{A} \times \textbf{B}$才有意义。即第一个矩阵的列数等于第二个矩阵的行数，得到的结果为 $\textbf{C}为 r \times c$矩阵。</p><p><img src="1.jpg" alt="alt"></p><p>$\textbf{C}$中每个元素$\textbf{C}_{ij}$等于$\textbf{A}$的第i行与 $\textbf{B}$的第j列点乘的结果。</p><p>$\textbf{C}_{ij} = \sum\limits_{k=1}^{n} a_{ik}b_{kj}$</p><h4 id="矩阵相乘性质"><a href="#矩阵相乘性质" class="headerlink" title="矩阵相乘性质"></a>矩阵相乘性质</h4><ul><li>任何矩阵和单位矩阵相乘等于自身：$\textbf{MI} = \textbf{IM} = \textbf{M}$ </li><li>矩阵乘法不满足交换律：$\textbf{AB} ≠ \textbf{BA}$</li><li>矩阵乘法不满足结合律：$\textbf{ABC} = \textbf{A(BC)}$</li><li>两个矩阵乘积的转置等于两个矩阵分别转置以相反的顺序乘积：$(\textbf{AB})^T$ = $\textbf{B}^T\textbf{A}^T$</li></ul><h3 id="矩阵向量相乘"><a href="#矩阵向量相乘" class="headerlink" title="矩阵向量相乘"></a>矩阵向量相乘</h3><p>由于向量可以被认为只有一行（$Row Vector$）或者一列（$Column Vector$）的矩阵，因此可以将矩阵相乘的规则应用于向量矩阵相乘。</p><p><strong>当为行向量（$1 \times n$）时，可以与矩阵（$n \times m$）相乘，结果为$1 \times m$行向量。行向量与矩阵相乘时，向量位于左侧，矩阵位于右侧。</strong></p><p>$\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}xm_{11} + ym_{21} + zm_{31}&amp;xm_{12} + ym_{22} + zm_{32}&amp;xm_{13} + ym_{23} + zm_{33}\end{bmatrix}$</p><p><strong>当为列向量（$n \times 1$）时，可以与矩阵（$m \times n$）相乘，结果为$m \times 1$列向量。列向量与矩阵相乘时，向量位于右侧，矩阵位于左侧。</strong></p><p>$\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix} = \begin{bmatrix}xm_{11} + ym_{12} + zm_{13}\\xm_{21} + ym_{22} + zm_{23}\\xm_{31} + ym_{32} + zm_{33}\end{bmatrix}$</p><ol><li>结果向量中每个元素是原始向量与矩阵中的单个行或者列的点积。</li><li>矩阵中的每个元素决定输入向量中特定元素对输出向量的元素有多大的“权重”。</li><li>乘法的结果是矩阵的行或列的线性组合。</li></ol><h3 id="行向量与列向量"><a href="#行向量与列向量" class="headerlink" title="行向量与列向量"></a>行向量与列向量</h3><p>当对行向量应用多个变换时，可以从左到右依次对向量进行矩阵乘法。例如对向量$\vec{v}$应用变换$\textbf{A},\textbf{B},\textbf{C}$时，表示为：</p><p>$\vec{v}\textbf{ABC}$.</p><p>同理如果对列向量应用相同的变换,则相应的乘法被写为：</p><p>$\textbf{C}^T\textbf{B}^T\textbf{A}^T\vec{v}$.</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二）：标准正交基/坐标系</title>
      <link href="/2022/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/2022/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二）：标准正交基-坐标系"><a href="#图形学的数学基础（二）：标准正交基-坐标系" class="headerlink" title="图形学的数学基础（二）：标准正交基/坐标系"></a>图形学的数学基础（二）：标准正交基/坐标系</h1><h2 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h2><p>对于三维空间任意三个向量,如果它们满足</p><ul><li>$||\vec{u}|| = ||\vec{v}|| = ||\vec{w}|| = 1$</li><li>$\vec{u}.\vec{v} = \vec{v}.\vec{w} = \vec{u}.\vec{w} = 0$</li><li>$\vec{w} = \vec{u} \times \vec{v}$ (右手系)</li></ul><p>即向量长度都为1,相互垂直, 这样的三个向量构成的坐标系称为<strong>标准正交基</strong>,$\vec{u} ,\vec{v},\vec{w}$称为标准正交基的<strong>基矢量</strong>.</p><h2 id="为什么需要标准正交基"><a href="#为什么需要标准正交基" class="headerlink" title="为什么需要标准正交基"></a>为什么需要标准正交基</h2><p>定义这样的坐标系,带来的一点好处就是, 空间中任意一矢量,都可以分解到标准正交基的三个轴上,需要用到前边向量投影的相关知识. 即<strong>矢量可以表示为基矢量的线性组合</strong>.<br><img src="1.jpg" alt="alt"></p><p>$||\vec{b_⊥}|| = ||\vec{b}|| \cos\theta$</p><p>此时的$\vec{a}$为单位向量,即$||\vec{a}|| = 1$</p><p>因此 $||\vec{b_⊥}|| = ||\vec{b}||||\vec{a}|| \cos\theta = \mathbf{b}.\mathbf{a}$</p><p>重要结论:</p><p>$\vec{p} = (\vec{p}.\vec{u})\vec{u} + (\vec{p}.\vec{v})\vec{v} + (\vec{p}.\vec{w})\vec{w}$</p><p>$x = \vec{p}.\vec{u}$ </p><p>$y = \vec{p}.\vec{v}$</p><p>$z = \vec{p}.\vec{w}$</p><p><strong>将三维矢量表示为基矢量的线性组合</strong></p><p>$\vec{p} = x\vec{u} + y\vec{v} + z\vec{w}$</p><h2 id="多个坐标空间"><a href="#多个坐标空间" class="headerlink" title="多个坐标空间"></a>多个坐标空间</h2><p>在图形学中,我们经常发现需要使用多个坐标空间,例如世界空间, 对象空间, 相机空间等,定义多个坐标空间有什么意义?毕竟坐标系可以无限延伸,可以表达我们想要的任何东西.原因就在于,某些信息仅在特定的上下文环境(坐标系)中才是有意义的.这样做可以为开发提供很多便利.</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>世界坐标系($World Coordinate System$)是一个特殊的坐标系,它为所有其它要指定的坐标系建立了一个”全局”参考系.换句话说,我们可以用世界坐标空间来表达其它坐标空间的位置,但是我们不能用更大的外部坐标空间来表示世界坐标空间.<br><strong>非技术意义上, 世界坐标系建立了我们关心的”最大”坐标系,大多数情况下,它实际上并不是整个世界,而是由我们定义的.</strong></p><h3 id="对象空间"><a href="#对象空间" class="headerlink" title="对象空间"></a>对象空间</h3><p>对象空间($Object Space$)是与特定对象关联的坐标空间,每个对象都有自己独立的对象空间.当一个对象移动或者改变方向,与该对象关联的对象坐标空间被随之携带.因此它也会移动或改变方向.<br>在图形学中,对象空间也被称为模型空间, 因为模型顶点的坐标是相对于模型空间来表示.</p><h3 id="相机空间"><a href="#相机空间" class="headerlink" title="相机空间"></a>相机空间</h3><p>相机空间($Camera Space$)中, 相机位于原点, +x指向右侧, +z指向前方(指向屏幕),+y指向”向上”(此处按照左手系约定),如果右手系,则-z指向屏幕方向.</p><h3 id="直立空间"><a href="#直立空间" class="headerlink" title="直立空间"></a>直立空间</h3><p>对象的直立空间是是世界空间与其对象空间之间的”过渡”,因为直立空间的轴线与世界空间的轴线平行,而直立空间的原点则于与对象空间的原点重合.</p><p><img src="2.png" alt="alt"></p><p>图片来源《3D Math Primer for Graphics and Game Development, 2nd Edition》</p><p><strong>因此通过旋转可以实现直立空间和对象空间的转换,通过平移可以实现世界空间和直立空间的转换(lookAt矩阵)</strong></p><h2 id="标准正交基-1"><a href="#标准正交基-1" class="headerlink" title="标准正交基"></a>标准正交基</h2><p>在很多情况下，例如在计算相机的lookAt矩阵中，由于传入的$\mathbf{direction}$ $\mathbf{up}$ $\mathbf{right}$三个基向量不一定是归一化的，需要对三个向量进行正交化处理，这样才能组成标准正交基。<br>本文将介绍两种常见的矢量正交化方法。施密特正交化和矢量叉积。</p><h2 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h2><p>施密特正交化是求欧几里得空间正交基的一种方法.从欧式空间任意线性无关的向量组$\mathbf{\alpha_1},\mathbf{\alpha_2},…,\mathbf{\alpha_m}$出发，求得正交向量组 $\mathbf{\beta_1},\mathbf{\beta_2},…,\mathbf{\beta_m}$,再将正交向量组中每个向量归一化，得到一个标准正交向量组，这种方法称为施密特正交化。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>如果$\vec{x_1},\vec{x_2},…\vec{x_n}$是某向量空间的基，那么可以通过以下公式找到该向量空间中的n个两两正交的向量$\vec{v_1},\vec{v_2},…\vec{v_n}$</p><p><img src="3.jpg" alt="alt"></p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>施密特正交化主要利用了矢量点积的投影性质，可以将矢量分解为平行和垂直两个矢量。以下我们分别以二维向量空间和三维向量空间为例详细介绍施密特正交化的推导过程。</p><h4 id="二维向量空间的推导"><a href="#二维向量空间的推导" class="headerlink" title="二维向量空间的推导"></a>二维向量空间的推导</h4><ol><li>假设二维空间的任意向量$\vec{x_1}$ $\vec{x_2}$</li></ol><p><img src="4.png" alt="alt"></p><ol><li>任选其一作为$\vec{v_1}$,比如$\vec{x_1}$.利用向量点积，将$\vec{x_2}$在$\vec{v_1}$上投影。得到$\vec{x_⊥}$，根据向量的三角形法则，$\vec{x_∥} = \vec{x_2} - \vec{x_⊥}$即为要求的$\vec{v_2}$</li></ol><p><img src="5.jpg" alt="alt"></p><p>$\vec{v_1} = \vec{x_1}$</p><p>$\vec{x_⊥} = \dfrac{\vec{x_2}.\vec{v_1}}{||\vec{v_1}||} \hat{v_1} = \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}} \hat{v_1}||\vec{v_1}|| = \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}$</p><p>$\vec{v_2} = \vec{v_∥} = \vec{x_2} - \vec{x_⊥} = \vec{x_2} - \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}$</p><p>$\hat{v_1} = \dfrac{\vec{v_1}}{||\vec{v_1}||}$</p><p>$\hat{v_2} = \dfrac{\vec{v_2}}{||\vec{v_2}||}$</p><h4 id="三维向量空间的推导"><a href="#三维向量空间的推导" class="headerlink" title="三维向量空间的推导"></a>三维向量空间的推导</h4><p>三维向量空间的正交化推导与二维空间类似，假设三维空间的任意向量 $\vec{x_1}$ $\vec{x_2}$ $\vec{x_3}$.<br>先任选两个向量做二维空间的正交化，例如$\vec{x_1}$ $\vec{x_2}$,得到$\hat{v_1}$,$\hat{v_2}$.<br>将 $\vec{x_3}$在$\hat{v_1}$,$\hat{v_2}$所张成的二维平面上投影，得到$\vec{x_3⊥}$，由于$\vec{x_3⊥}$在$\hat{v_1}$,$\hat{v_2}$的张成平面上，所以$\vec{x_3⊥}$是$\hat{v_1}$,$\hat{v_2}$的线性组合。</p><p>$\vec{x_3⊥} = k_1\hat{v_1} + k_2\hat{v_2}$</p><p>$\vec{v_3} = \vec{x_3} - \vec{x_3⊥}$</p><p>$\vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2}$</p><p>由于$\vec{v_3}$垂直于$\hat{v_1}$和${\hat{v_2}}$, $\hat{v_1}$,${\hat{v_2}}$正交，因此：</p><p>$ \vec{v_3}.\hat{v_1} = 0$</p><p>$\vec{v_3}.\hat{v_2} = 0$</p><p>$\hat{v_2}.\hat{v_1} = 0$</p><p>由此可以推导出：</p><p>$\vec{v_3}.\hat{v_1} = (\vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2}).\hat{v_1} = 0$</p><p>$\vec{x_3}.\hat{v_1} - k_1\hat{v_1}.\hat{v_1} - k_2\hat{v_2}.\hat{v_1} = 0 $</p><p>$\vec{x_3}.\hat{v_1} - k_1\hat{v_1}.\hat{v_1} = 0 $</p><p>$k_1 = \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}$</p><p>同理可得出： $k_2 = \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}$</p><p>$\vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2} = \vec{x_3} - \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}\hat{v_1} - \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}\hat{v_2}$</p><h2 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h2><p>假设三维空间中的三个向量$\vec{x_1}$ $\vec{x_2}$ $\vec{x_3}$.下边我们使用向量叉乘的方法对对其正交化。</p><ul><li><p>任选其一作为$\vec{v_1}$,例如$\vec{x_1}$ </p><p>  $\vec{v_1} = \vec{x_1}$</p></li><li><p>任选另外两个向量其一和$\vec{v_1}$叉乘例如$\vec{v_1} \times \vec{x_2}$ 得到$\vec{v_3}$</p><p>   $\vec{v_3} = \vec{v_1} \times \vec{x_2}$</p></li><li><p>用$\vec{v_3}和\vec{v_1}$叉乘得到$\vec{v_2}$</p><p>  $\vec{v_2} = \vec{v_3} \times \vec{x_1}$</p></li><li><p>$\hat{v_1} = \dfrac{\vec{v_1}}{||\vec{v_1}||}$  $\hat{v_2} = \dfrac{\vec{v_2}}{||\vec{v_2}||}$  $\hat{v_3} = \dfrac{\vec{v_3}}{||\vec{v_3}||}$</p></li></ul><p>至此通过以上几个步骤，完成了矢量的正交化。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/485838766">如何理解施密特正交化</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（一）：向量</title>
      <link href="/2022/05/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F/"/>
      <url>/2022/05/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（一）：向量"><a href="#图形学的数学基础（一）：向量" class="headerlink" title="图形学的数学基础（一）：向量"></a>图形学的数学基础（一）：向量</h1><h2 id="前边的话"><a href="#前边的话" class="headerlink" title="前边的话"></a>前边的话</h2><p>本系列是阅读《3D数学基础： 图形和游戏开发（第二版）》整理汇总的学习笔记，整个系列的结构排布基于原书的章节安排，针对其中的每个知识点做了适当的补充和拓展，其中不免有遗漏和错误之处，望各位读者批评指正。本篇文章做为该系列的第一章，主要介绍向量相关内容，涉及空间中向量的几何意义，各种运算，重点介绍点乘和叉乘的几何解释及在图形学中的应用场景。</p><h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>对于数学家来说向量是一个数组，数组的长度代表向量所在的空间维度。程序中表示向量通常有两种方式，行向量（$Row Vector$）和列向量（$Column Vector$）,至于为什么要区分两种书写方式,我们放到矩阵章节再详细说明.</p><p>$V_{column} = \begin{bmatrix}1\\ 2\\ 3\end{bmatrix}$</p><p>$V_{row} = \begin{bmatrix}1&amp;2&amp;-1\end{bmatrix}$</p><h2 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h2><p>从几何学上讲,向量是具有大小和方向的<strong>有向线段</strong>.讨论向量在空间中的哪个位置,是没有意义的,<strong>向量不具备位置属性</strong>.向量是一种相对偏移量的表示方法.如下图二维笛卡尔坐标系中,向量U和V是相等的.</p><ul><li>大小: 矢量的长度,矢量可以具有任何非负长度.</li><li>方向:空间中指定的方向.</li></ul><p><img src="1.jpg" alt="alt"></p><h2 id="笛卡尔坐标系下的向量"><a href="#笛卡尔坐标系下的向量" class="headerlink" title="笛卡尔坐标系下的向量"></a>笛卡尔坐标系下的向量</h2><p>当使用笛卡尔坐标来描述向量时,每个坐标将度量相应维度中有符号位移.</p><p><img src="2.jpg" alt="alt"></p><h2 id="向量与点的关系"><a href="#向量与点的关系" class="headerlink" title="向量与点的关系"></a>向量与点的关系</h2><p>点用于描述空间中的某一位置.向量用于描述空间中的一段位移,表达相对位置.那么点与向量之间有着怎样的关系呢?两者之间如何完成相互转换?其实很简单,本质上就一句话,<strong>任何点都可以表示为来自原点的向量</strong>.从原点开始按照向量[x,y]指定的量移动,最终会抵达点(x,y)所描述的位置, 同理向量[x,y]给出了从原点到点(x,y)的位移.</p><h2 id="向量基础运算"><a href="#向量基础运算" class="headerlink" title="向量基础运算"></a>向量基础运算</h2><h3 id="标量和向量的乘法"><a href="#标量和向量的乘法" class="headerlink" title="标量和向量的乘法"></a>标量和向量的乘法</h3><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>标量与向量的乘法，只需要用标量乘以矢量的每个分量即可。</p><p>$k\begin{bmatrix}x\\ y\\ z\end{bmatrix} = \begin{bmatrix}x\\ y\\ z\end{bmatrix}k = \begin{bmatrix}kx\\ ky\\ kz\end{bmatrix}$</p><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>将向量乘以标量k具有将向量的长度按照因数|k|缩放的效果.例如为了使向量长度加倍,可以将向量乘以2;如果k &lt; 0,则翻转向量的方向.</p><h3 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h3><h4 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h4><p>两个向量相加等于它们相应的分量相加得到的向量.向量不能和标量相加或者相减, 也不能和不同维度的向量进行加减运算.向量的减法可以理解为加一个负向量.</p><h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p>我们可以按照几何形式将向量相加,方法是定位向量使得各向量的头尾相连, 然后绘制一条从第一条向量尾部到最后一条向量头部的向量,即为相加的结果向量.如下图:</p><p>$\vec{e} = \vec{a} + \vec{b} + \vec{c} + \vec{d}$</p><p><img src="4.jpg" alt="alt"></p><h3 id="向量大小"><a href="#向量大小" class="headerlink" title="向量大小"></a>向量大小</h3><p>向量的大小也成为向量的长度(Length)或范数(Norm),在数学中通常使用围绕向量的双垂直直线来表示.$||\mathbf{v}||$</p><h4 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h4><p><strong>向量的大小是向量分量的平方和的平方根.</strong></p><p>$||\mathbf{v}|| = \sqrt{\sum\limits_{i=1}^n{v_i}^2}$</p><h4 id="几何意义-2"><a href="#几何意义-2" class="headerlink" title="几何意义"></a>几何意义</h4><p>以二维向量为例, 任何向量v(除去0向量)可以形成一个直角三角形,其中v作为斜边,v向量的两个分量作为直角边.根据毕达哥拉斯定理,对于任何直角三角形,斜边的长度的平方等于另外两边长度的平方和.</p><p>$||\mathbf{v}|| = \sqrt{ {v_x}^2 + {v_y}^2}$</p><p><img src="5.jpg" alt="alt"></p><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><p>对于许多向量,我们只关心其方向性,使用单位向量通常会很方便(点乘),单位向量是大小(Norm)为1的向量,单位向量也被称为归一化的向量($Normalized Vector$).</p><h4 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h4><p>对于任何非零向量,可以计算出指向v相同方向的单位向量,此过程称为向量的归一化(normalize).为了归一化向量,可以将向量除以其大小:</p><p>${v_i} = \dfrac{\mathbf{v}}{||\mathbf{v}||}$</p><h4 id="几何意义-3"><a href="#几何意义-3" class="headerlink" title="几何意义"></a>几何意义</h4><p>以二维向量为例,将单位向量尾部固定在原点,则向量头部将接触到以原点为中心的单位圆(半径为1).三维中,单位向量接触到的是单位球面(半径为1).</p><h3 id="两点距离"><a href="#两点距离" class="headerlink" title="两点距离"></a>两点距离</h3><p>两点之间的距离本质上是求从一点到另外一点向量的长度,根据向量的三角形法则.可以得到:</p><p><img src="3.jpg" alt="alt"></p><p>$\mathbf{d} = \mathbf{b} - \mathbf{a}$</p><p>$\mathbf{d} = \begin{bmatrix}b_x - a_x\\b_y - a_y\end{bmatrix}$</p><p>$\textbf{distance}(\mathbf{a},\mathbf{b}) = ||\mathbf{d}|| = \sqrt{ {d_x}^2 + {d_y}^2 }$</p><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积($Dot Product$)是向量乘法中比较简单的一种(另外一种叫做叉积),但是点积在图形学中应用非常广泛,与许多其它运算有重要的关系,例如矩阵乘法、信号卷积、统计相关、和傅里叶变换等。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>向量点积等于两个向量的长度相乘再乘以其夹角余弦.</strong></p><p><img src="9.jpg" alt="alt"></p><p>$\mathbf{a}\cdot\mathbf{b} = ||\mathbf{a}|| ||\mathbf{b}||\cos{\theta}$</p><p>推导:</p><p>$\cos\theta = \dfrac{\mathbf{a}\cdot\mathbf{b}}{||\mathbf{a}|| ||\mathbf{b}||}$</p><p>对于单位向量来说<br>$\cos\theta = \mathbf{a}\cdot\mathbf{b}$</p><h3 id="公式-4"><a href="#公式-4" class="headerlink" title="公式"></a>公式</h3><p><strong>两个向量的点积是相应分量的乘积之和，得到的结果是一个标量</strong>，因此也叫做标量乘法(Scalar Product)。</p><p>$\mathbf{a}.\mathbf{b} = \sum\limits_{i=1}^na_ib_i$</p><p>二维和三维向量点积</p><p>$\mathbf{a}.\mathbf{b} = a_xb_x + a_yb_y$</p><p>$\mathbf{a}.\mathbf{b} = a_xb_x + a_yb_y + a_zb_z$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>交换律</p><p>  $\mathbf{a}.\mathbf{b} = \mathbf{b}.\mathbf{a}$</p></li><li><p>结合律</p><p>  $(k\mathbf{a}).\mathbf{b} = \mathbf{a}.(k\mathbf{b}) = k(\mathbf{a}.\mathbf{b})$</p></li></ul><ul><li><p>分配律</p><p>   $\mathbf{a}.(\mathbf{b} + \mathbf{c}) = \mathbf{a}.\mathbf{b} + \mathbf{a}.\mathbf{c}$</p></li></ul><h3 id="几何意义-4"><a href="#几何意义-4" class="headerlink" title="几何意义"></a>几何意义</h3><p>向量点积的几何意义对于我们来说至关重要,因为涉及到图形学的方方面面,以下我们将从两个方面进行探讨.</p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p><strong>点积$\mathbf{a}.\mathbf{b}$等于$\mathbf{b}$投影到平行于$\mathbf{a}$的直线上的有符号号长度,乘以$\mathbf{a}$的长度.</strong><br>如何理解这句话呢?根据点积的定义及直角三角形余弦定理我们得知</p><p>$\mathbf{a}.\mathbf{b} = ||\mathbf{a}|| ||\mathbf{b}||\cos\theta$</p><p>-&gt;</p><p>$||\mathbf{b_⊥}|| = \cos\theta ||\mathbf{b}||$</p><p>-&gt;</p><p>$\mathbf{b_⊥} = ||\mathbf{b_⊥}||\hat{a} = \cos\theta||\mathbf{b}||\hat{a}$</p><p>-&gt;</p><p>$\mathbf{a}\cdot\mathbf{b} = ||\mathbf{a}||||\mathbf{b}|| \cos\theta = ||\mathbf{b_⊥}|| ||  \mathbf{a}||$</p><p><img src="6.jpg" alt="alt"></p><h4 id="分解向量"><a href="#分解向量" class="headerlink" title="分解向量"></a>分解向量</h4><p>根据上小节向量投影的介绍我们能够得到$\mathbf{b}$向量在$\mathbf{a}$向量上的投影向量,因此我们可以将$\mathbf{b}$向量进行分解,其中一条沿着$\mathbf{a}$方向即$\mathbf{b_⊥}$,另外一条垂直于$\mathbf{a}$向量,即$\mathbf{b_∥}$,如下图所示</p><p><img src="7.jpg" alt="alt"></p><p>$\mathbf{b_⊥} = ||\mathbf{b_⊥}|| \hat{a} = \cos\theta ||\mathbf{b}|| \hat{a}$</p><p>$\mathbf{b_∥} = \mathbf{b} - \mathbf{b_⊥}$</p><h4 id="向量大小于点积的关系"><a href="#向量大小于点积的关系" class="headerlink" title="向量大小于点积的关系"></a>向量大小于点积的关系</h4><p>$\mathbf{v}.\mathbf{v} = ||\mathbf{v}||^2$</p><h4 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h4><ol><li><strong>点积的符号可以给予我们对两个向量相对方向的粗略分类</strong></li></ol><p><img src="8.jpg" alt="alt"></p><ol><li>两个单位向量的点积等于夹角的余弦.</li></ol><p>$\hat{a}\cdot\hat{b} = \cos\theta$</p><ol><li>使用点积计算两个向量之间的角度</li></ol><p>$\theta = \arccos(\dfrac{\mathbf{a}\cdot\mathbf{b}}{||\mathbf{a}||||\mathbf{b}||})$</p><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积是另一种向量乘积，与上节讲到的点积不同，叉积的结果是一个向量，该向量垂直于原始的两个向量，即垂直于原始两个向量所构成的平面。</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="10.jpg" alt="alt"></p><ul><li><p>$\mathbf{a} \times \mathbf{b}$将产生一个垂直于$\mathbf{a}$和$\mathbf{b}$所构成平面的向量，这样的向量可能有两个，彼此方向相反，朝向由右手螺旋定则判定，具体在后文会详细介绍。</p></li><li><p><strong>$\mathbf{a} \times \mathbf{b}$的长度等于$\mathbf{a}$和$\mathbf{b}$长度的乘积再乘以$\mathbf{a}$和$\mathbf{b}$之间角度的正弦值。</strong></p><p>  $||\mathbf{a} \times \mathbf{b}|| = ||\mathbf{a}|||| \mathbf{b} || \sin\theta$</p></li></ul><p>实际上根据定义不难理解， $\mathbf{a} \times \mathbf{b}$的长度等于由两个边$\mathbf{a}$ $\mathbf{b}$所形成的平行四边形的面积。</p><p>$\textbf{A} =  bh = b(a\sin\theta) = ||\mathbf{a}||||\mathbf{b}||\sin\theta = ||\mathbf{a} \times \mathbf{b}||$</p><p><img src="11.jpg" alt="alt"></p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ul><li>叉积交换的，实际上，它是反交换的（anticommutative）的：$\mathbf{a} \times \mathbf{b} = - (\mathbf{b} \times \mathbf{a})$</li><li>向量自身的叉积等于零向量 $ \mathbf{a} \times \mathbf{a} = \vec{0} $</li><li>叉积满足分配律：$ \mathbf{a} \times(\mathbf{b} + \mathbf{c}) = \mathbf{a} \times \mathbf{b} + \mathbf{a} \times \mathbf{c} $</li><li>叉积满足结合律：$ \mathbf{a} \times (k\mathbf{b}) = k(\mathbf{a} \times \mathbf{b})$</li></ul><h2 id="右手螺旋定则"><a href="#右手螺旋定则" class="headerlink" title="右手螺旋定则"></a>右手螺旋定则</h2><p>先将两向量移动到同一起点，右手四指从A转动到B，则拇指所指方向，即为结果向量的方向。<br>符合右手螺旋定则的坐标系称之为右手坐标系，即 $\vec{x} \times \vec{y} = \vec{z}$,否则为左手系。</p><p><img src="12.jpg" alt="alt"></p><p>$\vec{x} \times \vec{y} = +\vec{z}$</p><p>$\vec{y} \times \vec{x} = -\vec{z}$</p><p>$\vec{y} \times \vec{z} = +\vec{x}$</p><p>$\vec{z} \times \vec{y} = -\vec{x}$</p><p>$\vec{z} \times \vec{x} = +\vec{y}$</p><p>$\vec{x} \times \vec{z} = -\vec{y}$</p><h2 id="几何意义-5"><a href="#几何意义-5" class="headerlink" title="几何意义"></a>几何意义</h2><h3 id="判定两向量的相对位置关系"><a href="#判定两向量的相对位置关系" class="headerlink" title="判定两向量的相对位置关系"></a>判定两向量的相对位置关系</h3><p>向量叉积可以判定两个向量的相对位置关系，比如我们想知道一个向量在另外一个的左侧还是右侧，可以通过两个向量叉积结果的符号来判断。</p><p>$\mathbf{a} \times \mathbf{b}  = + \mathbf{z}$<br>因此$\mathbf{b}在\mathbf{a}的左侧$</p><p><img src="13.jpg" alt="alt"></p><h3 id="判定点是否在三角形内"><a href="#判定点是否在三角形内" class="headerlink" title="判定点是否在三角形内"></a>判定点是否在三角形内</h3><p>分别使用三角形的三边向量 $\vec{AB}$ $\vec{BC}$ $\vec{CA}$，叉乘三角形每个顶点与P点构成的向量，如果得到的三个结果向量方向一致，则认为P点在三角形 $\triangle{ABC}$内,否则P点在三角形外。</p><p>$\vec{AB} \times \vec{AP}$</p><p>$\vec{BC} \times \vec{BP}$</p><p>$\vec{CA} \times \vec{CP}$</p><p><img src="14.png" alt="alt"></p><h3 id="构造三维直角坐标系"><a href="#构造三维直角坐标系" class="headerlink" title="构造三维直角坐标系"></a>构造三维直角坐标系</h3><p>$\vec{x} \times \vec{y} = \vec{z}$</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数函数和对数函数</title>
      <link href="/2022/04/03/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/03/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="指数法则"><a href="#指数法则" class="headerlink" title="指数法则"></a>指数法则</h2><blockquote><ol><li><p>$b^0=1$</p></li><li><p>$b^1=b$</p></li><li><p>$b^xb^y=b^{x+y}$</p></li><li><p>$\frac{b^x}{b^y}=b^{x-y}$</p></li><li><p>$(b^x)^y=b^{xy}$</p></li></ol></blockquote><h2 id="对数法则"><a href="#对数法则" class="headerlink" title="对数法则"></a>对数法则</h2><blockquote><ol><li><p>$b^{\log_by}=y$</p></li><li><p>$\log_b1=0$</p></li><li><p>$\log_bb=1$</p></li><li><p>$\log_b{(xy)}=\log_bx+\log_by$</p></li><li><p>$\log_b(\frac{x}{y})=\log_bx-\log_by$</p></li><li><p>$\log_b(x^y)=y\log_bx$</p></li><li><p>$\log_bx=\frac{\log_cx}{\log_cb}$</p></li><li><p>$\log_xy=\frac{1}{\log_yx}$</p></li></ol></blockquote><h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><p>关于e的四个定义:</p><blockquote><p>$\lim_{h \to \infty}(1+\frac{r}{h})^h=e^r$</p><p>$\lim_{h \to 0}(1+rh)^{\frac{1}{h}}=e^r$</p><p>$\lim_{h \to \infty}(1+\frac{1}{h})^h=e$</p><p>$\lim_{h \to 0}(1+h)^{\frac{1}{h}}=e$</p><h1 id="对数函数和指数函数求导"><a href="#对数函数和指数函数求导" class="headerlink" title="对数函数和指数函数求导"></a>对数函数和指数函数求导</h1></blockquote><h2 id="对数函数和指数函数求导-1"><a href="#对数函数和指数函数求导-1" class="headerlink" title="对数函数和指数函数求导"></a>对数函数和指数函数求导</h2><p>$令f(x)=\log_bx$</p><p>根据导数定义可知</p><p>$f’(x)=\lim_{h \to 0}\frac{\log_b(x+h)-\log_bx}{h}$</p><p>$f’(x)=\lim_{h \to 0}\frac{1}{h}(\log_b(\frac{x+h}{x}))$</p><p>$f’(x)=\lim_{h \to 0}\log_b((\frac{x+h}{x})^{\frac{1}{h}})$</p><p>$f’(x)=\lim_{h \to 0}\log_b((1+\frac{h}{x})^{\frac{1}{h}})$</p><p>$f’(x)=\log_b(e^{\frac{1}{x}})=\frac{1}{x}\log_be=\frac{1}{x\ln_b}$</p><p>以上可以推导出</p><blockquote><p>$\frac{\mathrm{d}}{\mathrm{d}x}\log_bx=\frac{1}{x\ln_b}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}\ln_x=\frac{1}{x}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}b^x=b^x\ln_b$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}e^x=e^x$</p></blockquote><h1 id="对数函数和指数函数的极限"><a href="#对数函数和指数函数的极限" class="headerlink" title="对数函数和指数函数的极限"></a>对数函数和指数函数的极限</h1><h1 id="取对数求导法"><a href="#取对数求导法" class="headerlink" title="取对数求导法"></a>取对数求导法</h1><p>$处理像f(x)^{g(x)}这种底数和指数均有x的函数的导数问题时,取对数求导法是个很有用的技巧.$</p><p>$令f(x)=x^x,根据对数法则$</p><p>$\ln_(x^x)=x\ln_x=\ln_y$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}\ln_y=\ln_x+x\frac{1}{x}$</p><p>$\frac{1}{y}\frac{\mathrm{d}y}{\mathrm{d}x}=\ln_x+1$</p><p>$\frac{\mathrm{d}y}{\mathrm{d}x}=(\ln_x+1)x^x$</p><h1 id="指数增长和指数衰变"><a href="#指数增长和指数衰变" class="headerlink" title="指数增长和指数衰变"></a>指数增长和指数衰变</h1><h2 id="指数增长"><a href="#指数增长" class="headerlink" title="指数增长"></a>指数增长</h2><p>假设$y=e^{kx}$,那么$\frac{\mathrm{d}y}{\mathrm{d}x}=ke^{kx}=ky$</p><blockquote><p>如果$\frac{\mathrm{d}y}{\mathrm{d}x}=ky,那么y=Ae^{kx},其中A为某个常数$</p></blockquote><p>这意味着,y的变化率等于ky.一个量变化的速率取决于这个量的大小.如果这个量越大, 那么它就会增长得越快(假设 k &gt; 0).</p><blockquote><p>指数增长方程: $P(t)=P_0e^{kt},其中P_0是初始的总数,k是增长常数$</p></blockquote><h2 id="指数衰变"><a href="#指数衰变" class="headerlink" title="指数衰变"></a>指数衰变</h2><blockquote><p>指数衰变方程: $P(t)=P_0e^{-kt}$</p></blockquote><h1 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h1><h2 id="双曲余弦函数-双曲正弦函数"><a href="#双曲余弦函数-双曲正弦函数" class="headerlink" title="双曲余弦函数 双曲正弦函数"></a>双曲余弦函数 双曲正弦函数</h2><p><img src="1.jpg" alt="alt"></p><blockquote><p>$coshx=\frac{e^x+e^{-x}}{2}$</p><p>$sinhx=\frac{e^x-e^{-x}}{2}$</p><p>$cosh^2(x)-sinh^2(x)=1$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}sinhx=coshx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}coshx=sinhx$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数的极限和导数</title>
      <link href="/2022/04/02/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/"/>
      <url>/2022/04/02/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="三角函数的极限"><a href="#三角函数的极限" class="headerlink" title="三角函数的极限"></a>三角函数的极限</h1><h2 id="小数的情况"><a href="#小数的情况" class="headerlink" title="小数的情况"></a>小数的情况</h2><blockquote><p>${\lim_{x \to 0} \frac{sinx}{x}} = 1$</p><p>$\lim_{x \to 0} cosx = 1$</p><p>$\lim_{x \to 0} \frac{tanx}{x} = 1$</p><p>$\lim_{x \to 0} \frac{1-cosx}{x} = 0$</p></blockquote><h2 id="大数的情况"><a href="#大数的情况" class="headerlink" title="大数的情况"></a>大数的情况</h2><p>考虑极限$\lim_{x \to \infty}$</p><p>对于任意的x $-1 &lt;= sinx &lt;=1$  $-1 &lt;=cosx &lt;= 1$</p><p>应用三明治定理 $\lim_{x \to \infty} \frac{sinx}{x} = 0$</p><h2 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h2><p>考虑极限$\lim_{x \to \frac{\pi}{2}}\frac{cosx}{x-\frac{\pi}{2}}$<br>这次的三角函数是余弦, 且要在 π/2 的附近求值. 这既不是小数的情况也不是大数的情况, 因此很明显, 之前的情况都不适用.<strong><em>面对 x → a 的极限, 而a != 0 时, 有一个很好的一般原则, 那就是用 t = x − a作替换, 将问题转化为 t→0</em></strong></p><p>$\lim_{x \to \frac{\pi}{2}}\frac{cosx}{x-\frac{\pi}{2}}$</p><p>$\lim_{t \to 0}\frac{cos(t+\frac{\pi}{2})}{t}$</p><p>$cos(\frac{\pi}{2}+t) = sin(-t) = -sint$</p><p>$\lim_{t \to 0}\frac{-sint}{t} = -1$</p><h1 id="三角函数的导数"><a href="#三角函数的导数" class="headerlink" title="三角函数的导数"></a>三角函数的导数</h1><blockquote><p>$\frac{\mathrm{d}}{\mathrm{d}x}sinx = cosx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cosx = -sinx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}tanx = (secx)^2$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}secx = secxtanx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cscx = -cscxcotx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cotx = -(cscx)^2$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续性和可导性</title>
      <link href="/2022/03/30/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E5%8F%AF%E5%AF%BC%E6%80%A7/"/>
      <url>/2022/03/30/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E5%8F%AF%E5%AF%BC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h1><p>我们先从一个函数是连续的, 这到底意味着什么开始. 正如我上面所说, 直觉上, 可以一笔画出连续函数的图像.</p><h2 id="在一点处的连续"><a href="#在一点处的连续" class="headerlink" title="在一点处的连续"></a>在一点处的连续</h2><p>如果f(x)在a点连续,则必须满足以下三个条件:</p><ul><li>双侧极限${\lim_{x \to a} f(x)}$存在并且是有限的</li><li>函数在点a处有定义,$f(a)$存在并且是有限的</li><li>以上两个量相等,即: ${\lim_{x \to a} f(x) = f(x)}$</li></ul><h2 id="在一个区间上连续"><a href="#在一个区间上连续" class="headerlink" title="在一个区间上连续"></a>在一个区间上连续</h2><p>函数f在[a, b] 上连续,需满足以下三个条件:</p><ul><li>f在(a,b)的每一点都连续</li><li>函数f在x = a处右连续,即 ${\lim_{x \to a^+} f(x)} = f(a)$</li><li>函数f在x = b处左连续,即 ${\lim_{x \to b^-} f(x)} = f(b)$</li></ul><p><strong><em>★介值定理</em></strong></p><blockquote><p>$如果f(x)在[a, b]上连续, 并且f(a) &lt; 0且f(b) &gt; 0,那么在区间(a, b) 上至少有一点 c, 使得 f(c) = 0. 代之以 f(a) &gt; 0 且 f(b) &lt; 0, 同样成立.$</p></blockquote><p><strong><em>★最大值与最小值定理</em></strong></p><blockquote><p>如果f(x)在[a, b]上连续, 那么f(x)在[a, b]上至少有一个最大值和一个最小值.</p></blockquote><h1 id="求解微分常用技巧"><a href="#求解微分常用技巧" class="headerlink" title="求解微分常用技巧"></a>求解微分常用技巧</h1><h2 id="使用定义求导"><a href="#使用定义求导" class="headerlink" title="使用定义求导"></a>使用定义求导</h2><p>根据导数的定义:<br>$f’(x) = \lim_{h \to 0}\frac{f(x+h) - f(x)}{h}$</p><p>$例如:对于 f(x) = \frac{1}{x}$</p><p>$f’(x) = \lim_{h \to 0}\frac{\frac{1}{x+h} - \frac{1}{x}}{h}$</p><p>$f’(x)=\lim_{h \to 0}\frac{\frac{x-(x+h)}{x(x+h)}}{h}=\lim_{h \to 0}\frac{-h}{hx(x+h)}=-\frac{1}{x^2}$</p><blockquote><p>$\frac{d}{dx}(\frac{1}{x})=-\frac{1}{x^2}$</p><p>$\frac{d}{dx}\sqrt{x}=\frac{1}{2\sqrt{x}}$</p><p>$\frac{d}{dx}x^a=ax^{a-1}$</p></blockquote><h2 id="函数的常数倍"><a href="#函数的常数倍" class="headerlink" title="函数的常数倍"></a>函数的常数倍</h2><p>处理一个函数的常数倍时,只需要用常数乘以该函数的导数就可以了.</p><blockquote><p>$\frac{d}{dx}Cf(x)=Cf’(x)$</p></blockquote><h2 id="函数和与函数差"><a href="#函数和与函数差" class="headerlink" title="函数和与函数差"></a>函数和与函数差</h2><p>对函数和与函数差求导,需要对每一部分求导然后再相加或者相减.</p><blockquote><p>$\frac{d}{dx}(f(x) + g(x))=f’(x)+g’(x)$</p></blockquote><h2 id="乘积法则"><a href="#乘积法则" class="headerlink" title="乘积法则"></a>乘积法则</h2><blockquote><p>$乘积法则(版本一):如果h(x)=f(x)g(x)那么 h’(x)=f’(x)g(x)+f(x)g’(x)$</p><p>$乘积法则(版本二):如果y=uv, 则 \frac{dy}{dx}=v\frac{du}{dx}+u\frac{dv}{dx}$</p></blockquote><h2 id="商法则"><a href="#商法则" class="headerlink" title="商法则"></a>商法则</h2><blockquote><p>$商法则(版本一):如果h(x)=\frac{f(x)}{g(x)},那么h’(x)=\frac{f’(x)g(x)-f(x)g’(x)}{g(x)^2}$</p><p>$商法则(版本二):如果y=\frac{u}{v},那么\frac{dy}{dx}=\frac{v\frac{du}{dx}-u\frac{dv}{dx}}{v^2}$</p></blockquote><h2 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h2><blockquote><p>$链式求导法则(版本一):如果h(x)=f(g(x)),那么h’(x)=f’(g(x))g’(x)$</p><p>$链式求导法则(版本二):如果y是u的函数,并且u是x的函数,那么\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$</p></blockquote><h1 id="切线方程"><a href="#切线方程" class="headerlink" title="切线方程"></a>切线方程</h1><ul><li>求斜率:通过导函数并带入给定的x值,求x点的斜率m</li><li>求直线上的一个点:通过将给定的x值带入原始函数本身得到y0值得到(x0, y0)</li><li>使用点斜式 $y-y0=m(x-x0)$</li></ul><h1 id="导数伪装的极限"><a href="#导数伪装的极限" class="headerlink" title="导数伪装的极限"></a>导数伪装的极限</h1><p>考虑求解以下极限<br>$\lim_{h \to 0}\frac{\sqrt[5]{32+h}-2}{h}$</p><p>它和以下公式非常相似:</p><p>$f’(x) = \lim_{h \to 0}\frac{f(x+h)-f(x)}{h}$</p><p>$假设f(x)=\sqrt[5]{x},则f’(x)=\lim_{h \to 0}\frac{\sqrt[5]{x+h}-\sqrt[5]{x}}{h}=\frac{1}{5}x^{\frac{-4}{5}}$<br>$设x = 32 = 2^5$</p><p>$由此可知问题可以转换为函数f(x)=\sqrt[5]{x}在x = 32时的导数即 \frac{1}{5}32^{\frac{-4}{5}}$</p><h1 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h1><p>考虑方程$x^2 + y^2 = 4$,求$\frac{\mathrm{d}y}{\mathrm{d}x}$,对等号两边同时添加一个$\frac{\mathrm{d}}{\mathrm{d}x}$,<br>$\frac{\mathrm{d}}{\mathrm{d}x}{(x^2 + y^2)} = \frac{\mathrm{d}}{\mathrm{d}x}{4}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}{x^2} + \frac{\mathrm{d}}{\mathrm{d}x}{y^2} = 0$</p><p>$2x +2y\frac{\mathrm{d}y}{\mathrm{d}x}=0$</p><p><strong><em>注:这一步应用链式求导法则</em></strong></p><p>$\frac{\mathrm{d}y}{\mathrm{d}x}=-\frac{x}{y}$</p><p>隐函数求导法则:</p><ul><li>在原始方程中, 对一切求导并使用链式求导法则、乘积法则以及商法则进行化简</li><li>如果想要求 dy/dx, 可重新整理并作除法来求解 dy/dx; 不过如果想要求的是斜率或求曲线一个特定点上的切线方程, 可先代入 x 和 y的已知值, 接着重新整理并求 dy/dx, 然后如果需要的话, 使用点斜式来求切线方程</li></ul><h2 id="隐函数求二阶导"><a href="#隐函数求二阶导" class="headerlink" title="隐函数求二阶导"></a>隐函数求二阶导</h2><p>求导两次可以得到二阶导.例如,如果$2y+siny = \frac{x^2}{\pi}+1$,那么该曲线上点(π, π/2)处的$\frac{\mathrm{d}y^2}{\mathrm{d}x^2}$的值是什么呢？再一次地, 你应该先通过代入 x 和 y 的值, 看看方程是否成立来检验该点是否位于曲线上. 现在, 如果你想要求导两次, 必须先从求导一次开始! 使用链式求导法则来处理$sin(y)$这一项, 你应该会得到</p><p>① $2\frac{\mathrm{d}y}{\mathrm{d}x} + cosy\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{1}{\pi}2x$</p><p>然后进行二次求导.如下:<br>② $\frac{\mathrm{d}}{\mathrm{d}x}(2\frac{\mathrm{d}y}{\mathrm{d}x}) + \frac{\mathrm{d}}{\mathrm{d}x}(cosy\frac{\mathrm{d}y}{\mathrm{d}x})=\frac{\mathrm{d}}{\mathrm{d}x}(\frac{1}{\pi}2x)$</p><p>根据乘积法则和链式求导法则可推出:<br>③ $2\frac{\mathrm{d}y^2}{\mathrm{d}x^2}-sin(y)(\frac{\mathrm{d}y}{\mathrm{d}x}^2) + cos(y)\frac{\mathrm{d}y^2}{\mathrm{d}x^2}=\frac{2}{\pi}$</p><p>根据式①带入(π, π/2)得到$\frac{\mathrm{d}y}{\mathrm{d}x}=1$.将其带入二阶导方程得知$\frac{\mathrm{d}y^2}{\mathrm{d}x^2}=\frac{1}{\pi}+\frac{1}{2}$</p>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数</title>
      <link href="/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="角度弧度换算"><a href="#角度弧度换算" class="headerlink" title="角度弧度换算"></a>角度弧度换算</h2><blockquote><p>用弧度度量的角 = π/180 × 用度度量的角</p><p>用角度度量的角 = 180/π × 用弧度度量的角</p></blockquote><h2 id="sin-cos-tan-csc-sec-cot"><a href="#sin-cos-tan-csc-sec-cot" class="headerlink" title="sin cos tan csc sec cot"></a>sin cos tan csc sec cot</h2><p><img src="1.jpg" alt="alt"></p><blockquote><p>sin(θ) = 对边/斜边 </p><p>cos(θ) = 临边/斜边</p><p>tan(θ) = 对边/临边 = sin(θ)/cos(θ)</p><p>csc(θ) = 1/sin(θ)</p><p>sec(θ) = 1/cos(θ)</p><p>cot(θ) = 1/tan(θ)</p></blockquote><h2 id="常用三角函数速记表"><a href="#常用三角函数速记表" class="headerlink" title="常用三角函数速记表"></a>常用三角函数速记表</h2><p><img src="2.jpg" alt="alt"></p><h2 id="计算三角函数"><a href="#计算三角函数" class="headerlink" title="计算三角函数"></a>计算三角函数</h2><h3 id="参考角"><a href="#参考角" class="headerlink" title="参考角"></a>参考角</h3><blockquote><p>θ 的参考角是在表示角 θ 的射线和 x 轴之间的最小的角, 它必定介于 0 到 π/2之间</p></blockquote><h3 id="ASTC表示法"><a href="#ASTC表示法" class="headerlink" title="ASTC表示法"></a>ASTC表示法</h3><p><img src="3.jpg" alt="alt"></p><h2 id="三角恒等式"><a href="#三角恒等式" class="headerlink" title="三角恒等式"></a>三角恒等式</h2><blockquote><p>$sin(θ)^2 + cos(θ)^2 = 1$</p><p>$1 + tan(θ)^2 = sec(θ)^2$</p><p>$cot(θ)^2 + 1 = csc(θ)^2$</p><p>$sin(A + B) = sinAcosB + cosAsinB$</p><p>$cos(A + B) = cosAcosB - sinAsinB$</p><p>$sin(A - B) = sinAcosB - cosAsinB$</p><p>$cos(A - B) = cosAcosB + sinAsinB$</p><p>$sin(2x) = 2sinxcosx$</p><p>$cos(2x) = 2(cosx)^2 - 1 = 1 - 2(sinx)^2$</p></blockquote><h2 id="正弦定理"><a href="#正弦定理" class="headerlink" title="正弦定理"></a>正弦定理</h2><p><strong><em>在任意一个平面三角形中，各边和它所对角的正弦值的比相等且等于外接圆的直径</em></strong></p><blockquote><p>$a/sinA = b/sinB = c/sinC = 2R$</p></blockquote><h2 id="余弦定理"><a href="#余弦定理" class="headerlink" title="余弦定理"></a>余弦定理</h2><p><strong><em>在任意一个平面三角形中，任何一边的平方等于其他两边平方的和减去这两边与它们夹角的余弦的积的两倍。</em></strong></p><blockquote><p>$a^2 = b^2 + c^2 -2bccosA$</p><p>$b^2 = a^2 + c^2 -2accosB$</p><p>$c^2 = a^2 + b^2 -2abcosC$</p></blockquote><h2 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h2><p>设三角形的三条边为abc.则面积s</p><blockquote><p>$p = (a + b + c) / 2$</p><p>$s = \sqrt[2]{p(p-a)(p-b)(p-c)}$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数 图形和直线</title>
      <link href="/2022/03/29/%E5%87%BD%E6%95%B0-%E5%9B%BE%E5%BD%A2%E5%92%8C%E7%9B%B4%E7%BA%BF/"/>
      <url>/2022/03/29/%E5%87%BD%E6%95%B0-%E5%9B%BE%E5%BD%A2%E5%92%8C%E7%9B%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="奇函数与偶函数"><a href="#奇函数与偶函数" class="headerlink" title="奇函数与偶函数"></a>奇函数与偶函数</h1><ul><li>当对f定义域内所有的x都有f(-x) = -f(x)时,f是奇函数.奇函数的图像关于原点有180°的对称性.</li><li>当对f定义域内所有的x都有f(-x) = f(x)时,f是偶函数,偶函数的图像关于y轴具有镜面对称性.</li></ul><h1 id="线性函数的图像"><a href="#线性函数的图像" class="headerlink" title="线性函数的图像"></a>线性函数的图像</h1><p>形如f(x) = mx + b的函数叫做线性函数,函数的图像为直线,斜率为m.</p><p> <strong><em>点斜式</em></strong></p><blockquote><p>如果已知直线通过点(x0, y0),斜率为m,则它的方程为 y - y0 = m(x - x0)</p><p>如果一条直线通过点 (x1, y1) 和 (x2, y2), 则它的斜率等于 (y2 − y1) / (x2 − x1)</p></blockquote><h1 id="常见函数及其图像"><a href="#常见函数及其图像" class="headerlink" title="常见函数及其图像"></a>常见函数及其图像</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>有许多函数是基于 x 的非负次幂建立起来的.你可以以 1、x、$x^2$、$x^3$等为基本项, 然后用实数同这些基本项做乘法, 最后把有限个这样的项加到一起.基本项 $x^n$ 的倍数叫作 $x^n$ 的系数.最大的幂指数n(该项系数不能为零) 叫作多项式的次数.</p><h3 id="二次函数"><a href="#二次函数" class="headerlink" title="二次函数"></a>二次函数</h3><p>次数为2的多项式叫做二次函数,即 p(x) = $ax^2 + bx + c$,根据判别式的符号可以判断二次函数到底有两个 一个还是没有实数解.</p><p><strong><em>判别式</em></strong></p><blockquote><p>$\bigtriangleup$ = $b^2 - 4ac$</p></blockquote><p>它共有三种可能性. 如果 $\bigtriangleup$ &gt; 0, 有两个不同的解; 如果 $\bigtriangleup$ = 0, 只有一个解, 也可以说有两个相同的解; 如果 $\bigtriangleup$ &lt; 0, 在实数范围内无解</p><h2 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h2><h2 id="指数和对数函数"><a href="#指数和对数函数" class="headerlink" title="指数和对数函数"></a>指数和对数函数</h2><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h2 id="带有绝对值的函数"><a href="#带有绝对值的函数" class="headerlink" title="带有绝对值的函数"></a>带有绝对值的函数</h2>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - Context</title>
      <link href="/2021/11/22/Context/"/>
      <url>/2021/11/22/Context/</url>
      
        <content type="html"><![CDATA[<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>This solution means that you’d have to rewrite a special version of every existing function you want to use in a Maybe! This greatly limits the usefulness of tools such as Maybe. It turns out Haskell has a type class that solves this problem, called Functor.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>Maybe is a member of the Functor type class. The Functor type class requires only one definition: fmap.<br><img src="1.jpg" alt="alt"><br>_<strong>fmap provides an adapter</strong>_, Notice that we’re using &lt;$&gt;, which is a synonym for fmap (except it’s a binary operator rather than a function._<strong>This ability to transform the types of values inside a Maybe is the true power of the Functor type class.</strong>_<br><img src="2.jpg" alt="alt"></p><p>Though fmap is the official function name, in practice the binary operator &lt;$&gt; is used much more frequently<br><img src="3.png" alt="alt"></p><h1 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h1><p>_<strong>the Applicative type class allows you to use functions that are inside a context, such as Maybe or IO, Functor is a superclass of Applicative.</strong>_<br><img src="4.jpg" alt="alt"><br><img src="5.jpg" alt="alt"></p><h2 id="The-pure-method"><a href="#The-pure-method" class="headerlink" title="The pure method"></a>The pure method</h2><p>The pure method is a useful helper function for taking an ordinary value(also function) or function and putting it into a context.<br><img src="7.png" alt="alt"></p><h2 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;*&gt;"></a>&lt;*&gt;</h2><p><img src="6.png" alt="alt"></p><h2 id="Containers-vs-contexts"><a href="#Containers-vs-contexts" class="headerlink" title="Containers vs. contexts"></a>Containers vs. contexts</h2><ol><li>Parameterized types that represent a container are types that represent a data structure.</li><li>When a type is a context, extra information is implied about the type, beyond its structure.</li></ol><h2 id="List-as-a-context"><a href="#List-as-a-context" class="headerlink" title="List as a context"></a>List as a context</h2><p>The List type is both a container and a context.List as a container is easy to understand. List is basically a chain of buckets of whatever type of data you want to hold. But List is a member of Applicative,so there must be a way to view List as a context.<br>_<strong>List as a context is that it describes nondeterministic computation.</strong>_</p><p><img src="8.png" alt="alt"><br>when you add values in the context of a list,you’re adding together all possible values from the two contexts.</p><ol><li>A list as a container is a sequence of values that can hold any type. Each item in the list points to the next one or to the empty list.</li><li>A list as a context represents a set of possibilities. Think of a list as a context as being a single variable that can contain many possible values.</li></ol><h1 id="MONAD"><a href="#MONAD" class="headerlink" title="MONAD"></a>MONAD</h1><h2 id="The-Monad-type-class"><a href="#The-Monad-type-class" class="headerlink" title="The Monad type class"></a>The Monad type class</h2><p><img src="10.jpg" alt="alt"></p><p><img src="11.png" alt="alt"></p><h3 id="The-bind-operator-gt-gt"><a href="#The-bind-operator-gt-gt" class="headerlink" title="The bind operator: &gt;&gt;="></a>The bind operator: &gt;&gt;=</h3><p><img src="9.png" alt="alt"><br>_<strong>As you can see, &gt;&gt;= allows you to chain together a function of a type (a -&gt; m b)</strong>_</p><h2 id="the-list-Monad"><a href="#the-list-Monad" class="headerlink" title="the list Monad"></a>the list Monad</h2><p>when you assign your list to a variable using &lt;-, you get to treat it as though it were a single value. The rest of this code looks like it’s operating on one candidate, and yet the final result is the same as applying your logic to every candidate in a list.<br><img src="12.png" alt="alt"></p><h3 id="Building-lists-with-the-list-monad"><a href="#Building-lists-with-the-list-monad" class="headerlink" title="Building lists with the list monad"></a>Building lists with the list monad</h3><p><img src="13.png" alt="alt"></p><h3 id="The-guard-function"><a href="#The-guard-function" class="headerlink" title="The guard function"></a>The guard function</h3><p>Again you could use filter, but when working with monads, you’d like to be able to reason about a value outside its context. In Control.Monad, a function called guard allows you to filter your values in a list. You have to import Control.Monad to use guard.<br><img src="14.png" alt="alt"></p><h3 id="list-comprehensions"><a href="#list-comprehensions" class="headerlink" title="list comprehensions"></a>list comprehensions</h3><p><img src="15.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - IO</title>
      <link href="/2021/11/20/IO/"/>
      <url>/2021/11/20/IO/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-TYPES"><a href="#IO-TYPES" class="headerlink" title="IO TYPES"></a>IO TYPES</h1><p>Haskell has a special parameterized type called IO. Any value in an IO context must stay in this context. This prevents code that’s pure (meaning it upholds referential transparency and doesn’t change state) and code that’s necessarily impure from mixing.</p><h2 id="IO-types—dealing-with-an-impure-world"><a href="#IO-types—dealing-with-an-impure-world" class="headerlink" title="IO types—dealing with an impure world"></a>IO types—dealing with an impure world</h2><p>IO in Haskell is a parameterized type that’s similar to Maybe.The first thing they share in common is that they’re parameterized types of the same kind.The other thing that Maybe and IO have in common is that (unlike List or Map) they describe a context for their parameters rather than a container. The context for the IO type is that the value has come from an input/output operation.To keep Haskell code pure and predictable, you use the IO type to provide a context for data that may not behave the way all of the rest of your Haskell code does. IO actions aren’t functions.</p><h2 id="Examples-of-IO-actions"><a href="#Examples-of-IO-actions" class="headerlink" title="Examples of IO actions"></a>Examples of IO actions</h2><p>main doesn’t return any meaningful value; it simply performs an action. It turns out that main isn’t a function, because it breaks one of the fundamental rules of functions: it doesn’t return a value. Because of this, we refer to main as an IO action. IO actions work much like functions except they violate at least one of the three rules we established for functions early in the book. Some IO actions return no value, some take no input, and others don’t always return the same value given the same input.<br><img src="1.png" alt="alt"></p><h2 id="Do-notation"><a href="#Do-notation" class="headerlink" title="Do-notation"></a>Do-notation</h2><p>This do-notation allows you to treat IO types as if they were regular types. This also explains why some variables use let and others use &lt;-. Variables assigned with &lt;- allow you to act as though a type IO a is just of type a. You use let statements whenever you create variables that aren’t IO types.</p><h3 id="lt"><a href="#lt" class="headerlink" title="&lt;-"></a>&lt;-</h3><p>Donotation allows you to assign an IO String variable by using &lt;-, to act like it’s an ordinary String, and then to pass it to functions that work with only regular Strings<br><img src="2.png" alt="alt"></p><h1 id="LAZY-I-O"><a href="#LAZY-I-O" class="headerlink" title="LAZY I/O"></a>LAZY I/O</h1><h2 id="the-nonlazy-way"><a href="#the-nonlazy-way" class="headerlink" title="the nonlazy way"></a>the nonlazy way</h2><p><img src="3.png" alt="alt"></p><p><img src="4.png" alt="alt"></p><h2 id="lazy-way"><a href="#lazy-way" class="headerlink" title="lazy way"></a>lazy way</h2><p><img src="5.png" alt="alt"></p><h3 id="do-notation-in-Maybe"><a href="#do-notation-in-Maybe" class="headerlink" title="do-notation in Maybe"></a>do-notation in Maybe</h3><p>IO can use do-notation because it’s a member of a powerful type class called Monad. We discuss Monad much more in unit 5. Do-notation has nothing to do with IO in particular and can be used by any member of Monad to perform computation in a context. </p><h1 id="TEXT-AND-UNICODE"><a href="#TEXT-AND-UNICODE" class="headerlink" title="TEXT AND UNICODE"></a>TEXT AND UNICODE</h1><h2 id="The-Text-type"><a href="#The-Text-type" class="headerlink" title="The Text type"></a>The Text type</h2><p>Unlike String, Text is implemented as an array under the hood. This makes many string operations faster and much more memory-efficient. Another major difference between Text and String is that Text doesn’t use lazy evaluation. Lazy evaluation proved to be helpful in the preceding lesson, but in many real-world cases it can lead to performance headaches. If you do need lazy text, you can use Data.Text.Lazy, which has the same interface as Data.Text.</p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell02 - types</title>
      <link href="/2021/11/18/types/"/>
      <url>/2021/11/18/types/</url>
      
        <content type="html"><![CDATA[<h1 id="01-TYPE-BASICS"><a href="#01-TYPE-BASICS" class="headerlink" title="01. TYPE BASICS"></a>01. TYPE BASICS</h1><p>in Haskell, you haven’t had to write down any information about the<br>type you’re using for any of your values. It turns out this is because Haskell has done it<br>for you! Haskell uses type inference to automatically determine the types of all values at<br>compile time based on the way they’re used! You don’t have to rely on Haskell to determine your types for you.</p><p><img src="1.png" alt="alt"></p><h2 id="list-tuple-function"><a href="#list-tuple-function" class="headerlink" title="list  tuple  function"></a>list  tuple  function</h2><p><img src="2.png" alt="alt"></p><h3 id="Functions-with-multiple-arguments"><a href="#Functions-with-multiple-arguments" class="headerlink" title="Functions with multiple arguments"></a>Functions with multiple arguments</h3><p>why are type signatures this way? The reason is that behind the scenes in Haskell, all functions take only one argument. By rewriting makeAddress by using a series of nested lambda functions.</p><p><img src="3.png" alt="alt"></p><h3 id="Types-for-first-class-functions"><a href="#Types-for-first-class-functions" class="headerlink" title="Types for first-class functions"></a>Types for first-class functions</h3><p>functions can take functions as arguments and return<br>functions as values. To write these type signatures, you write the individual function<br>values in parentheses.</p><p><img src="4.png" alt="alt"></p><h2 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h2><p> Haskell has type variables. Any lowercase letter in a type signature indicates that any type can be used in that place.<br> Type variables are literally variables for types. Type variables work exactly like regular<br>variables, but instead of representing a value, they represent a type. When you use a<br>function that has a type variable in its signature, you can imagine Haskell substituting<br>the variable that’s needed.</p><h1 id="02-CREATING-YOUR-OWN-TYPES"><a href="#02-CREATING-YOUR-OWN-TYPES" class="headerlink" title="02. CREATING YOUR OWN TYPES"></a>02. CREATING YOUR OWN TYPES</h1><h2 id="type-synonyms"><a href="#type-synonyms" class="headerlink" title="type synonyms"></a>type synonyms</h2><p>When you have two names for the same type, it’s referred to as a type synonym. Type synonyms are extremely useful, because they make reading type signatures much easier.<br>_<strong>In Haskell, you can create new type synonyms by using the type keyword.</strong>_</p><h2 id="Creating-new-types"><a href="#Creating-new-types" class="headerlink" title="Creating new types"></a>Creating new types</h2><h2 id="record-syntax"><a href="#record-syntax" class="headerlink" title="record syntax"></a>record syntax</h2><p>You can define data types such as Patient by using record syntax. Defining a new data type by using record syntax makes it much easier to understand which types represent<br>which properties of the data type.<br><img src="5.png" alt="alt"></p><h3 id="automatically-getters-and-setters"><a href="#automatically-getters-and-setters" class="headerlink" title="automatically getters and setters"></a>automatically getters and setters</h3><p>you don’t have to write your getters; each field in the record syntax automatically creates a function to access that value from the record.You can also set values in record syntax by passing the new value in curly brackets to<br>your data.<br><img src="6.png" alt="alt"></p><h1 id="03-TYPE-CLASSES"><a href="#03-TYPE-CLASSES" class="headerlink" title="03. TYPE CLASSES"></a>03. TYPE CLASSES</h1><p>Type classes in Haskell are a way of describing groups of types that all behave in the same way. If you’re familiar with<br>Java or C#, type classes may remind you of interfaces.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>definition of the type class is a list of functions that all members of the class must implement, along with the type signatures of<br>those functions. The family of functions that describe a number is +, -, *, negate, abs, and<br>signum (gives the sign of a number)<br><img src="7.jpg" alt="alt"></p><h2 id="The-benefits-of-type-classes"><a href="#The-benefits-of-type-classes" class="headerlink" title="The benefits of type classes"></a>The benefits of type classes</h2><p>So far in Haskell, each function you’ve defined works for only one specific set of types. Without type classes, you’d need a different name for each function that adds a different type of value. You do have type variables, but they’re too flexible.<br>_<strong>Type classes also allow you to define functions on a variety of types that you can’t even<br>think of</strong>_</p><h2 id="Defining-a-type-class"><a href="#Defining-a-type-class" class="headerlink" title="Defining a type class"></a>Defining a type class</h2><p><img src="8.jpg" alt="alt"></p><h2 id="Deriving-type-classes"><a href="#Deriving-type-classes" class="headerlink" title="Deriving type classes"></a>Deriving type classes</h2><p><img src="9.png" alt="alt"></p><h2 id="implement-type-class"><a href="#implement-type-class" class="headerlink" title="implement type class"></a>implement type class</h2><p><img src="10.png" alt="alt"></p><h2 id="Creating-types-with-newtype"><a href="#Creating-types-with-newtype" class="headerlink" title="Creating types with newtype"></a>Creating types with newtype</h2><p>When looking at our type definition for Name, you find an interesting case in which you’d like to use a type synonym, but need to define a data type in order to make your type an instance of a type class. Haskell has a preferred method of doing this: _<strong>using the newtype keyword.</strong>_ Here’s an example of the definition of Name using newtype.<br><img src="11.png" alt="alt"></p><h1 id="04-AlGEBRAIC-DATA-TYPES"><a href="#04-AlGEBRAIC-DATA-TYPES" class="headerlink" title="04. AlGEBRAIC DATA TYPES"></a>04. AlGEBRAIC DATA TYPES</h1><p>Algebraic data types are any types that can be made by combining other types. The key to understanding algebraic data types is knowing exactly how to combine other types. Thankfully, there are only two ways. You can combine multiple types with an and (for example, a name is a String and another String), or you can combine types with an or (for example, a Bool is a True data constructor or a False data constructor). Types that are made by combining other types with an and are called product types. Types combined using or are called sum types.</p><h2 id="product-type"><a href="#product-type" class="headerlink" title="product type"></a>product type</h2><p>Product types are created by combining two or more existing types with and, bundling two or more types together to define a new type. Nearly every programming language supports product types, even if not by that name.<br><img src="12.png" alt="alt"></p><h2 id="sum-type"><a href="#sum-type" class="headerlink" title="sum type"></a>sum type</h2><p>Sum types are a surprisingly powerful tool, given that they provide only the capability to combine two types with or. </p><h1 id="05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS"><a href="#05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS" class="headerlink" title="05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS"></a>05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS</h1><h2 id="combining-functions"><a href="#combining-functions" class="headerlink" title="combining functions"></a>combining functions</h2><p>combining functions:A special higher-order function that’s just a period (called compose) takes two functions as arguments.<br><img src="13.png" alt="alt"></p><h2 id="Combining-like-types-Semigroups"><a href="#Combining-like-types-Semigroups" class="headerlink" title="Combining like types: Semigroups"></a>Combining like types: Semigroups</h2><p>The Semigroup class has only one important method you need, the &lt;&gt; operator. You can think of &lt;&gt; as an operator for combining instances of the same type.<br><img src="14.png" alt="alt"><br>_<strong>This simple signature is the heart of the idea of composability; you can take two like<br>things and combine them to get a new thing of the same type.</strong>_</p><h2 id="Composing-with-identity-Monoids"><a href="#Composing-with-identity-Monoids" class="headerlink" title="Composing with identity: Monoids"></a>Composing with identity: Monoids</h2><p>Another type class that’s similar to Semigroup is Monoid. The only major difference between Semigroup and Monoid is that Monoid requires an identity element for the type. An identity element means that x &lt;&gt; id = x (and id &lt;&gt; x = x). _<strong>Having an identity element might seem like a small detail, but it greatly increases the power of a type by allowing you to use a fold function to easily combine lists of the same type.</strong>_<br><img src="15.png" alt="alt"></p><h3 id="mconcat"><a href="#mconcat" class="headerlink" title="mconcat"></a>mconcat</h3><p>_<strong>The mconcat method takes a list of Monoids and combines them, returning a single Monoid.</strong>_<br>The easiest way to see how powerful identity is, is to explore the final method in the definition of Monoid: mconcat. The only required definitions in Monoid are mempty and mappend. If you implement these two, you get mconcat for free.This is because the definition of mconcat relies only on foldr, mappend, and mempty. Here’s the definition of mconcat:<br><img src="16.png" alt="alt"></p><h3 id="Monoid-laws"><a href="#Monoid-laws" class="headerlink" title="Monoid laws"></a>Monoid laws</h3><ol><li>mappend mempty x is x</li><li>mappend x mempty is x</li><li>mappend x (mappend y z) = mappend (mappend x y) z</li><li>mconcat = foldr mappend mempty</li></ol><h1 id="06-PARAMETERIZED-TYPES"><a href="#06-PARAMETERIZED-TYPES" class="headerlink" title="06. PARAMETERIZED TYPES"></a>06. PARAMETERIZED TYPES</h1><p>If you’re familiar with type generics in languages such as C# and Java, parameterized types will initially seem similar. Like generics in C# and Java, parameterized types allow you to create “containers” that can hold other types.</p><h2 id="definition-1"><a href="#definition-1" class="headerlink" title="definition"></a>definition</h2><p><img src="17.png" alt="alt"></p><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>A list of type a is either Empty or the consing of the value a with another     list of type a.<br><img src="18.png" alt="alt"></p><h2 id="Types-with-more-than-one-parameter"><a href="#Types-with-more-than-one-parameter" class="headerlink" title="Types with more than one parameter"></a>Types with more than one parameter</h2><p>Just like functions, types can also take more than one argument. The important thing to remember is that more than one type parameter means the type can be a container for more than one type.</p><h3 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h3><p>Tuples are the most ubiquitous multiparameter type in Haskell. tuples use a built-in type constructor, ().you have to use () with one comma inside for every n – 1 items in the tuple. For example, if you want the definition of a 2-tuple, you’d type :info<br>(,) into GHCi. Here’s the built-in definition.<br><img src="19.png" alt="alt"></p><h3 id="Data-Map"><a href="#Data-Map" class="headerlink" title="Data.Map"></a>Data.Map</h3><p>Map allows you to look up values by using keys. In many other languages, this data type is called Dictionary. The type parameters of Map are the types of the keys and values. The most common way to build a Map is with the fromList function.<br><img src="20.png" alt="alt"><br><img src="21.png" alt="alt"></p><h2 id="Kinds-types-of-types"><a href="#Kinds-types-of-types" class="headerlink" title="Kinds: types of types"></a>Kinds: types of types</h2><p>The type of a type is called its kind. _<strong>The kind of a type indicates the number of parameters the type takes, which are expressed using an asterisk (<em>). Types that take no parameters have a kind of </em>, types that take one parameter have the kind <em> -&gt; </em>, types with two parameters have the kind <em> -&gt; </em> -&gt; *, and so forth.</strong>_</p><h1 id="07-Maybe"><a href="#07-Maybe" class="headerlink" title="07. Maybe"></a>07. Maybe</h1><h2 id="solving-missing-values-with-types"><a href="#solving-missing-values-with-types" class="headerlink" title="solving missing values with types"></a>solving missing values with types</h2><p>Maybe is a simple but powerful type. So far, all of our parameterized types have been viewed as containers. Maybe is different. _<strong>Maybe is best understood as a type in a context.The context in this case is that the type contained might be missing. Here’s its definition.</strong>_<br><img src="22.png" alt="alt"><br>When a function returns a value of the Maybe type, the program can’t use that value without dealing with the fact that the value<br>is wrapped in a Maybe. Missing values can never cause an error in Haskell because Maybe makes it impossible to forget that a value might be null. At the same time, the programmer never has to worry about this until absolutely necessary. </p><p>_<strong>The interesting thing here is that you didn’t even have to remove the organ from the Maybe context. Maybe implements Eq, so you can just compare two Maybe Organs.</strong>_</p><h2 id="isJust-and-isNothing"><a href="#isJust-and-isNothing" class="headerlink" title="isJust and isNothing"></a>isJust and isNothing</h2><p>The Data.Maybe module contains two functions, isJust and isNothing, that solve the general case of handling Just values. </p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell01 - Foundations of functional programming</title>
      <link href="/2021/11/16/Foundations-of-functional-programming/"/>
      <url>/2021/11/16/Foundations-of-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Functions"><a href="#01-Functions" class="headerlink" title="01. Functions"></a>01. Functions</h1><p>All functions in Haskell follow three rules that force them to behave like functions in<br>math:</p><ul><li>All functions must take an argument.</li><li>All functions must return a value.</li><li>Anytime a function is called with the same argument, it must return the same<br>value</li></ul><p>The third rule is part of the basic mathematical definition of a function. When the rule<br>that the same argument must always produce the same result is applied to function in a<br>programming language, it’s called referential transparency.</p><h1 id="02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE"><a href="#02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE" class="headerlink" title="02. LAMBDA FUNCTIONS AND LEXICAL SCOPE"></a>02. LAMBDA FUNCTIONS AND LEXICAL SCOPE</h1><h2 id="Lambda-functions"><a href="#Lambda-functions" class="headerlink" title="Lambda functions"></a>Lambda functions</h2><p>One of the most foundational concepts in functional programming is a function without<br>a name, called a lambda function (hence lambda calculus). Lambda functions are often<br>referred to using the lowercase Greek letter λ. Another common name for a lambda<br>function is an anonymous function.<br><img src="1.png" alt="alt"></p><h2 id="Practical-lambda-functions-and-lexical-scope"><a href="#Practical-lambda-functions-and-lexical-scope" class="headerlink" title="Practical lambda functions and lexical scope"></a>Practical lambda functions and lexical scope</h2><p>IIFE works on exactly the same principles as our example of replacing a where statement. Whenever you create a new function, named or not, you<br>create a new scope, which is the context in which a variable is defined. When a variable is<br>used, the program looks at the nearest scope; if the definition of the variable isn’t there,<br>it goes to the next one up. This particular type of variable lookup is called lexical scope.<br>Both Haskell and JavaScript use lexical scoping, which is why IIFE and your lambda function variables behave in a similar fashion.</p><h1 id="03-FIRST-CLASS-FUNCTIONS"><a href="#03-FIRST-CLASS-FUNCTIONS" class="headerlink" title="03. FIRST-CLASS FUNCTIONS"></a>03. FIRST-CLASS FUNCTIONS</h1><p>The concept of first-class functions is that functions are no different from any other data<br>used in a program. Functions can be used as arguments and returned as values from<br>other functions. This is a deceptively powerful feature for a programming language to<br>have. It allows you to abstract out any repetitive computation from your code, and ultimately allows you to write functions that write other functions.</p><h1 id="04-LISTS"><a href="#04-LISTS" class="headerlink" title="04 LISTS"></a>04 LISTS</h1><p>Lists are the single most important data structure in functional programming. One of<br>the key reasons is that lists are inherently recursive. A list is either an empty list or an<br>element followed by another list</p><h2 id="head-tail"><a href="#head-tail" class="headerlink" title="head tail"></a>head tail</h2><p>When taking apart a list, the main pieces are the head, the tail.The head is just the first element in a list.The tail is the rest of the list left over, after the head<br><img src="3.png" alt="alt"></p><p><img src="4.png" alt="alt"></p><h2 id="cons"><a href="#cons" class="headerlink" title="cons(:)"></a>cons(:)</h2><p>To build a list, you need just one function and the infix operator (:),<br>which is called cons. you need to take a value and cons it with another list. The simplest way<br>to make a list is to cons a value with the empty list. _<strong>By definition, a list is always a<br>value consed with another list (which can also be an empty list)</strong>_<br>If you do want to combine two lists, you need to concatenate them by using ++</p><h2 id="lazy-evaluation"><a href="#lazy-evaluation" class="headerlink" title="lazy evaluation"></a>lazy evaluation</h2><p>Haskell uses a special form of evaluation called lazy evaluation. In lazy evaluation,<br>no code is evaluated until it’s needed.</p><h2 id="Common-functions-on-lists"><a href="#Common-functions-on-lists" class="headerlink" title="Common functions on lists"></a>Common functions on lists</h2><h3 id="The-operator"><a href="#The-operator" class="headerlink" title="The !! operator"></a>The !! operator</h3><p>If you want to access a particular element of a list by its index, you can use the !! operator. The !! operator takes a list and a number, returning the element at that location in<br>the list. _<strong>any infix operator (an operator that’s placed between two values, such as +) can also be used like a prefix function by wrapping it in parentheses</strong>_<br><img src="5.png" alt="alt"></p><h4 id="partial-application"><a href="#partial-application" class="headerlink" title="partial application"></a>partial application</h4><p>_<strong>Using prefix notation can often make things such as partial application easier. Prefix<br>notation is also useful for using operators as arguments to other functions. You can still<br>use partial application with an infix operator; you just need to wrap the expression in<br>parentheses</strong>_</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>give the length of the list</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>reverse the list</p><h3 id="elem"><a href="#elem" class="headerlink" title="elem"></a>elem</h3><p>The elem function takes a value and a list and checks whether the value is in the list.elem is a function that you may want to treat as an infix operator for readability. _<strong>Any<br>binary function can be treated as an infix operator by wrapping it in back-quotes (`)</strong>_</p><h3 id="take-and-drop"><a href="#take-and-drop" class="headerlink" title="take and drop"></a>take and drop</h3><p>The take function takes a number and a list as arguments and then returns the first n elements of the list. f you ask for more values then a list has, take gives you what it can, with no error.</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>You use zip when you want to combine two lists into tuple pairs. The arguments to zip<br>are two lists. If one list happens to be longer, zip will stop whenever one of the two lists<br>is empty.</p><h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><p> cycle uses lazy evaluation to create an infinite list. Given a list, cycle repeats that list endlessly.<br><img src="6.png" alt="alt"></p><h1 id="05-RECURSION-AND-PATTERN-MATCHING"><a href="#05-RECURSION-AND-PATTERN-MATCHING" class="headerlink" title="05 RECURSION AND PATTERN MATCHING"></a>05 RECURSION AND PATTERN MATCHING</h1><p>In general, something is recursive if it’s defined in terms of itself.</p><h2 id="Rules-from-Recursion"><a href="#Rules-from-Recursion" class="headerlink" title="Rules from Recursion"></a>Rules from Recursion</h2><ol><li>Identify the end goal(s).</li><li>Determine what happens when a goal is reached.</li><li>List all alternate possibilities.</li><li>Determine your “rinse and repeat” process.</li><li>Ensure that each alternative moves you toward your goal.</li></ol><h2 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h2><p>Haskell has an amazing feature called pattern matching<br>that allows you to peek at the values passed as arguments and behave accordingly.</p><ol><li>_<strong>Pattern matching, just like case, looks at the options in order</strong>_</li><li>_<strong>pattern matching is that it can look only at arguments, but it can’t do any computation on them when matching</strong>_</li><li>_<strong>it’s standard practice to use _ as a wildcard for values you don’t use</strong>_</li></ol><h2 id="Recursion-on-lists"><a href="#Recursion-on-lists" class="headerlink" title="Recursion on lists"></a>Recursion on lists</h2><h3 id="implements-built-in-length-take-cycle"><a href="#implements-built-in-length-take-cycle" class="headerlink" title="implements built-in length take cycle"></a>implements built-in length take cycle</h3><p><img src="7.png" alt="alt"></p><h1 id="06-HIGHER-ORDER-FUNCTIONS"><a href="#06-HIGHER-ORDER-FUNCTIONS" class="headerlink" title="06 HIGHER-ORDER FUNCTIONS"></a>06 HIGHER-ORDER FUNCTIONS</h1><p>A higher-order function is technically any function that takes another function as an argument.<br>Typically, when higher-order functions are mentioned, a specific group of them comes<br>to mind, and nearly all of these are used to abstract away common patterns of recursion.<br>The main reason that you use first-class functions, and therefore have higher-order<br>functions, is so you can abstract out programming patterns</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>The map function takes another function and a list as arguments and applies that<br>function to each element in the list.</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>The filter function looks and behaves similarly to map, taking a function and a list as arguments and<br>returning a list. The difference is that the function passed to filter must be passed a<br>function that returns True or False. The filter function works by keeping only the elements of the list that pass the test</p><h2 id="foldl-foldr"><a href="#foldl-foldr" class="headerlink" title="foldl(foldr)"></a>foldl(foldr)</h2><p>The function foldl (the l stands for left) takes a list and reduces<br>it to a single value. The function takes three arguments: a binary function, an initial<br>value, and a list. The most common use of foldl is to sum a list.</p><h2 id="implements-map-filter-amp-foldl"><a href="#implements-map-filter-amp-foldl" class="headerlink" title="implements map filter &amp; foldl"></a>implements map filter &amp; foldl</h2><p><img src="8.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>enum</title>
      <link href="/2021/11/01/enum/"/>
      <url>/2021/11/01/enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h1><p>当一个变量有几种可能的取值时,可以将它定义为枚举类型，</p><ol><li>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加</li><li>因此当我们把第一个值赋值后,后面也会根据第一个值进行累加</li><li>枚举类型的值其实也可以是字符串类型</li><li>字符串枚举可以和数字枚举混合使用</li></ol><h2 id="枚举的本质-amp-双向映射"><a href="#枚举的本质-amp-双向映射" class="headerlink" title="枚举的本质 &amp; 双向映射"></a>枚举的本质 &amp; 双向映射</h2><p>枚举具有双向映射的特性，所谓双向映射指的是通过key可以索引到value,同时通过value也可以索引到key.<br>原因就在编译后的 JavaScript把枚举类型构造成为了一个对象，而由于其特殊的构造，导致其拥有正反向同时映射的特性<br><img src="1.png" alt="alt"></p><h2 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h2><p>枚举可以被 const 声明为常量,这样做的好处是，编译后的js代码中实际上是不存在枚举和枚举对象的，使用的是枚举的值，这是性能提升的一个方案。</p><blockquote><p>如果你非要 TypeScript 保留对象 Direction ,那么可以添加编译选项 —preserveConstEnums</p></blockquote><h2 id="联合枚举类型"><a href="#联合枚举类型" class="headerlink" title="联合枚举类型"></a>联合枚举类型</h2><p>将一个变量声明为枚举类型，可以认为声明了一个联合类型，联合类型的值对应枚举的值。<br><img src="2.png" alt="alt"></p><h2 id="使用数字类型作为标志"><a href="#使用数字类型作为标志" class="headerlink" title="使用数字类型作为标志"></a>使用数字类型作为标志</h2><p><img src="3.png" alt="alt"></p><h2 id="为枚举添加静态方法"><a href="#为枚举添加静态方法" class="headerlink" title="为枚举添加静态方法"></a>为枚举添加静态方法</h2><p>可以使用enum + namespace 的声明方式向枚举类型添加静态方法.如下例所示，我们将静态成员 isBusinessDay 添加到枚举上<br><img src="4.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface</title>
      <link href="/2021/10/31/interface/"/>
      <url>/2021/10/31/interface/</url>
      
        <content type="html"><![CDATA[<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查,它有时被称做”鸭式辩型法”或”结构型子类型化”.<br>TypeScript里接口的作用就是为这些类型命名和为你的代码和第三方代码定义契约.<br><img src="1.png" alt="alt"></p><h2 id="可选属性-amp-只读属性"><a href="#可选属性-amp-只读属性" class="headerlink" title="可选属性 &amp; 只读属性"></a>可选属性 &amp; 只读属性</h2><p><img src="2.png" alt="alt"></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p><img src="3.png" alt="alt"></p><h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>通过定义key和value的类型宽泛的描述接口”形状”.<br><img src="4.png" alt="alt"></p><h4 id="所有成员都必须符合字符串的索引签名"><a href="#所有成员都必须符合字符串的索引签名" class="headerlink" title="所有成员都必须符合字符串的索引签名"></a>所有成员都必须符合字符串的索引签名</h4><p><img src="5.png" alt="alt"></p><h4 id="使用一组有限的字符串字面量"><a href="#使用一组有限的字符串字面量" class="headerlink" title="使用一组有限的字符串字面量"></a>使用一组有限的字符串字面量</h4><p>一个索引签名可以通过映射类型来使索引字符串为联合类型中的一员<br><img src="6.png" alt="alt"></p><h4 id="索引签名的嵌套"><a href="#索引签名的嵌套" class="headerlink" title="索引签名的嵌套"></a>索引签名的嵌套</h4><p>尽量不要使用这种把字符串索引签名与有效变量混合使用。如果属性名称中有拼写错误，这个错误不会被捕获到<br><img src="8.png" alt="alt"></p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>基于现有接口实现一个新接口,添加部分额外属性,可以通过接口继承的方式,实现代码重用.<br><img src="7.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeScript类型系统</title>
      <link href="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="typeScript类型系统"><a href="#typeScript类型系统" class="headerlink" title="typeScript类型系统"></a>typeScript类型系统</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>基本注解采用 <strong>:TypeAnnotation</strong>语法,在类型声明空间中可用的任何内容都可以用作类型注解</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 string、number、boolean 也可以被用作类型注解.</p><p><img src="1.png" alt="alt"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>针对数组的类型注解有两种方式 <strong>:TypeAnnotation[]</strong> 或者 <strong>Array\<TypeAnnotation></TypeAnnotation></strong>,这两种方式是等价的<br><img src="2.png" alt="alt"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>typeScript核心特性,合并众多类型声明至一个类型声明<br><img src="3.png" alt="alt"></p><h3 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h3><p>内联类型能快速提供一个类型注解,不必为类型起单独的名称,然而,如果你发现需要多次使用相同的内联注解,应该把它重构为一个接口<br><img src="4.png" alt="alt"></p><h3 id="联合类型-amp-交叉类型"><a href="#联合类型-amp-交叉类型" class="headerlink" title="联合类型 &amp; 交叉类型"></a>联合类型 &amp; 交叉类型</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型(|)"></a>联合类型(|)</h4><p>所期望的属性是众多类型之一,如字符串或字符串数组,本质上是类型的并集操作,这正是typeScript中联合类型的用途,使用 | 作标记.</p><p><img src="5.png" alt="alt"></p><h4 id="交叉类型-amp"><a href="#交叉类型-amp" class="headerlink" title="交叉类型(&amp;)"></a>交叉类型(&amp;)</h4><p>在 JavaScript 中， extend 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式<br><img src="6.png" alt="alt"></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型和数组很相似,表示一个已知元素数量和类型的数组,各元素的类型不必相同.可以把元组看成严格版型的数组<br><img src="7.png" alt="alt"><br><img src="8.png" alt="alt"></p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <strong>type SomeName = someValidTypeAnnotation</strong> 来创建别名：</p><p><img src="9.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core 文件系统</title>
      <link href="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-文件系统"><a href="#Asp-Net-Core-文件系统" class="headerlink" title="Asp.Net Core 文件系统"></a>Asp.Net Core 文件系统</h1><p>ASP.NET Core 具有很多针对文件读取的应用。比如我们倾向于采用JSON文件来定义配置，所以应用就会涉及针对配置文件读取。如果用户发送一个针对物理文件的HTTP请求，应用会根据指定的路径读取目标文件的内容并对请求予以响应。在一个ASP.NET Core MVC应用中，针对View的动态编译会涉及到根据预定义的路径映射关系来读取目标View文件。这些不同应用场景都会出现一个IFileProvider对象的身影，以此对象为核心的文件系统提供了统一的API来读取文件的内容并监控内容的改变。</p><h2 id="物理文件系统"><a href="#物理文件系统" class="headerlink" title="物理文件系统"></a>物理文件系统</h2><h3 id="IChangeToken"><a href="#IChangeToken" class="headerlink" title="IChangeToken"></a>IChangeToken</h3><p>由于IFileProvider提供了针对文件系统变换的监控功能，在.NET Core的世界里类似的功能大都利用一个IChangeToken对象来实现.从字面上理解的IChangeToken对象就是一个与某组监控数据关联的“令牌（Token）”，它能够在检测到数据改变的时候及时地对外发出一个通知。IChangeToken接口具有如下所示的三个成员。</p><p><img src="IFileProvider1.jpg" alt="alt"></p><ul><li><p><strong>HasChanged</strong>:如果关联的数据发生改变，HasChanged属性将变成True.</p></li><li><p><strong>ActiveChangeCallbacks</strong>:它表示当数据发生变化时是否需要主动执行注册的回调操作.</p></li><li><p><strong>RegisterChangeCallback</strong>:注册一个在数据发生改变时可以自动执行的回调，该方法会以一个IDisposable对象的形式返回注册对象，所以我们应该在适当的时机调用其Dispose方法解除注册的回调.</p></li></ul><h3 id="IFileProvider"><a href="#IFileProvider" class="headerlink" title="IFileProvider"></a>IFileProvider</h3><p>IFileProvider的接口定义如下图:</p><p><img src="IFileProvider2.jpg" alt="alt"></p><p><img src="IFileProvider3.jpg" alt="alt"></p><p><img src="IFileProvider4.jpg" alt="alt"></p><ul><li><p><strong>GetDirectoryContents</strong>:通过给定的路径遍历目录,返回一个由IFileInfo组成的集合.该接口有一个属性Exists,判断指定路径目录是否存在.</p></li><li><p><strong>IsDirectory</strong>:由GetDirectoryContents得到的集合中无论是目录还是文件,都会用IFileInfo来表示.判断是文件还是目录用属性IsDirectory来区分.</p></li><li><p><strong>GetFileInfo</strong>:获取指定路径下的文件.如果是目录或者不存在,则Exists属性返回false.</p></li><li><strong>Watch</strong>:监控指定文件的变化,如果产生变化,则调用注册的回调函数.如下图所示.</li></ul><p><img src="IFileProvider5.jpg" alt="alt"></p><p>文件系统涉及的接口以及相互关系图.</p><p><img src="IFileProvider6.jpg" alt="alt"></p><h3 id="物理文件系统-1"><a href="#物理文件系统-1" class="headerlink" title="物理文件系统"></a>物理文件系统</h3><p>物理文件系统涉及的接口以及相互关系图</p><p><img src="IFileProvider7.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务消费</title>
      <link href="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/"/>
      <url>/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务消费"><a href="#Asp-Net-Core-DI-服务消费" class="headerlink" title="Asp.Net Core DI-服务消费"></a>Asp.Net Core DI-服务消费</h1><p>本系列博客均来源于大内老A关于Asp.NET Core的解读,在此进基础上进行了提炼,方便日后查看学习.<br>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IServiceProvider的GetService方法，IServiceProvider就会根据对应的服务注册提供所需的服务实例。</p><h2 id="IServiceProvider"><a href="#IServiceProvider" class="headerlink" title="IServiceProvider"></a>IServiceProvider</h2><p>IServiceProvider由ServiceCollection的BuildServiceProvider方法来生成,ServiceProvider只包含一个方法GetService(Type serviceType).如下图:</p><p><img src="Use1.jpg" alt="alt"><br>IserviceProvider包含其他一些扩展方法,可以方便通过不同方式不用应用场景返回实例.如下图:</p><p><img src="Use2.jpg" alt="alt"></p><ul><li>GetService<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应实例,如果没有T对应的注册信息,返回null</T></li><li>GetServices<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应的多个实例</T></li><li>GetServices(this IServiceProvider provider, Type serviceType):传参的方式</li><li>GetRequiredService(this IServiceProvider provider, Type serviceType):如果指定服务类型的服务注册不存在,则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用者两个扩展方法</li></ul><h2 id="构造函数的选择"><a href="#构造函数的选择" class="headerlink" title="构造函数的选择"></a>构造函数的选择</h2><p>如果IServiceProvider对象试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，最终被选择出来的构造函数必须具备一个基本的条件：</p><ul><li>第一个原则:<strong>IServiceProvider能够提供构造函数的所有参数</strong>.</li><li>第二个原则: <strong>每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集</strong>.</li></ul><h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>对于DI框架体用的三种生命周期（Singleton、Scoped和Transient）来说，Singleton和Transient都具有明确的语义，但是Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由IServiceScopeFactory接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有如图3所示的“父子关系”。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有“父子关系”。</p><p><img src="Use3.jpg" alt="alt"></p><p>如上图所示的树形层次结构只是一种逻辑结构，从对象引用层面来开，通过某个IServiceScope包裹的IServiceProvider对象不需要知道自己的“父亲”是谁，它只关心作为根节点的IServiceProvider在哪里就可以了。下图从物理层面揭示了IServiceScope/IServiceProvider对象之间的关系，任何一个IServiceProvider对象都具有针对根容器的引用。</p><p><img src="Use4.jpg" alt="alt"></p><h2 id="三种生命周期模式"><a href="#三种生命周期模式" class="headerlink" title="三种生命周期模式"></a>三种生命周期模式</h2><ul><li><strong>Singleton</strong>:IServiceProvider创建的服务实例保存在作为根容器的IServiceProvider上，所有多个同根的IServiceProvider对象提供的针对同一类型的服务实例都是同一个对象.</li><li><strong>Scoped</strong>:IServiceProvider创建的服务实例由自己保存，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象.</li><li><strong>Transient</strong>:针对每一次服务提供请求,IServiceProvider总是创建一个新的实例.</li></ul><h2 id="ASP-NET-Core应用下的生命周期"><a href="#ASP-NET-Core应用下的生命周期" class="headerlink" title="ASP.NET Core应用下的生命周期"></a>ASP.NET Core应用下的生命周期</h2><p>DI框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如下图所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider，另一个类则是根据请求及时创建和释放的IServiceProvider，我们可以将它们分别称为Application ServiceProvider和Request ServiceProvider。</p><p><img src="Use5.jpg" alt="alt"></p><p>在ASP.NET Core应用初始化过程中，即请求管道构建过程中使用的服务实例都是由Application ServiceProvider提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个服务范围，该服务范围提供的Request ServiceProvider用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，上述的这个中间件会主动释放掉由它创建的服务范围。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务注册</title>
      <link href="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务注册"><a href="#Asp-Net-Core-DI-服务注册" class="headerlink" title="Asp.Net Core DI-服务注册"></a>Asp.Net Core DI-服务注册</h1><p>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。IServiceCollection实际上是包含了<strong>ServiceDescriptor</strong>对象的集合.</p><h2 id="ServiceDescriptor"><a href="#ServiceDescriptor" class="headerlink" title="ServiceDescriptor"></a>ServiceDescriptor</h2><p>IServiceCollection对象是一个存放服务注册信息的集合.在IServiceCollection/IServiceProvider为核心的DI框架中,与之对应的类型为ServiceDescriptor.</p><p>DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中.如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p>ServiceDescriptor共有5个属性,3个构造函数,如下所示:</p><p><img src="Enrollment1.jpg" alt="alt"></p><p>属性说明:</p><ul><li>ServiceType:注册的服务类型.往往是一个接口</li><li>ImplementationType:实现ServiceType接口的类</li><li>ImplementationInstance:已经实例化的对象</li><li>ImplementationFactory:提供对象的工厂方法.类型为Func<IServiceProvider,object></IServiceProvider,object></li><li>Lifetime:生命周期,枚举类型,对应有三个值,分别为:Singleton,Scoped,Transient</li></ul><p>构造函数说明:<br>ServiceDescriptor的三个属性(ImplementationType,ImplementationInstance,ImplementationFactory)体现了服务实例的三种提供方式，并对应着三个构造函数。</p><ul><li>ServiceDescriptor(Type serviceType,object instace):提供现有对象,该对象就是最终提供的服务实例.</li><li>ServiceDescriptor(Type serviceType,Type implementationType,ServiceLifetime lifetime):最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建.</li><li>ServiceDescriptor(Type serviceType, Func<IServiceProvider, object> factory, ServiceLifetime lifetime):IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例</IServiceProvider,></li></ul><h2 id="IServiceCollection"><a href="#IServiceCollection" class="headerlink" title="IServiceCollection"></a>IServiceCollection</h2><p>DI框架将服务注册(IServiceDescriptor)存储在一个通过IServiceCollection接口表示的集合之中.一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p><img src="Enrollment2.jpg" alt="alt"></p><p>我们在应用启动的时候所做的服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程.考虑到服务注册是一个高频调用的操作,所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作.</p><p>DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中.如下所示的是针对Singleton模式的AddSingleton方法重载的定义,针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义.</p><p><img src="Enrollment3.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI框架</title>
      <link href="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-NET-Core-DI框架概览"><a href="#Asp-NET-Core-DI框架概览" class="headerlink" title="Asp.NET Core DI框架概览"></a>Asp.NET Core DI框架概览</h1><p>毫不夸张地说,整个ASP.NET Core框架是建立在一个依赖注入框架之上的,它在应用启动时构建请求处理管道的过程中,以及利用该管道处理每个请求过程中使用到的服务对象均来源于DI容器.该DI容器不仅为ASP.NET Core框架提供必要的服务,同时作为了应用的服务提供者,依赖注入已经成为了ASP.NET Core应用基本的编程模式.</p><h2 id="服务的注册与消费"><a href="#服务的注册与消费" class="headerlink" title="服务的注册与消费"></a>服务的注册与消费</h2><p>ASP.NET Core中的依赖注入框架中,我们添加的服务注册被保存到通过 <strong>IServiceCollection</strong> 接口表示的集合之中,基于这个集合创建的DI容器体现为 <strong>IServiceProvider</strong>.</p><p>DI框架提供了生产实例的三种生命周期模式,分别为:</p><ul><li><strong>Singleton</strong>:整个应用程序生命周期内单例</li><li><strong>Scoped</strong>:单次服务请求内的单例</li><li><strong>Transient</strong>:每次获取均会产生新的对象</li></ul><p>DI框架注册服务时通常会使用三种方式,分别为:</p><ul><li>指定注册非服务类型和实现类型.</li><li>指定一个现有的服务实例.</li><li>指定一个创建服务实例的委托对象.</li></ul><p>当我们在进行服务注册时,可以为同一类型添加一个服务注册,也可以添加多个,实际上添加的所有服务注册都是有效的,在完成服务注册之后，我们调用IServiceCollection接口的扩展方法  <strong>BuildServiceProvider</strong>创建出代表DI容器的IServiceProvider对象,并利用它调用后者的<strong>GetService<T></T></strong>方法来提供相应的服务实例,总时会返回一个服务实例,这里采用了”后来居上”的原则,即总是采用最近添加的服务注册来创建服务实例.如果我们调用另一个扩展方法<strong>GetServices<T></T></strong>,它将利用返回所有服务注册提供的服务实例.如下所示的代码片段.</p><p><img src="DI1.jpg" alt="alt"></p><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p>IServiceProvider之间的层次结构造就了三种不同的生命周期模式：由于Singleton服务实例保存在作为根容器的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。Scoped服务实例被保存在当前IServiceProvider上，所以它只能在当前IServiceProvider对象的“服务范围”保证的单例的。没有实现IDisposable接口的Transient服务则采用“即用即取，用后即弃”的策略。</p><p>接下来我们通过简单的实例来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表DI容器的IServiceProvider对象之后，我们调用其CreateScope方法创建了两个所谓的“服务范围”，后者的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。</p><pre><code>//根节点的ServiceProvidervar root = new ServiceCollection()        .AddTransient&lt;IFoo, Foo&gt;()        .AddScoped&lt;IBar&gt;(_ =&gt; new Bar())        .AddSingleton&lt;IBaz, Baz&gt;()        .BuildServiceProvider();//子节点的ServiceProvidervar provider1 = root.CreateScope().ServiceProvider;var provider2 = root.CreateScope().ServiceProvider;void GetServices&lt;TService&gt;(IServiceProvider provider)&#123;    provider.GetService&lt;TService&gt;();    provider.GetService&lt;TService&gt;();&#125;GetServices&lt;IFoo&gt;(provider1);GetServices&lt;IBar&gt;(provider1);GetServices&lt;IBaz&gt;(provider1);Console.WriteLine();GetServices&lt;IFoo&gt;(provider2);GetServices&lt;IBar&gt;(provider2);GetServices&lt;IBaz&gt;(provider2);输出:Foo Foo Bar Baz     Foo Foo Bar</code></pre>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc模式对应的几种设计模式</title>
      <link href="/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ioc原则对应的几种设计模式"><a href="#Ioc原则对应的几种设计模式" class="headerlink" title="Ioc原则对应的几种设计模式"></a>Ioc原则对应的几种设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IoC仅仅是一种设计原则,针对IoC的设计原则有多种设计模式,例如:模板方法,简单工厂,抽象工厂等.以下通过这三种设计模式阐述如何实现IoC设计原则的.</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据按照预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。</p><p>所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供一组相关的对象。</p><p>具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。</p><h2 id="依赖注入-DI容器"><a href="#依赖注入-DI容器" class="headerlink" title="依赖注入(DI容器)"></a>依赖注入(DI容器)</h2><p>DI:Dependency Injection.含义为依赖注入.DI是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。</p><p>在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供所需的每一个服务实例。<br>我们将这个被框架用来提供服务的容器称为“DI容器”.</p><p>从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。依赖注入主要有三种方式:[构造器注入]  [属性注入] [方法注入]</p><h3 id="Service-Locator"><a href="#Service-Locator" class="headerlink" title="Service Locator"></a>Service Locator</h3><p>假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器，那么我们可以采用如下两种方式(ServiceProvider和ServiceLocator)来定义这个服务类型Foo.</p><pre><code>public class Foo : IFoo&#123;    public IBar Bar &#123; get; &#125;    public IBaz Baz &#123; get; &#125;    //方式一:通过构造器注入,通过框架生成服务实例    public Foo(IBar bar, IBaz baz)    &#123;        Bar = bar;        Baz = baz;    &#125;      public async Task InvokeAsync()    &#123;        await Bar.InvokeAsync();        await Baz.InvokeAsync();    &#125;&#125;public class Foo : IFoo&#123;    public Cat Cat &#123; get; &#125;    public Foo(Cat cat) =&gt; Cat = cat;     public async Task InvokeAsync()    &#123;        //方式二:Service Locator,主动去获取服务实例        await Cat.GetService&lt;IBar&gt;().InvokeAsync();        await Cat.GetService&lt;IBaz&gt;().InvokeAsync();    &#125;&#125;</code></pre><p>以上两种方式虽然都解决了针对服务的解耦问题,但是第二种使用方式不能称之为”依赖注入”,而是一种被称为”Service Locator”的设计模式.Service Locator模式同样具有一个通过服务注册创建的全局容器来提供所需的服务实例,该容器被称为”Service Locator”.DI容器和Service Locator实际上是同一事物在不同设计模型的不同称谓罢了.DI容器和Service Locator之间的差异体现在 <strong>“被谁使用”</strong>.DI容器的使用者是框架自身,Service Locator的使用者是应用程序.一般情况下我们尽可能通过构造器注入的方式使用,尽量不要使用Service Locator模式.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core IoC</title>
      <link href="/2019/10/19/Asp.NetCoreIoC/"/>
      <url>/2019/10/19/Asp.NetCoreIoC/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-IOC模式"><a href="#Asp-Net-Core-IOC模式" class="headerlink" title="Asp.Net Core IOC模式"></a>Asp.Net Core IOC模式</h1><p>本系列文章来源于大内老A的博客,对博客内容进行了略微整理,方便自己以后查阅.</p><h2 id="IoC名词解释"><a href="#IoC名词解释" class="headerlink" title="IoC名词解释"></a>IoC名词解释</h2><p>IoC全名为Inverse of Control,含义为”控制倒置”,针对软件设计行业来说,IoC所谓的控制其实是”针对流程的控制”.控制权原来在应用程序,应用程序可以根据自己的场景定义流程,而IoC原则主张流程的控制权转移到框架中,由框架来定义流程的步骤,我们可以通过下图来说明控制权的转移过程.</p><p><img src="IOC1.jpg" alt="alt"></p><h2 id="流程定制"><a href="#流程定制" class="headerlink" title="流程定制"></a>流程定制</h2><p>我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制.作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。</p><p>我们可以说得更加宽泛点。如下图所示我们将一个泛化的工作流程（A=&gt;B=&gt;C）被定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。 </p><p><img src="IOC2.jpg" alt="alt"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一方面IoC对框架的流程进行了封装,消费者只需要执行,框架利用引擎驱动整个流程的运转,应用程序无须关心该工作流程的细节,只需要启动引擎即可.另一方面,框架会提供一系列的扩展点,应用程序则通过定义扩展的方式实现对流程某个环节的定制,在引擎启动前,应用程序将所需的扩展注册到框架中,一旦引擎被正常启动,这些注册的扩展会自动参与到整个流程的执行过程中.这样就实现了框架对流程的高度复用和扩展.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript学习笔记</title>
      <link href="/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h2><ul><li>ECMAScript:由ECMA-262定义,提供核心语言功能</li><li>文档对象模型(DOM):提供访问和操作网页内容的方法和接口</li><li>浏览器对象模型(BOM):提供与浏览器交互的方法和接口</li></ul><h2 id="变量-作用域和内存问题"><a href="#变量-作用域和内存问题" class="headerlink" title="变量 作用域和内存问题"></a>变量 作用域和内存问题</h2><p>JavaScript的变量与其他语言有很大区别.不存在定义某个变量必须要保存何种数据类型值的规则,变量的值以及数据类型可以在脚本的生命周期内改变.</p><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li><p>从一个变量向另一个变量赋值基本类型的值,会在变量对象上创建一个新值,然后把该值赋值带为新变量分配的位置上.</p></li><li><p>当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份跟放到为新变量分配的空间中,不同的是,这个值的副本实际上是一个指针.而这个指针指向存储在堆内存中的一个对象.</p></li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>Js中所有函数的参数都是按值传递的.不同的是,对于基本类型的值来说,被传递的值会复制给一个局部变量.对于引用类型的值,会把这个值在内存中的地址复制给一个局部变量.<strong>因此这个局部变量的变化会反映在函数的外部</strong>.</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>检测基本数据类型,通常使用typeof操作符,换句话说,typeof操作符是确定一个变量是字符串,数字,布尔值还是undefined的最佳工具.</li><li>检测引用类型,通常使用instanceof操作符.语法如下:<br><code>result = variable instanceof constructor</code></li></ul><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>JavaScript函数不介意传递进来多少个参数,也不在乎传进来参数是什么类型,即使定义的函数只接受两个参数,调用时也未必要传递两个参数,原因是JavaScript函数的参数在函数内部用一个arguments对象来表示.</p><ul><li><p>参数个数</p><p> 当实参比函数声明指定的形参要少,剩下的形参都将设置为undefined,通常会使用逻辑或(||)来判断参数是否有值来给变量设置默认值.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(x,y)&#123;</span><br><span class="line">    x = x||1;</span><br><span class="line">    y = y||2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(3);</span><br></pre></td></tr></table></figure></li><li><p>对象参数</p><p> 当函数中需要传递多个参数时,一般会使用对象参数的方式,通过键/值对的形式传递参数,这样参数的顺序就无关紧要了.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记整理</title>
      <link href="/2017/02/22/css/"/>
      <url>/2017/02/22/css/</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>css有三种样式嵌入方式，分别为内联，嵌入，外部引用，一般情况下优先级为内联样式表&gt;嵌入样式表&gt;外部样式表，前提是外部引用css文件在嵌入的前边，如果外部引用在嵌入的后边那么外部引用的优先级将高于嵌入的。简而言之，css优先级是以离标签的距离为依据的。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>取所有选择器所选择元素的并集，然后集中设置样式，语法为在每个选择器中间加上逗号，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1,selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>给所有选择器选中的标签中，相交的那部分标签设置属性。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1Selecotr2&#123;</span><br><span class="line">   属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：Selector1和selector2之间没人任何符号也没有空格。</em><br><span id="more"></span></p><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>给指定选择器后面紧跟的那个选择器中的标签设置属性，必须是第一个选择器后边紧跟的第一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1+Selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>给指定选择器后面的所有选择器选中的所有标签设置属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1~Selector2&#123;</span><br><span class="line">  属性：值;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><p>selector1:first-child  选中selector1同级别中的第一个元素，如果是selector1对应的元素则选中，否则无法选中任何元素。<br>selector1:last-child 选中同级别中的最后一个标签，如果该标签是Selector1对应的元素，则选中,否则无法选中任何元素。<br>selector1:nth-child(n)选中同级别中的第N个元素，如果该元素是选择器1对应标签则选中<br>selector1:nth-last-child(n)倒数第N个。<br>selector1:only-child选中父元素中唯一的元素。</p><p>selector1:first-of-type 选中同级别中同类型的第一个元素<br>selector1:last-of-type  选中同级别中同类型的最后一个元素<br>selector1:nth-of-type(n) 取出同级别同类型的第N个元素，<br>selector1:nth-last-of-type(n) 同级别同类型倒数第N个元素<br>selector1:only-of-type 选中父元素中唯一类型的元素</p><p>selector1:nth-child(odd) 奇数选择器<br>selector1:nth-child(even) 偶数选择器<br>selector1:nth-child(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><p>selector1:nth-of-type(odd) 奇数选择器<br>selector1:nth-of-type(even) 偶数选择器<br>selector1:nth-of-type(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p><strong>[attribute]:</strong> 根据指定的属性名称找到对应的标签<br><strong>[attribute=value]:</strong>找到有指定属性，并且属性的取值等于value的标签，常见的应用场景用于区分input属性。例如：Input[type=text]<br><strong>[attribute^=value]:</strong>属性值以value开头的元素 CSS3( [attribute|=value] css2)<br><strong>[attribute$=value]:</strong>属性值以value结尾的<br><strong>[attribute*=value]:</strong>属性值包含value css3([attribute~=value] css2)</p><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1.继承性"></a>1.继承性</h3><p>给父元素设置一些属性，子元素以及后代元素都可以使用，这个我们称之为继承性。并不是所有的属性都可以集成，<strong>只有以color/font-/text-/line开头的属性才可以继承。</strong><br><strong>注意：</strong>CSS继承性中的特殊性：a标签的颜色及样式不可以继承;h标签的字体大小不能继承。<br><strong>应用：</strong>一般用于设置网页上的一些共性信息，例如网页的文字颜色，文字大小等内容，一般在body{}中进行统一设置</p><h3 id="2-层叠性"><a href="#2-层叠性" class="headerlink" title="2.层叠性"></a>2.层叠性</h3><p>在样式表现时，有可能会出现两个或更多的样式寻找同一元素，这就可能出现表现层的不确定性和样式冲突，CSS通过“层叠”给每个规则分配一个重要度。</p><h3 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3.优先级"></a>3.优先级</h3><p><strong>1&gt;</strong>     是否是直接选中（间接选中就是指继承）,如果是间接选中，那么谁离目标比较近就取谁的值。</p><p><strong>2&gt;</strong>     如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级层叠，具体优先级为:<strong>id&gt;class&gt;标签&gt;通配符(*)&gt;继承&gt;浏览器默认。</strong></p><p><strong>3&gt;</strong>     如果都是直接选中，并且都是同类型的选择器，那么谁写的靠后取谁的值。</p><p><strong>4&gt;</strong>     !important 用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级提升为最高，!important 只能用于直接选中，不能用于间接选中，!important的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">  属性:值!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5&gt;</strong>     <strong>优先级的权重</strong>:当多个选择器混合在一起使用时，可以通过计算权重来判断谁的优先级最高。权重的计算规则：首先计算选择器中有多少个id，id多的选择器优先级最高；如果id个数一样，那么再看类名的个数，类名多个优先级高；如果类名个数一样，那么标签名个数多的优先级高；如果都一样，那么谁的位置靠后，取谁的值。</p><h2 id="CSS属性值"><a href="#CSS属性值" class="headerlink" title="CSS属性值"></a>CSS属性值</h2><h3 id="1-文本属性"><a href="#1-文本属性" class="headerlink" title="1.文本属性"></a>1.文本属性</h3><h4 id="1-1-中文字间距-字母间距-单词间距"><a href="#1-1-中文字间距-字母间距-单词间距" class="headerlink" title="1.1 中文字间距 字母间距  单词间距"></a>1.1 中文字间距 字母间距  单词间距</h4><p>1）Letter-spacing用来设置中文字间距和字母间距。<br>2）word-spacing 用来设置英文单词的间距。</p><h4 id="1-2-text-align"><a href="#1-2-text-align" class="headerlink" title="1.2 text-align"></a>1.2 text-align</h4><p><code>text-align：center</code>可以设置块级元素内文本和图片的水平居中<br><strong>注：内联元素之间的间距是由于换行导致的。</strong></p><h4 id="1-3-font"><a href="#1-3-font" class="headerlink" title="1.3 font"></a>1.3 font</h4><h5 id="1-3-1-font字体大小单位"><a href="#1-3-1-font字体大小单位" class="headerlink" title="1.3.1 font字体大小单位"></a>1.3.1 font字体大小单位</h5><p>font属性简写至少要包含 font-family 和font-size属性。如：font：12px “微软雅黑”;<br>Em值的大小是以当前文档中font-size的大小为参考点的，果font-size为16px，则1em = 16px，如果font-size为20px则1em = 20px。<br>特殊情况：当给font-size取值以em为单位时，则此时计算的标准是以父元素font-size为基础的。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*css:*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  p&#123;font-size:14px&#125;</span><br><span class="line">  span&#123;font-size:0.8em;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html:*/</span><br><span class="line">  &lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-3-2-中文英文单独设置字体"><a href="#1-3-2-中文英文单独设置字体" class="headerlink" title="1.3.2 中文英文单独设置字体"></a>1.3.2 中文英文单独设置字体</h5><p>  中文字体里边都包含了英文，英文字体里边没有包含中文，也就是说中文字体可以处理英文，而英文字体不能处理中文，所以如果想要中英文分别单独设置字体，需要采用以下格式：<br>Font—family:”Times New Roman”,”微软雅黑”,将英文字体写在前边，中文字体写在后边作为备选方案。<br>常用字体 中文：宋体/黑体/微软雅黑 英文：Times New Roman / Arial</p><h4 id="1-4-文本垂直居中"><a href="#1-4-文本垂直居中" class="headerlink" title="1.4 文本垂直居中"></a>1.4 文本垂直居中</h4><p>文字在行高中默认是垂直居中的，我们经常将盒子的高度和行高设置一样，那么这样就可以保证单行文字在盒子中是垂直居中的，简而言之：要想单行文字在盒子中垂直居中，那么只需要设置line-height为盒子的height值即可。</p><h5 id="1-4-1-单行文本的垂直居中"><a href="#1-4-1-单行文本的垂直居中" class="headerlink" title="1.4.1 单行文本的垂直居中"></a>1.4.1 单行文本的垂直居中</h5><p>通过设置父元素的height和line-height高度一致来实现，(height该元素的高度，line-height：顾名思义，行高 指在文本中，行与行基线间的距离)，line-height与font-size的计算值之差，在css中称为行间距，分为两半，分别加到一个文本行内容的顶部和底部。</p><h5 id="1-4-2-多行文本及图片的垂直居中"><a href="#1-4-2-多行文本及图片的垂直居中" class="headerlink" title="1.4.2 多行文本及图片的垂直居中"></a>1.4.2 多行文本及图片的垂直居中</h5><p><strong>方法一：</strong><br>使用插入 table  (包括tbody、tr、td)标签，同时设置 vertical-align：middle。<br>css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*Html*/</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    height:300px;</span><br><span class="line">    background:#ccc;</span><br><span class="line">    display:table-cell;/*IE8以上及Chrome、Firefox*/</span><br><span class="line">    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-文本在容器中自动换行"><a href="#1-5-文本在容器中自动换行" class="headerlink" title="1.5 文本在容器中自动换行"></a>1.5 文本在容器中自动换行</h4><p><code>word-break:break-all;</code> 例如div宽200px，它的内容就会到200px自动换行，如果该行末端有个英文单词很长（congratulation等），它会把单词截断，变成该行末端为conra(congratulation的前端部分)，下一行为tulation（conguatulation）的后端部分了。</p><p> <code>word-wrap:break-word;</code> 例子与上面一样，但区别就是它会把congratulation整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断掉的。</p><h3 id="2-background"><a href="#2-background" class="headerlink" title="2. background"></a>2. background</h3><p><code>background-image:url();</code>设置元素背景图片</p><p><code>background-repeat</code>: repeat(默认) repeat-x repeat-y no-repeat</p><p><code>background-position:</code>水平方向 垂直方向;有两种取值方式，分别为具体的方位名词和像素如下：<br>具体的方位名词：水平方向(left center right),垂直方向(top center bottom)<br>具体的像素:浏览器的XY坐标系，X轴向右为正，Y轴向下为正。</p><p><code>background-attachment:fixed</code>(不会随着滚动条滚动)、 scroll(默认取值)</p><p><strong>背景属性缩写的格式:background:background-color  background-image  background-repeat background-attachment  Backgroud-position</strong></p><h3 id="3-CSS-Reset"><a href="#3-CSS-Reset" class="headerlink" title="3.CSS Reset"></a>3.CSS Reset</h3><p>在实际项目开发中我们经常需要清空浏览器给元素设置的默认值，常见的比如margin padding等，在百度中查找YUI CSS Reset或者输入网址:<br><strong><a href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css</a></strong><br>复制其中的内容，粘贴进我们项目的reset.css文件即可。</p><h3 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h3><h4 id="4-1-box-sizing"><a href="#4-1-box-sizing" class="headerlink" title="4.1 box-sizing"></a>4.1 box-sizing</h4><p>盒子元素的宽度 = border-left+padding-left+content-width+padding-right+border-right<br>盒子元素的高度 =border-top+padding-top+content-height+padding-bottom+border-bottom<br>因此假如一个DIV的初始大小为100px*100px，那么加入border或者padding会改变盒子元素自身的大小，从而影响整个网页的布局，如果需要盒子的宽高保持不变，那么需要相应的减少内容的大小，我们可以通过设置属性：<br><code>box-sizing:border-box;</code>,让其自动适应，保持宽高不变。</p><h4 id="4-2-margin"><a href="#4-2-margin" class="headerlink" title="4.2 margin"></a>4.2 margin</h4><p>Margin穿透现象：如果两个盒子是嵌套关系，那么设置内部盒子的margin-top值，外部盒子的margin-top值会被改变，这种情况我们称之为margin穿透现象。解决办法有两种：<br><strong>1)</strong>  给外边的盒子设置边框。<br><strong>2)</strong>     控制嵌套关系盒子之间的距离，首先应该考虑外边盒子的padding属性，其次考虑内层盒子的margin属性。<br><strong>3)</strong>  <code>overflow:hidden;</code></p><h4 id="4-3-块级元素水平居中"><a href="#4-3-块级元素水平居中" class="headerlink" title="4.3 块级元素水平居中"></a>4.3 块级元素水平居中</h4><p>在嵌套关系的盒子中，我们可以通过设置内层盒子的<code>margin:0 auto;</code>让内层盒子在外边的盒子水平居中，margin的auto取值只对水平方向上有效，对垂直方向上是无效的。</p><h3 id="5-浮动流"><a href="#5-浮动流" class="headerlink" title="5.浮动流"></a>5.浮动流</h3><p><strong>1&gt;</strong> 浮动流不区分 块级元素/行内元素/行内块级元素，无论块级元素/行内元素/行内块级元素都可以水平排版。<br><strong>2&gt;</strong> <strong>浮动流中无论块级元素/行内元素/行内块级元素都可以设置宽高。</strong><br><strong>3&gt;</strong> <strong>当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。</strong><br><strong>4&gt;</strong>设置浮动后，盒子的margin属性不会失效。<br><strong>5&gt;</strong> 浮动元素贴靠现象<br>如果父元素的宽度能够显示所有浮动元素, 那么浮动的元素会并排显示; 如果父元素的宽度不能显示所有浮动元素, 那么会从最后一个元开始往前贴靠, 如果贴靠了前面所有浮动元素之后都不能显示, 最终会贴靠到父元素的左边或者右边。<br><strong>6&gt;</strong>浮动元素字围现象<br>浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象。</p><h3 id="6-清除浮动"><a href="#6-清除浮动" class="headerlink" title="6.清除浮动"></a>6.清除浮动</h3><p><strong>方式一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box1::after&#123;</span><br><span class="line">  Content:&quot;&quot;</span><br><span class="line">  Display:block;</span><br><span class="line">  Height:0;</span><br><span class="line">  Visibility:hidden;</span><br><span class="line">  Clear:both;</span><br><span class="line">&#125;</span><br><span class="line">/*这种方式在IE6中显示不正常，需要加入额外的属性*/</span><br><span class="line">.box1&#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><pre><code>overflow:hidden;</code></pre><p><strong>注：Overflow:hidden属性的作用有以下几点：</strong><br>        <strong>1.</strong>将超出标签范围的内容才减掉。<br>        <strong>2.</strong>清除浮动。内部盒子浮动后，外部盒子的高度无法被撑起，会缩成一条，这时候对父元素使用clear：both是无法清除浮动的影响的，需要设置overflow：hidden才行。<br>       <strong>3</strong>.外部盒子设置overflow：hidden；保证了内部盒子在设置了margin-top属性后外部盒子的margin-top不会发生变化。</p><h3 id="7-定位流"><a href="#7-定位流" class="headerlink" title="7.定位流"></a>7.定位流</h3><p>定位流分为：相对定位、绝对定位、固定定位、静态定位四种类型。</p><h4 id="7-1-相对定位"><a href="#7-1-相对定位" class="headerlink" title="7.1 相对定位"></a>7.1 相对定位</h4><p>相对定位就是相对于自己以前在标准路中的位置作为参考点进行移动，语法如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position：relative；</span><br><span class="line">Top:</span><br><span class="line">Bottom:</span><br><span class="line">Left:</span><br><span class="line">Right:</span><br></pre></td></tr></table></figure><br><strong>1&gt;</strong>    相对定位不会脱离标准流，会继续在标准流中占用一份空间。<br><strong>2&gt;</strong>在相对定位中同一个方向上的定位属性只能使用一个。<br><strong>3&gt;</strong>    由于相对定位是不脱离标准流的，所以相对定位中区分块级 行内 行内块级元素。<br><strong>4&gt;</strong>给设置相对定位的元素设置margin属性，是给元素以前的位置设置margin，并不是给定位之后的元素设置margin。</p><h4 id="7-2-绝对定位"><a href="#7-2-绝对定位" class="headerlink" title="7.2 绝对定位"></a>7.2 绝对定位</h4><p><strong>1&gt;</strong>绝对定位的元素是脱离标准流的<br><strong>2&gt;</strong>绝对定位中是不区分行内 块级 行内块级元素<br><strong>3&gt;</strong>参考点：默认情况下所有的绝对定位元素，无论是否有祖先元素，对会以body 作为参考点；<br>  &nbsp;  &nbsp; &nbsp;      a. 如果一个绝对定位有祖先元素，并且这个祖先元素也是定位流，并且这个定位流只能是：绝对定位、相对定位、固定定位。那么这个绝对定位的元素会以这个祖先元素作为参考点。<br>   &nbsp;  &nbsp; &nbsp;      b. 如果绝对定位有多个祖先元素，并且多个祖先元素均为定位流，那么这个绝对定位的元素会以离他最近的元素为参考点。<br><strong>4&gt;</strong>如果一个绝对定位的元素以body为参考点，其实是以网页首屏宽度为参考点，而不是以整个网页的宽度和高度为参考点。<br><strong>5&gt;</strong> 绝对定位的元素会忽略祖先元素的padding值。</p><h4 id="7-3-子绝父相"><a href="#7-3-子绝父相" class="headerlink" title="7.3 子绝父相"></a>7.3 子绝父相</h4><p>这是通常情况下设置绝对定位元素的方式，将要设置绝对定位元素的父元素设置为相对定位，然后自身设置为绝对定位，那么久会以父元素作为参照点进行偏移，俗称“子绝父相”.<br>如何让绝对定位的元素在父元素中水平居中，只需要设置绝对定位元素的left：50%，然后再设置绝对定位的元素margin-left，负的元素宽度的一半px; </p><h4 id="7-4-不定宽块级元素水平居中"><a href="#7-4-不定宽块级元素水平居中" class="headerlink" title="7.4 不定宽块级元素水平居中"></a>7.4 不定宽块级元素水平居中</h4><p>通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*Html代码*/</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    left:50%</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container ul&#123;</span><br><span class="line">    list-style:none;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    </span><br><span class="line">    position:relative;</span><br><span class="line">    left:-50%;</span><br><span class="line">&#125;</span><br><span class="line">.container li&#123;float:left;display:inline;margin-right:8px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-3-固定定位"><a href="#7-3-固定定位" class="headerlink" title="7.3 固定定位"></a>7.3 固定定位</h4><p> 固定定位：可以让某个盒子不随着网页滚动条而滚动。<br>固定定位的元素是脱离标准流的，不会占用标准流的空间，固定定位和绝对定位一样不区分行内/块级 /行内块级元素。<br><strong>注：IE6不支持position：fixed.</strong></p><h4 id="7-4-z-index"><a href="#7-4-z-index" class="headerlink" title="7.4 z-index"></a>7.4 z-index</h4><p>默认情况下，所有设置了position属性的元素都有一个Z-index属性，默认取值为0，z-index属性的作用是专门用于控制定位流元素的覆盖关系的。</p><p>1&gt;默认情况下定位流的元素会盖住标准流的元素。<br>2&gt;定位里的元素后面编写的会盖住前面编写的元素。<br>3&gt;如果定位流的元素设置了z-index属性，那么谁的z-index属性大，谁就显示在上面。</p><p><strong>从父现象：</strong><br>如果两个元素的父元素都没有设置z-index属性，那么谁的z-index属性大就显示在上面</p><p>如果两个元素的父元素设置了z-index属性，那么他们自身的z-index属性将失效。</p><h4 id="7-5-隐形改变display类型"><a href="#7-5-隐形改变display类型" class="headerlink" title="7.5 隐形改变display类型"></a>7.5 隐形改变display类型</h4><p>当元素设置一下两个句之一：</p><ol><li>position:ablsolute</li><li>float:left或right<br>简单来说，只要html代码中出现以上两句之一，元素的display显示类型就自动变为display：inline-block的方式，当然就可以设置元素的width和height了，<strong>且默认宽度不占满父元素</strong>。</li></ol><h3 id="8-a标签伪类选择器"><a href="#8-a标签伪类选择器" class="headerlink" title="8 .a标签伪类选择器"></a>8 .a标签伪类选择器</h3><p>:link 修改从未被访问过状态下的样式<br>:visited 修改被访问过的状态下的样式<br>:active 修改鼠标长按状态下的样式<br>:hover 修改鼠标悬停在a标签上的状态</p><p>注意点：a标签的伪类选择器一起出现，那么有严格的顺序要求，必须按照这个顺序：<br><strong><em>link  visited  hover  active</em></strong></p><h3 id="9-CSS3圆角"><a href="#9-CSS3圆角" class="headerlink" title="9.CSS3圆角"></a>9.CSS3圆角</h3><p>Border-radius是向元素添加圆角边框。使用方式：<br><code>Border-radius:10px;</code>   /<em>所有角都使用半径为10px的圆角</em>/<br><code>Border-radius:5px 4px 3px 2px;</code>四个半径值分别对应左上、右上、右下、左下</p><p><strong>1.实心上半圆</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:50px;/*是width的一半*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实心圆</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:100px;/*与width设置一致*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="10-盒子边框阴影"><a href="#10-盒子边框阴影" class="headerlink" title="10.盒子边框阴影"></a>10.盒子边框阴影</h3><p>Box-shadow是向盒子添加阴影，支持添加一个或多个，如果需要添加多个阴影只需要用逗号隔开即可。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box-shadow:X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</span><br></pre></td></tr></table></figure><p><strong>X轴偏移量：</strong> 必选参数，值可以正负，正值表示向右偏移，负值向左<br><strong>Y轴偏移量：</strong> 必选参数，值可以正负，正值表示向下偏移，负值向上。<br><strong>阴影模糊半径：</strong> 可选参数，值只能为正，如果值为0，代表阴影没有模糊效果。<br><strong>阴影扩展半径：</strong> 可选参数，值可以为正负，越大阴影面积越大。<br><strong>投射方式：</strong> 其中投影方式默认为外阴影方式，可以设置为inset让其显示为内部阴影。</p><h3 id="11-实现双列布局一列固定宽度，另外一列自适应的方式。"><a href="#11-实现双列布局一列固定宽度，另外一列自适应的方式。" class="headerlink" title="11. 实现双列布局一列固定宽度，另外一列自适应的方式。"></a>11. 实现双列布局一列固定宽度，另外一列自适应的方式。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*HTML*/</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*CSS*/</span><br><span class="line">.main&#123;</span><br><span class="line">width:100%;</span><br><span class="line">height:300px;</span><br><span class="line">background:darkred;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left&#123;</span><br><span class="line"> width:200px;</span><br><span class="line"> height:300px;</span><br><span class="line"> background:blue;</span><br><span class="line"> position:absolute;</span><br><span class="line"> left:0px;</span><br><span class="line"> top:0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right&#123;</span><br><span class="line">margin-left:210px;</span><br><span class="line">height:300px;</span><br><span class="line">background:orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html学习笔记整理</title>
      <link href="/2017/02/22/html/"/>
      <url>/2017/02/22/html/</url>
      
        <content type="html"><![CDATA[<h2 id="引用标签"><a href="#引用标签" class="headerlink" title="引用标签"></a>引用标签</h2><p>引用标签会自动对其中的内容加入双引号，有单行文本和长段文本两种方式：</p><pre><code>&lt;q&gt;引用标签&lt;/q&gt; //适用单行文本&lt;blockquote&gt;引用标签&lt;/blockquote&gt; //长段文本</code></pre><h2 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h2><p>在html中输入多个空格是不起作用的，并且换行也会被当做一个空格来看待，如果需要多个空格请使用实体字符，如:<code>&amp;nbsp;</code></p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><pre><code>&lt;address&gt;地址&lt;/address&gt; //显示地址</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>&lt;code&gt;代码&lt;/code&gt;  //显示程序代码&lt;pre&gt;大段代码&lt;/pre&gt; //显示大段代码</code></pre><h2 id="表格摘要"><a href="#表格摘要" class="headerlink" title="表格摘要"></a>表格摘要</h2><p>  摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：</p><pre><code>&lt;table summary=&quot;表格简介文本&quot;&gt;&lt;/table&gt;</code></pre><h2 id="使用mailto在网页中连接Email地址"><a href="#使用mailto在网页中连接Email地址" class="headerlink" title="使用mailto在网页中连接Email地址"></a>使用mailto在网页中连接Email地址</h2><pre><code>&lt;a href=&quot;mailto:yy@imooc.com?subject=&#39;观了不起的盖茨比有感&#39;&amp;body=&#39;你好，对此评论有些想法&#39;&quot;&gt;发送邮件给我&lt;/a&gt;</code></pre><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>用于绑定input在用户点击label标签的文字后即可聚焦input，有两种绑定方式。<br><strong>方式一:</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">     &lt;label for=”account”&gt;账号&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text”  id=”account”/&gt;</span><br><span class="line">     &lt;label for=”pwd”&gt;密码&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text” id=”pwd”&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p><strong>方式二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  账号:&lt;input type=”text”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  密码:&lt;input type=”password”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="HTML5-DTD文档类型声明"><a href="#HTML5-DTD文档类型声明" class="headerlink" title="HTML5 DTD文档类型声明"></a>HTML5 DTD文档类型声明</h2><pre><code>&lt;!DOCTYPE html&gt; //必须位于html文档的第一行</code></pre><span id="more"></span><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p><strong>width:</strong>设置图片的宽度</p><p><strong>height：</strong>设置图片的高度</p><p><em>注： 如果img标签没有指定需要显示的图片的宽高，那么系统会按照图片默认的宽高来显示。想要保持img图片原图的宽高比，只需要设置img宽度和高度其中之一，另外一个属性会根据原图的宽高比自动计算得出。</em></p><p><strong>title:</strong>当鼠标悬停在图片上时，弹出的描述狂中显示的内容。</p><p><strong>alt(alternate):</strong>当需要显示的图片找不到时，显示的替代的文字内容。</p><h2 id="br"><a href="#br" class="headerlink" title="br"></a>br</h2><p>&nbsp;&nbsp;&nbsp;br标签用于换行，多个br标签可以连续使用，使用了多少个br标签就会换多少行，由于html的作用就是给文本添加语义，而br标签的语义是不另起一个段落换行，而在企业开发中一般情况下需要换行都是因为需要另起一个段落，所以在企业开发中很少使用br标签，换行另起段落一般用P标签。</p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p> base标签专门用来统一指定当前网页中所有的a标签的打开方式,base标签必须写在head标签之间,格式为：</p><pre><code>&lt;base target=”_blank”&gt;               //必须位于head之间</code></pre><p><em>注：如果即在base中指定了target又在a标签中指定了target，那么浏览器会按照a标签中指定方式的来执行。</em></p><h3 id="假链接"><a href="#假链接" class="headerlink" title="假链接"></a>假链接</h3><p>为a标签的href属性分配一个#或者JavaScript，以实现特定的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#”&gt;返回顶部&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”javascript:”&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>锚点是文档中某行的一个记号，类似于书签，用于链接到文档中的某个位置。当定义了锚点后，我们可以创建直接跳至该锚点（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 创建锚点需要以下几个步骤：<br>1) 给需要定位的目标标签添加一个ID属性。<br>2) 告诉a标签你需要转到的目标标签。<br>3) 格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#target”&gt;跳转到目标&lt;/a&gt;</span><br><span class="line">&lt;h1 id=”target”&gt;我是目标&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><em>注：使用这种方式跳转是没有过渡动画的，一下就跳转到了指定位置  a标签除了可以跳转到当前界面的指定位置，还可以直接跳转到其他界面的指定位置。</em></p><h2 id="定义列表-dl-definition-list"><a href="#定义列表-dl-definition-list" class="headerlink" title="定义列表 dl(definition list)"></a>定义列表 dl(definition list)</h2><p>常用于网站底部的信息、图文混排等。格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;   //definition title 定义列表中的标题</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;  //definition description 定义列表标题的描述</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格摘要-1"><a href="#表格摘要-1" class="headerlink" title="表格摘要"></a>表格摘要</h3><p>摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table summary=”表格简介文本”&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure></p><h3 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h3><p>表格标题永远处于表格的水平中心位置，语法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;caption&gt;</span><br><span class="line">     &lt;h2&gt;表格标题&lt;/h2&gt;</span><br><span class="line">  &lt;/caption&gt;                 //表格标题</span><br><span class="line">  &lt;thead&gt;&lt;/thead&gt;            //表格头</span><br><span class="line">  &lt;tbody&gt;&lt;/tbody&gt;            //表格内容体</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="细线表格"><a href="#细线表格" class="headerlink" title="细线表格"></a>细线表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  Table&#123;</span><br><span class="line">Padding:0.1px;</span><br><span class="line">Background-Color:steelblue;  //定义边框的颜色</span><br><span class="line">Width:650px;</span><br><span class="line">Height:40px;</span><br><span class="line">Font:16px “微软雅黑”;</span><br><span class="line">Text-align:center;</span><br><span class="line">  &#125;</span><br><span class="line">  Table tr&#123;</span><br><span class="line">    Background-Color:white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h2><p>给input输入框绑定待选项列表，格式如下：<br>先定义一个datalist列表项，给它分配一个唯一的ID “cars”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;datalist  id=”cars”&gt;</span><br><span class="line">    &lt;option&gt;奔驰&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;；路虎&lt;/option&gt;</span><br><span class="line">&lt;option&gt;Jeep&lt;/option&gt;</span><br><span class="line">&lt;option&gt;劳斯莱斯&lt;/option&gt;</span><br><span class="line">&lt;option&gt;宝马&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p>然后给输入框添加一个属性list，值填写刚才定义列表的id值”cars”。<br>请输入你的车型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=”text” list=”cars”/&gt;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>可以通过给option标签添加一个selected属性来制定列表的默认选中项;可以给option进行分组，使用optgroup label标签的名字显示了分组的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line"> &lt;optgroup label=”北京”&gt;</span><br><span class="line"> &lt;option&gt;西城区&lt;/option&gt;</span><br><span class="line"> &lt;option selected=”selected”&gt;朝阳区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;通州区&lt;/option&gt;</span><br><span class="line"> &lt;/optgroup&gt;</span><br><span class="line"> &lt;optgroup label=”广州&gt;</span><br><span class="line"> &lt;option&gt;天河区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;越秀区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;黄浦区&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="textArea"><a href="#textArea" class="headerlink" title="textArea"></a>textArea</h2><p>Textarea通过css的属性resize:none可以禁止用户自由拉伸textarea</p><h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p><strong>src:</strong>用于告诉video标签需要播放的视频地址。<br><strong>autoplay：</strong>用于告诉video标签是否需要自动播放视频 autoplay = “autoplay”。<br><strong>controls:</strong> 用于告诉video标签是否显示控制条 controls = “controls”。<br><strong>poster:</strong> 用于设置视频在播放之前，显示的图片。<br><strong>loop:</strong> 一般用于广告视频，用于告诉video标签播放完毕后是否需要循环播放。Loop = “loop”。<br><strong>preload:</strong> 预加载视频，但是需要注意preload和autoplay相冲。<br><strong>muted:</strong> 静音   muted = “muted”。<br><strong>width/height：</strong>二者只设置一个，保持视频的宽高比</p><p>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式，但是显然所有浏览器都通过video标签播放视频有一个前提条件，那就是浏览器必须支持H5，可以通过一个JS框架叫做<strong>html5demia</strong>来实现兼容。</p><p>video的第二种格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">&lt;source src=”video/1.webm” type=”video/webm”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/2.mp4” type=”video/mp4”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/3.ogg” type=”video/ogg”&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="marquee"><a href="#marquee" class="headerlink" title="marquee"></a>marquee</h2><p>Marquee标签虽然不是w3c标准的标签，，但是各大浏览器对其支持很好。Marquee标签是一个内联块级元素，主要用于实现类似于跑马灯的效果。格式为：</p><pre><code>&lt;marquee&gt;内容&lt;/marquee&gt;</code></pre><p><strong>direction(left right up down):</strong> 设置内容滚动的方向<br><strong>scrollamount：</strong>设置滚动的速度，值越大越快<br><strong>loop：</strong>设置滚动次数，默认为-1，也就是无限滚动<br><strong>behavior：</strong>设置滚动类型，slide，滚动到边界即停止，alternate，滚动到边界即弹回。</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2017/02/09/blog/"/>
      <url>/2017/02/09/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="http://i1.piimg.com/567571/f63d2030ab646842.png" alt><br><a href="hexo.io">Hexo</a>是一个快捷、简单、功能强大的个人博客框架，使用Node.js下载与安装，上百个文件仅需几秒就可以安装完毕;Hexo的页面使用Markdown语法，简洁高效;通过简单的命令即可发布到网站，支持发布到GitHub Pages Heroku和其他站点;同时Hexo拥有丰富强大的插件系统，可以根据个人需要进行安装。本文主要针对技术开发人员如何快速的搭建Hexo博客做一个详尽的教程，也是对自己在搭建博客的过程中遇到的问题进行总结，避免以后的小伙伴踩坑。本文从五个方面进行讲解，分别为：</p><ul><li>环境部署</li><li>HEXO安装与常用命令</li><li>个性化设置</li><li>HEXO部署Github</li><li><p>定制化个性域名</p><span id="more"></span><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h2 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1.Node.js"></a>1.Node.js</h2><p>首先我们需要安装Node.js，点击进入<a href="https://nodejs.org/en/">node.js官网</a>，按照通用的安装方式下载安装即可。Node.js主要用于生成静态界面。</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><p>这里说的git实则是为了使用git指令，我们的git使用一般有两种方式，一种是图形化界面（GUI），另一种是通过命令行，我们这里要使用的是后者，点击<a href="http://git-scm.com/downloads">这里</a>进入git的下载网站下载git的安装包。作用：把本地的hexo内容提交到github上去.</p><h2 id="3-GitHub配置"><a href="#3-GitHub配置" class="headerlink" title="3.GitHub配置"></a>3.GitHub配置</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>如果你没有GitHub账号，请到<a href="https://github.com/">这里</a>进行注册申请，详细注册过程略。</p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p>点击右上角的”+”选择New respository 建立新仓库，如图：<br><img src="http://p1.bqimg.com/567571/b85d00d61646ce19.png" alt><br>接下来需要配置仓库信息，如图：<br><img src="http://p1.bpimg.com/567571/8ddca7070ac1d6d3.png" alt><br>这里我们需要填写Repository name，注意这里的命名规范，如果我们要把这个仓库作为我们的个人博客，必须遵照以下规范命名：<strong>github用户名.github.io</strong>,点击Create repository即可。</p><h3 id="生成添加秘钥"><a href="#生成添加秘钥" class="headerlink" title="生成添加秘钥"></a>生成添加秘钥</h3><p>本机生成秘钥是为了方便以后更新博客不用每次都输入用户名密码，这个根据个人需要，不是必须操作。<br>在终端输入：</p><p>  $ ssh-keygen -t rsa -C “Github的注册邮箱地址”<br>待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，这两个文件位于：<br><img src="http://p1.bpimg.com/567571/ab706a277d27e1cd.png" alt><br>这个目录下，用文本编辑器(notepad++ 、Sublime Text)打开id_rsa.pub这个文件,全选复制里边的内容，然后打开<a href="https://github.com/settings/ssh">网址</a>,如图:<br><img src="http://i1.piimg.com/567571/15b94723da693034.png" alt></p></li></ul><p>点击 New SSH key:<br><img src="http://i1.piimg.com/567571/efd23501f3d72f7b.png" alt><br>Title随便起个名字，将刚才复制的内容粘贴进Key中，然后点击Add SSH Key，这样生成的秘钥就添加完毕了，在今后更新博客，不必每次都输入用户名密码验证登录。</p><h3 id="为Hexo安装Git插件"><a href="#为Hexo安装Git插件" class="headerlink" title="为Hexo安装Git插件"></a>为Hexo安装Git插件</h3><p>安装 hexo-deployer-git，否则会报 ERROR Deployer not found: git 的错误。</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>至此，环境全部配置完毕，接下来我们讲Hexo的安装，目录结构与常用命令。</p><h1 id="Hexo安装与常用命令"><a href="#Hexo安装与常用命令" class="headerlink" title="Hexo安装与常用命令"></a>Hexo安装与常用命令</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。执行如下命令安装Hexo：<br>定位blog安装位置：</p><pre><code>$ cd 文件夹路径$ npm install hexo-cli -g</code></pre><p>安装好hexo以后，在终端输入：</p><pre><code>$ hexo</code></pre><p>若出现下图，说明Hexo安装成功：<br><img src="http://i1.piimg.com/567571/fe00cc2a41c9c40b.png" alt></p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><pre><code>$ hexo init //初始化博客$ npm install //node.js的命令，根据博客的dependencies配置安装所有的依赖包</code></pre><p>完成后我们可以看到Blog文件夹下的文件结构是这样的：<br><img src="http://p1.bqimg.com/567571/cf1c9ba7e9372f95.png" alt></p><h3 id="主目录结构："><a href="#主目录结构：" class="headerlink" title="主目录结构："></a>主目录结构：</h3><pre><code>主目录1  ├── .deploy       #需要部署的文件2  ├── node_modules  #Hexo插件3  ├── public        #生成的静态网页文件4  ├── scaffolds     #模板5  ├── source        #博客正文和其他源文件，CNAME也放这里6  | ├── _drafts     #草稿7  | ├── _posts      #文章8  ├── themes        #主题9  ├── _config.yml   #全局配置文件10 └── package.json</code></pre><p>我们经常需要操作的目录为source &gt; _post(文章目录),themes(主题目录),config.yml(全局配置文件)。</p><h3 id="主题目录结构："><a href="#主题目录结构：" class="headerlink" title="主题目录结构："></a>主题目录结构：</h3><pre><code>主目录1  ├── languages          #国际化2  |   ├── default.yml    #默认3  |   └── zh-CN.yml      #中文4  ├── layout             #布局5  |   ├── _partial       #局部的布局6  |   └── _widget        #小挂件的布局7  ├── script             #js脚本8  ├── source             #源代码文件9  |   ├── css            #CSS10 |   |   ├── _base      #基础CSS11 |   |   ├── _partial   #局部CSS12 |   |   ├── fonts      #字体13 |   |   ├── images     #图片14 |   |   └── style.styl #style.css15 |   ├── fancybox       #fancybox16 |   └── js             #js17 ├── _config.yml        #主题配置文件18 └── README.md          #主题介绍</code></pre><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><pre><code>$ npm install hexo-cli -g           //安装Hexo$ hexo init                         //初始化博客$ npm install                       //安装依赖包$ hexo server                       //本地启动$ npm update hexo -g                //升级 $ hexo new &quot;文件名&quot;                  //新建文章$ hexo p                            //发布$ hexo generate                     //生成静态文件$ hexo generate -watch              //监视文件变动$ hexo deploy                       //部署$ hexo d -g                         //同上$ hexo g -d                         //同上$ hexo new page &quot;pageName&quot;          //新建页面</code></pre><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><h2 id="配置博客信息"><a href="#配置博客信息" class="headerlink" title="配置博客信息"></a>配置博客信息</h2><p>博客初始化完毕后，我们需要对博客做一些详细的配置信息，以及个性化设置，主要设置的内容有：博客信息，语言、时区、主题样式、博客目录结构、部署设置(deploy)、插件等。</p><h3 id="全局配置文件-config-yml"><a href="#全局配置文件-config-yml" class="headerlink" title="全局配置文件_config.yml"></a>全局配置文件_config.yml</h3><p>使用sublime Text打开根目录下的config.yml文件，首先我们要对站点信息进行设置:</p><h4 id="网站信息："><a href="#网站信息：" class="headerlink" title="网站信息："></a>网站信息：</h4><pre><code># Site        //站点信息title :       //博客名称subtilte:     //副标题description:  //站点描述信息ahthor:       //作者language:     //语言(zh-CN) *重要timezone:     //时区(Asia/Shanghai) *重要</code></pre><p><strong>注意：填写每一项内容时,:后边都要留一个空格再填写内容。</strong></p><h4 id="分页设置："><a href="#分页设置：" class="headerlink" title="分页设置："></a>分页设置：</h4><pre><code># Pagination## Set per_page to 0 to disable paginationper_page:5     //每页显示文章数pagination_dir: page</code></pre><h4 id="主题设置："><a href="#主题设置：" class="headerlink" title="主题设置："></a>主题设置：</h4><pre><code>#  Extensions## Plugins:https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next        //主题名称</code></pre><h4 id="部署设置："><a href="#部署设置：" class="headerlink" title="部署设置："></a>部署设置：</h4><pre><code>deploy:type: git          //类型repo:              //Github仓库地址branch: master     //项目分支，默认使用主分支即master</code></pre><h2 id="设置个性化主题"><a href="#设置个性化主题" class="headerlink" title="设置个性化主题"></a>设置个性化主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>首先找到我们喜欢的<a href="https://hexo.io/themes/">主题</a>，本篇文章以Next主题为例，将终端定位到Blog根目录，将Next主题从github clone到本地。</p><pre><code>$ cd:d/Blog $ git clone https://github.com/iissnan/hexo-theme-next themes/next   </code></pre><p>稍等片刻，Next主题会自动下载到Blog &gt;themes文件夹下。</p><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改config.yml全局配置文件，找到theme字节，修改值为：next</p><pre><code>theme: next</code></pre><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><h4 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h4><p>打开theme &gt; next &gt;_config.yml，定位到menu,hexo博客框架默认有/home 、/archives、/tags三个一级页面。如果我们要增加其他的页面需要对这里的配置文件进行修改。</p><pre><code>menu：  home: /                          //主页(默认打开)  #categories: /categories         //分类  #about: /about                   //关于  archives: /archives              //文章(默认打开)  tags: /tags                      //标签(默认打开)  #sitemap: /sitemap.xml           //站点地图  #commonweal: /404.html           //公益404</code></pre><p>我们需要增加哪个页面只需要把前边的#注释去掉即可。然后在终端中新建刚才添加的页面</p><pre><code>hexo new page &quot;categories&quot;          //这里用categories举例</code></pre><p>编辑站点的source/categories/index.md，添加</p><pre><code>---title: categoriesdate: 2017-02-09 17:52:11type: &quot;categories&quot;             //添加类型comments: false                //禁用评论---</code></pre><p>保存后<code>hexo s</code>,打开<a href="http://localhost:4000/查看效果。">http://localhost:4000/查看效果。</a></p><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>打开themes &gt;next &gt;languages 找到zh-Hans.yml，重命名为zh-CN.yml,或者将全局配置文件_config.yml的languages设置为zh-Hans也可以。</p><h4 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h4><p>定位到menu_icons,这里储存了页面使用的图标信息，Next主题采用了FontAwesome的图标，直接使用FontAwesome的图标名称即可调用对应的图标文件,关于FontAwesome的详细信息点击<a href="http://fontawesome.io/icons/">这里</a>，选择自己喜欢的图标复制名称粘贴即可。</p><pre><code>menu_icons:                    //目录图标配置enable: true                   //是否启用 #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home                    //主页 about: user                   //关于 categories: th                //分类 schedule: calendar            //进度 tags: tags                    //标签 archives: archive             //文章 sitemap: sitemap              //站点地图 commonweal: heartbeat</code></pre><h4 id="Scheme设置"><a href="#Scheme设置" class="headerlink" title="Scheme设置"></a>Scheme设置</h4><pre><code># Scheme Setting# ---------------------------------------------------------------# Schemes#scheme: Muse scheme: Mist#scheme: Pisces</code></pre><p>Next主题提供了三种样式，分别为Muse Mist Pisces，将样式前的#注释去掉即可启用该主题，同时只能启用一个。</p><h4 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h4><p>定位到social_icons，修改配置信息。</p><h4 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h4><p>定位倒sidebar，可以设置侧边栏的显示位置(左右),显示方式等。</p><h4 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h4><p>首先将我们的头像图片copy到themses &gt; next &gt; source &gt;images文件夹下，然后打开next主题下的_config.yml文件，定位到avatar。</p><pre><code>avatar: /images/头像文件名</code></pre><h1 id="Hexo部署GitHub"><a href="#Hexo部署GitHub" class="headerlink" title="Hexo部署GitHub"></a>Hexo部署GitHub</h1>]]></content>
      
      
      <categories>
          
          <category> Blog建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
