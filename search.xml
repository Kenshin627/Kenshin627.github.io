<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图形学的数学基础（二十四）：插值</title>
      <link href="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/"/>
      <url>/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二十四）：插值"><a href="#图形学的数学基础（二十四）：插值" class="headerlink" title="图形学的数学基础（二十四）：插值"></a>图形学的数学基础（二十四）：插值</h1><h2 id="线性插值（-Linear-Interpolation-）"><a href="#线性插值（-Linear-Interpolation-）" class="headerlink" title="线性插值（$Linear\;Interpolation$）"></a>线性插值（$Linear\;Interpolation$）</h2><p>在图形学领域插值是一项广泛应用的技术，很多时候，数据是在规则网格上指定的（值写在 2D 或 3D 网格的顶点位置）或在一条线上（在 1D 情况下），但是程序需要计算任意一点的值。如果采样点刚好落在网格顶点处，那么可以读取数值直接使用，但是如果采样点落在其他地方，考虑到那里并没有存储数值，我们需要基于周围顶点计算数值。这种技术称为插值，因为其关键思想是“插值”，通过固定网格顶点的现有值计算网格上其他任意位置的值。</p><p>在二维中这种技术叫双线性插值，与之对应的三维插值称为三线性插值。“线性插值”是一种类似于以下形式的方程：</p><p>$a(1-t) +bt\;\;\;with\; 0 &lt;=t\;&lt;=\;1$</p><p>其他种种形式的线性插值都是以此为基础的。</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/1.jpg" alt="线性插值"></p><p>插值技术通常用于图像处理（例如调整图像大小）。但是 3D 技术也可以使用 3D 或 2D 网格（纹理可以看作 2D 网格），例如流体模拟、体积渲染、纹理映射和辐照度缓存等等，无论何时涉及网格，通常也需要插值技术。</p><h2 id="双线性插值（-Bilinear-Interpolation-）"><a href="#双线性插值（-Bilinear-Interpolation-）" class="headerlink" title="双线性插值（$Bilinear\;Interpolation$）"></a>双线性插值（$Bilinear\;Interpolation$）</h2><p>双线性插值是一种用于在二维规则网格中计算任意值的方法。此网格也可以是图像或纹理贴图。思路是取二维平面上周围最近的四个网格顶点作为参照，首先水平方向做两次线性插值，得到两个查之后的结果，根据这两个值，再垂直方向再做一次线性插值。即可拿到p点的值。</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/2.png" alt="线性插值"></p><p>线性插值基本公式：</p><p>$lerp(t, v_0, v_1) = v_0 + t(v_1-v_0)$</p><p>计算x方向两次线性插值，得到a和b：</p><p>$a = C_{00} + s(C_{10} - C_{00})$</p><p>$b = C_{01} + s(C_{01} - C_{11})$</p><p>根据ab的值，再进行一次线性插值，计算p的值：</p><p>$p = a + t(b - a)$</p><p>这也是名称双线性插值的由来，总共做了两轮线性插值，水平方向上一轮，垂直方向上一轮。</p><h2 id="双三次线性插值（-Bicubic-Interpolation-）"><a href="#双三次线性插值（-Bicubic-Interpolation-）" class="headerlink" title="双三次线性插值（$Bicubic\;Interpolation$）"></a>双三次线性插值（$Bicubic\;Interpolation$）</h2><p>双线性插值是采用周围临近4个点作为参照，而双三次线性插值是采用周围16个点。也被称为双三次插值算法。</p><p>$W(x) = \begin{cases}<br>    (a+2)|x|^3 - (a+3)|x|^2 +1 \;for\;|x| &lt;= 1\\<br>    a|x|^3 - 5a|x|^2 + 8a|x|-4a\;for 1&lt; |x| &lt; 2\\<br>    0\;otherwise<br>\end{cases}$</p><p>其中$a = -0.5$</p><h2 id="三线性插值（-Trilinear-Interpolation-）"><a href="#三线性插值（-Trilinear-Interpolation-）" class="headerlink" title="三线性插值（$Trilinear\; Interpolation$）"></a>三线性插值（$Trilinear\; Interpolation$）</h2><p>三线性插值是双线性插值在三维空间的扩展。可以看作是两个双线性插值的“线性插值”。三线性插值双线性插值具有相同的有点和缺点，首先它非常简单，实现容易，速度也很快。但是它产生的结果不是非常平滑。然后对于体积渲染或流体模拟，需要在三维网格中处理大量插值时，它仍然是一个非常好的选择。</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/3.png" alt="线性插值"></p><p>step1:</p><p>$a = C_{010}+t(C_{110} - C_{010})$</p><p>$b = C_{000}+t(C_{100} - C_{000})$</p><p>$c = C_{011}+t(C_{111} - C_{011})$</p><p>$d = C_{001}+t(C_{101} - C_{001})$</p><p>step2:</p><p>$e = b + s(a - b)$</p><p>$f = d + s(c - d)$</p><p>step3:</p><p>$p = e + w(f-e)$</p><h2 id="平滑阶梯函数-SmoothStep"><a href="#平滑阶梯函数-SmoothStep" class="headerlink" title="平滑阶梯函数($SmoothStep$)"></a>平滑阶梯函数($SmoothStep$)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$smoothStep$函数用来生成0到1的平滑过渡值.先看smoothStep函数实现:</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/4.png" alt="线性插值"></p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>通过$smoothStep$函数定义,我们知道:</p><ul><li>$res = 3t^2 - 2t^3$</li><li>$t = \dfrac{(x-a)}{(b-a)}$</li></ul><p>接下来我们一步步通过函数图像来解释$smoothStep$背后的数学原理.</p><p><1> 对于函数$y = x$这个函数,其实就是一条直线:</1></p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/5.jpg" alt="线性插值"></p><p><2>对于函数$y = x^2$,可以看到它比$y = x$有一个更平滑的过渡:</2></p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/6.jpg" alt="线性插值"></p><p>但是我们发现$y = x^2$的函数图像仍然是不够“平滑的”，为什么呢？我们知道曲线的切线表示了这条曲线的变化率。通过观察我们明显发现，在0附近的变化率要低于1附近的变化率。</p><p><3> $y = 1 - (x-1)^2$我们在$y = x^2$的基础上构造另外一条曲线.首先先将$下^2$反转.得到:</3></p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/7.jpg" alt="线性插值"></p><p>将$y = -x^2$向右移动一个单位得到:</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/8.jpg" alt="线性插值"></p><p>然后再向上移动一个单位得到以下函数图像:</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/9.jpg" alt="线性插值"></p><p>此时$y = 1- (x-1)^2$</p><p>可以看到我们构造的第二条曲线在接近1的部分开始变缓,和$y = x^2$从0开始变缓一样.因此我们将这两条曲线混合到一起即可以得到理想情况下的“平滑过渡”：</p><p>利用线性插值混合两条曲线：</p><p>$y = xf(x) + (1-x)g(x) = x(1-(x-1)^2) + (1-x)x^2 = 3x^2 - 2x^3$</p><p><img src="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8F%92%E5%80%BC/10.jpg" alt="线性插值"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/interpolation">Scratchapixel</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://zhuanlan.zhihu.com/p/424589478">SmoothStep函数/节点到底做了什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二十三）：反射方程与渲染方程</title>
      <link href="/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"/>
      <url>/2022/09/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二十三）：反射方程与渲染方程"><a href="#图形学的数学基础（二十三）：反射方程与渲染方程" class="headerlink" title="图形学的数学基础（二十三）：反射方程与渲染方程"></a>图形学的数学基础（二十三）：反射方程与渲染方程</h1>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二十二）：辐射度量学</title>
      <link href="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
      <url>/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二十二）：辐射度量学"><a href="#图形学的数学基础（二十二）：辐射度量学" class="headerlink" title="图形学的数学基础（二十二）：辐射度量学"></a>图形学的数学基础（二十二）：辐射度量学</h1><h2 id="辐射度量学（-Radiometry-）"><a href="#辐射度量学（-Radiometry-）" class="headerlink" title="辐射度量学（$Radiometry$）"></a>辐射度量学（$Radiometry$）</h2><p> 辐射度量学是基于物理光照的基础，是基于几何光学来定义的，提供了精准的关于光的各种物理量，光与物体表面的作用，光线传播方法的定义等。辐射度量学是反射方程 渲染方程的基础。</p><h2 id="1-辐射能量（-Radiant-energy-）"><a href="#1-辐射能量（-Radiant-energy-）" class="headerlink" title="1.辐射能量（$Radiant\;energy$）"></a>1.辐射能量（$Radiant\;energy$）</h2><p>在辐射度量学中最基本的单位是辐射能量，表示为$Q$,单位是$J(焦耳)$，辐射能量$Q$以辐射的形式发射，传播或接收的能量。每个光子都携带一定的能量，这个能量正比于它的频率：</p><p>$Q = hv$</p><p>其中$h = 6.62620\times (10^{-34})J$.光子的频率（或者说能量）影响着光子与物体表面的交互，更重要的是，它影响着光与感应器之间的作用，使不同频率的光被察觉为不同的颜色。</p><h2 id="2-辐射通量（-Radiant-flux-）"><a href="#2-辐射通量（-Radiant-flux-）" class="headerlink" title="2.辐射通量（$Radiant\;flux$）"></a>2.辐射通量（$Radiant\;flux$）</h2><p>辐射通量，记为为$Φ$，表示单位时间 发射/反射/传播/接受的能量(功率-power)。单位为（$watt$）W或者($lumen$)lm，在辐射测量中，都是基于这个辐射通量来测量能量的，而不是使用能量$Q$。</p><p>$Φ = \dfrac{dQ}{dt}$</p><h2 id="3-辐射强度（-Radiant-intensity-）"><a href="#3-辐射强度（-Radiant-intensity-）" class="headerlink" title="3.辐射强度（$Radiant\;intensity$）"></a>3.辐射强度（$Radiant\;intensity$）</h2><p>辐射强度，记为$I$,<strong>表示一个点光源在单位立体角上发射能量的功率</strong>。表示光源在某一方向上的辐射功率。单位为$(candela)$cd.</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/1.png" alt="radiant intensity"></p><p>在辐射度两学里，通常用$\omega$表示三维空间中的一个方向。$\omega$可以用$\theta和\phi$两个参数定义它的位置。并且可以通过$\sin\theta{d}\theta{d}\phi$表示它的单位立体角。</p><p>$I(w) = \dfrac{dΦ}{dw}$</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/2.png" alt="radiant intensity"></p><p>对于空间中的一个点光源，$Radiant\;intensity$表示光源在任意方向上的发射功率。</p><h3 id="各向同性点光源"><a href="#各向同性点光源" class="headerlink" title="各向同性点光源"></a>各向同性点光源</h3><p>对于空间中各向同性（各方向发射功率相同）的点光源。任意方向辐射功率都是相同的。因此：</p><p>光源所有方向单位立体角的$Radiant\;intensity$的积分等于光源的总功率。<br>$Φ = \int_{s^2}Idw$</p><p>任意方向上单位立体角的$Radiant\;intensity$等于</p><p>$I = \dfrac{Φ}{4\pi}$</p><h2 id="4-辐射照度（-Irradiance-）"><a href="#4-辐射照度（-Irradiance-）" class="headerlink" title="4. 辐射照度（$Irradiance$）"></a>4. 辐射照度（$Irradiance$）</h2><p>辐射照度，记为$E$，表示单位投影面积的能量功率，用于描述物体表面单位面积接收到的辐射功率。单位为$lux$。</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/4.png" alt="Irradiance"></p><p>$E(x) = \dfrac{dΦ(x)}{dA}$</p><h2 id="5-辐射亮度（-Radiance-）"><a href="#5-辐射亮度（-Radiance-）" class="headerlink" title="5. 辐射亮度（$Radiance$）"></a>5. 辐射亮度（$Radiance$）</h2><p>用于描述光线在传播过程中的属性。记为$L$，<strong>表示为单位投影面积 单位立体角被发射/反射/转换/接收的辐射功率（一条光线所携带的功率）。</strong>.单位为$nit$</p><p>$L(p,w) = \dfrac{d^2Φ(p,w)}{dwdA\cos\theta}$</p><p>$Radiance$做两次微分，一次是单位立体角，一次是投影面积，两次微分后，将功率收束为一条光线。</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/5.png" alt="Radiance"></p><h3 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h3><ol><li>$Radiant\;intensity$</li></ol><p>$Radiant\;intensity$是点光源在某一方向单位立体角的辐射功率，是一个由点及面的过程。</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/6.jpg" alt="Radiance"></p><p>$Radiance$可以理解为$Radiant\;intensity$在单位投影面积上的微分，将光源从$w$方向单位立体角辐射的功率收束为一条光线。描述了光线发射过程中，光线传播的性质。</p><p>一句话描述$Radiance$等于单位投影面积上的$Radiant\;intensity$</p><p>$L(p,w) = \dfrac{dI(p,w)}{dA\cos\theta}$</p><ol><li>$Irradiance$</li></ol><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/7.png" alt="Radiance"></p><p>$Radiance$可以理解为$Irradiance$在某一方向$W$单位立体角上接收的光照辐射功率，是物体表面单位面积$dA$接收的各个方向的辐射功率（$Irradiance$）在某一单位立体角上的微分。描述了物体接收光照辐射过程中，光线的“形状”。</p><p>一句话描述$Radiance$等于单位立体角上的 $Irradiance$。</p><p>$L(p,w) = \dfrac{dE(p)}{dw\cos\theta}$</p><p>总结：</p><p>$L(p,w) = \dfrac{dI(p,w)}{dA\cos\theta} = \dfrac{dE(p)}{dw\cos\theta} = \dfrac{d^2Φ(p,w)}{dwdA\cos\theta}$</p><h2 id="Irradiance-vs-Radiance"><a href="#Irradiance-vs-Radiance" class="headerlink" title="$Irradiance\;vs\;Radiance$"></a>$Irradiance\;vs\;Radiance$</h2><p>$Irradiance$: 单位面积$dA$接收到的所有能量</p><p>$Radiance$：单位面积$dA$从方向$dw$上接收到的能量。</p><p>$E(p) =  \int_{H^2}L_i(p,w)\cos\theta{dw}$</p><p>$dE(p,w) = L_i(p,w)\cos\theta{dw}$</p><p><strong>单位面积$dA$上的$Irradiance$等于各个角度$Radiance$的半球积分。</strong></p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/8.png" alt="Radiance"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=15&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.thegibook.com/">全局光照技术：从离线到实时渲染</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二十一）：立体角</title>
      <link href="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
      <url>/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二十一）：立体角"><a href="#图形学的数学基础（二十一）：立体角" class="headerlink" title="图形学的数学基础（二十一）：立体角"></a>图形学的数学基础（二十一）：立体角</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>立体角，常用字母$\Omega$表示，是一个物体对特定点的三维空间的角度，是平面角在三维空间中的类比。因此，立体角是单位球面上的一块面积，这和“平面角是单位圆上的一段弧长”类似。</p><h2 id="平面角"><a href="#平面角" class="headerlink" title="平面角"></a>平面角</h2><p>平面角等于张角对应圆上的弧长除以圆的半径，即：</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/1.png" alt="平面角"></p><p>$\theta = \dfrac{l}{r}$</p><p>而圆的周长等于$2\pi{r}$,因此完整圆<br>对应的角度为：</p><p>$\dfrac{2\pi{r}}{r} = 2\pi\;\;radians$</p><h2 id="立体角（-Solid-angle-）"><a href="#立体角（-Solid-angle-）" class="headerlink" title="立体角（$Solid\;angle$）"></a>立体角（$Solid\;angle$）</h2><p>平面角在三维空间的延申。在三维空间中某一个球体，从球心出发，形成具有一定大小的锥体，锥体会打到球面上，形成一定的面积。而立体角就是锥体形成的面积$A$除以球体半径的平方。</p><p>$\omega = \dfrac{A}{r^2}$</p><p>球体的表面积等于$4\pi{r^2}$</p><p>因此完整球体的立体角为$4\pi\;\;steradians$</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/2.jpg" alt="平面角"></p><h3 id="微分立体角（-Differential-Solid-angles-）"><a href="#微分立体角（-Differential-Solid-angles-）" class="headerlink" title="微分立体角（$Differential\;Solid\;angles$）"></a>微分立体角（$Differential\;Solid\;angles$）</h3><p>由立体角的定义可知，三维空间中的某一立体角等于锥体在球面形成的面积处于半径的平方。因此微分立体角等于球体上极小面积处于半径平方，而极小面积是由球体上某一点在$\theta和\phi$两个方向上的微小移动形成的。</p><p>$d\phi$是立体角$d\omega$在底面上展开的微小平面夹角范围，$d\theta$是$d\omega$与垂直方向的微小平面夹角范围。极小面积如下图所示：</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/3.png" alt="平面角"></p><p>极小面积可以近似看作矩形，因此极小面积近似等于$AB\times{BC}$如下图：</p><p><img src="/2022/09/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AB%8B%E4%BD%93%E8%A7%92/4.jpg" alt="平面角"></p><p>$d\omega = \dfrac{dA}{r^2}$</p><p>$OBC$可以看作二维扇面，根据平面角的定义：</p><p>$d\theta = \dfrac{BC}{r}$</p><p>$BC = d\theta{r}$</p><p>BD垂直于n轴，OBD形成直角三角形，根据正弦定理：</p><p>$BD = r\sin\theta$</p><p>DAB形成二维扇面：</p><p>$d\phi = \dfrac{AB}{DB} = \dfrac{AB}{r\sin\theta}$</p><p>$AB = r\sin\theta{d}\phi$</p><p>$dA = AB\times{BC} = r\sin\theta{d}\phi\times {d\theta{r}} = \sin\theta{d}\theta{d}\phi{r^2}$</p><p>$d\omega = \dfrac{dA}{r^2} = \dfrac{\sin\theta{d}\theta{d}\phi{r^2}}{r^2} = \sin\theta{d}\theta{d}\phi$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.youtube.com/watch?v=VmnkkWLwVsc">Understanding the concept of Solid Angle</a></p><p><a href="https://zhuanlan.zhihu.com/p/450731138">立体角 （Solid Angle）</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二十）：包围盒</title>
      <link href="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
      <url>/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二十）：包围盒-Bounding-Box"><a href="#图形学的数学基础（二十）：包围盒-Bounding-Box" class="headerlink" title="图形学的数学基础（二十）：包围盒($Bounding Box$)"></a>图形学的数学基础（二十）：包围盒($Bounding Box$)</h1><p>包围盒是一种求解离散点集最优包围空间的算法,基本思想是用体积稍大且特性简单的集合体来近似代替复杂的几何对象。包围盒常用于几何物体的碰撞检测，ray-tracing中光线求交等。常用的包围盒有两种，$AABB与OBB$，AABB包围盒是轴对齐的，而$OBB$是任意定向的。</p><h2 id="AABB"><a href="#AABB" class="headerlink" title="$AABB$"></a>$AABB$</h2><p>$AABB$是$Axially\;Aligned\;Bounding\;Box$的缩写，三维$AABB$是一个简单的6面盒子，每一面都与一个主要平面平行，这个盒子不一定是立方体，盒子的长度宽度高度可以各自不同。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>几何体$AABB$包围盒内的点满足以下不等式：</p><p>$x_{min} &lt;= x &lt;= x_{max}$</p><p>$y_{min} &lt;= y &lt;= y_{max}$</p><p>$z_{min} &lt;= z &lt;= z_{max}$</p><p>两个具有特殊意义的点：</p><ul><li><p>最小值：$\textbf{P}_{min} = [x_{min}, y_{min}, z_{min}]$</p></li><li><p>最大值：$\textbf{P}_{max} = [x_{max}, y_{max}, z_{max}]$</p></li></ul><p>中心点可以通过最小值和最大值的中点计算得出：</p><p>$\textbf{c} = \dfrac{(\textbf{P}_{min} + \textbf{P}_{max})}{2}$</p><p>大小矢量($Size\;Vector$)$s$是从$\textbf{P}_{min}$到$\textbf{P}_{max}$的矢量，该矢量的三个分量分别代表了包围盒的长宽高信息。</p><h3 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h3><p>一般情况下会使用$\textbf{P}_{min}$和$\textbf{P}_{max}$表示包围盒。</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/1.png" alt="AABB"></p><h3 id="计算-AABB"><a href="#计算-AABB" class="headerlink" title="计算$AABB$"></a>计算$AABB$</h3><p>针对一组点计算$AABB$是一个很简单的过程，首先初始化min和max两个值，初始值分别设置为最大值和最小值，遍历点位集合，分别比较判断$min,max$的三个分量，将当前最小值赋给$min$最大值赋给$max$。</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/2.png" alt="AABB"></p><h3 id="变换-AABB"><a href="#变换-AABB" class="headerlink" title="变换$AABB$"></a>变换$AABB$</h3><p>有时候我们需要将$AABB$从一个坐标空间转换为另一个坐标空间。假设在对象空间中有$AABB$,现在希望在世界空间中获得$AABB$,其中一种做法就是，可以基于变换后的几何体顶点，重新计算包围盒，但是针对复杂的几何体，顶点数量特别多，这种计算是相对昂贵的，因此在世界空间中获得$AABB$，就需要考虑变换对象空间的$AABB$。<br>要为变换后的$AABB$计算$AABB$，仅变换$\textbf{P}_min和\textbf{P}_max$是不够的，这可能导致假的包围盒，<br>在经过变换后，通常导致包围盒大于原始包围盒。而通过变换后的对象重新计算$AABB$将与原始的$AABB$大致相同。</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/3.png" alt="AABB"></p><h4 id="矩阵变换-AABB"><a href="#矩阵变换-AABB" class="headerlink" title="矩阵变换$AABB$"></a>矩阵变换$AABB$</h4><p>当我们对空间中一个点做变换时，可以采用矩阵形式：</p><p>$\begin{bmatrix}<br>x^丶\\ y^丶\\ z^丶\\<br>\end{bmatrix} = \begin{bmatrix}<br>m_{11}&amp;m_{12}&amp;m_{13}\\<br>m_{21}&amp;m_{22}&amp;m_{23}\\<br>m_{31}&amp;m_{32}&amp;m_{33}\\<br>\end{bmatrix}\begin{bmatrix}<br>x\\ y\\ z\\<br>\end{bmatrix}$</p><p>$x^丶 = m_{11}x + m{12}y+m_{13}z$</p><p>$y^丶 = m_{21}x + m{22}y+m_{23}z$</p><p>$z^丶 = m_{31}x + m{32}y+m_{33}z$</p><p>假设$x,y,z$是原始八个顶点中的任何一个，我们的工作是找出变换后哪些顶点具有最小的$x$值。最小化整个总和的技巧是单独最小化3个乘积的每一个。我们来看第一个乘积$m_{11}x$，我们必须决定用$x_{min}或x_{max}$中的哪一个来代替$x$以便最小化乘积。显然如果$m_{11} &gt; 0$,则二者中较小的$x_{min}$将导致较小的乘积。</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/4.png" alt="AABB"></p><h3 id="光线与-AABB-求交"><a href="#光线与-AABB-求交" class="headerlink" title="光线与$AABB$求交"></a>光线与$AABB$求交</h3><p>包围盒常用来做物体的碰撞监测，光线的相交测试等。尤其在光线追踪中，包围盒常用来做光线与物体相交测试。基本思想是这样的，我们将包围盒的长方体看做是三对互相平行的平面相交所形成的区域。尤其对于$AABB$，每一对平行面都是与一个轴对齐的。根据这个特性，先以二维空间举例：</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/5.jpg" alt="AABB"></p><p>$AABB$由两对平面构成，分别是平行于$x轴和y轴$。根据光线公式可知：</p><p>$Ray = \textbf{0} + \textbf{d}t$</p><p>其中o为光线起点，d为光线方向，Ray是光线经过t时间到达的位置。 </p><p>如何判定光线是否与包围盒相交呢？我们可以通过分解，将问题简化，将光线分别穿过每对无线延申的平面，分别求出其$T_{min}和T_{max}$：</p><p>与$x$轴垂直的一对平面的交点：</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/6.png" alt="AABB"></p><p>$T_{xmin}d_x + o_x = x_0$</p><p>=&gt;</p><p>$T_{xmin} = \dfrac{x_0 - o_x}{d_x}$</p><p>$T_{xmax}d_x + o_x = x_1$</p><p>=&gt; </p><p>$t_{xmax} = \dfrac{x_1 - o_x}{d_x}$</p><p>与$y$轴垂直的一对平面的交点：</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/7.png" alt="AABB"></p><p>$T_{ymin}d_y + o_y = y_0$</p><p>=&gt;</p><p>$T_{ymin} = \dfrac{y_0 - o_y}{d_y}$</p><p>$T_{ymax}d_y + o_y = y_1$</p><p>=&gt; </p><p>$t_{ymax} = \dfrac{y_1 - o_y}{d_y}$</p><p>现在我们想象空间中的一条光线，只有当光线进入了所有的“平面对”，才算进入了盒子，光线只要离开了任何“平面对”，就算离开了盒子，因此光线进入盒子的时间实际上是进入所有“平面对”的最大值，即<strong>最小时间的最大值</strong>，而离开盒子的时间是光线离开“平面对”的最小值，即<strong>最大时间的最小值</strong>。（求交）</p><p><img src="/2022/09/08/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%8C%85%E5%9B%B4%E7%9B%92/8.jpg" alt="AABB"></p><p>考虑三维情况下光线与$AABB$求交。关键点：</p><ul><li>当且仅当光线进入了所有“平面对”，光线进入盒子。</li><li>只要光线离开了一组“平面对”，光线就离开了盒子。</li></ul><p>对于三维空间，我们有三组“平面对”，分别计算$t_{min}和t_{max}$，因此有：</p><p>$t_{enter} = max(t_{minx}, t_{miny}, t_{minz})$</p><p>$t_{exit} = min(t_{maxx}, t_{maxy}, t_{maxz})$</p><p>当且仅当$t_{enter} &lt; t_{exit}$时，我们认为“光线在盒子里停留了一段时间”，即光线与盒子相交。</p><p>但是以上推断没有考虑t为负值的情况，当$t_{exit} &lt; 0$时，盒子在光线背面，必然不会出现交点（光线是单向的），当 $t_{exit} &gt;= 0 并且t_{enter} &lt; 0时$，光线起点在盒子里边，那么光线必然与盒子相交。因此得出结论：</p><p>光线$Ray$与$AABB$相交，当且仅当：</p><p>$t_{enter} &lt; t_{exit}$<br>$t_{exit} \;\;&gt;= 0$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十九）：几何图元-重心坐标</title>
      <link href="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
      <url>/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十九）：几何图元-重心坐标"><a href="#图形学的数学基础（十九）：几何图元-重心坐标" class="headerlink" title="图形学的数学基础（十九）：几何图元-重心坐标"></a>图形学的数学基础（十九）：几何图元-重心坐标</h1><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/1.jpg" alt="重心坐标"></p><h2 id="定义重心坐标-Barycentric-Coordinates"><a href="#定义重心坐标-Barycentric-Coordinates" class="headerlink" title="定义重心坐标($Barycentric\;Coordinates$)"></a>定义重心坐标($Barycentric\;Coordinates$)</h2><p>对于空间内的三角形$\triangle{v_1v_2v_3}$和任意一点$\textbf{p}$，必定唯一存在三个数$b_1,b_2,b_3$,满足：</p><p>$b_1+b_2+b_3 = 1$</p><p>$\textbf{p} = b_1\textbf{v}_1 + b_2\textbf{v}_2+ b_3\textbf{v}_3$</p><p>则$b_1,b_2,b_3$就称为$\textbf{p}$点在此三角形$\triangle{v_1v_2v_3}$上的重心坐标.</p><p>重心坐标表示了三角形每个顶点对该点的权重（贡献），重心坐标可以用来三角形光栅化顶点的属性插值，比如说uv 颜色 法线的线性插值。</p><p>重心坐标也是一种坐标系统，类似于普通笛卡尔坐标系，但有一个区别就是，重心坐标的三个分量之和为1：</p><p>$b_1 + b_2 + b_3 = 1$</p><p><strong>这种归一化的约束消除了一个自由度，因此即使有三个坐标，它仍然是一个二维空间。</strong></p><p>重心坐标不仅适用于三角形内的点，对于边上的点甚至三角形外的点都是适用的，三角形内的重心坐标都是被限制到[0,1]范围内，三角形外的任何点都至少有一个负坐标。</p><p>还有一种解释重心坐标的角度，丢弃$b_3$,将$(b_1,b_2)$解释为常规的二维坐标，原点位于$\textbf{v}_3$,x轴是$\textbf{v}_1-\textbf{v}_3$,y轴是$\textbf{v}_2-\textbf{v}_3$</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/2.jpg" alt="重心坐标的几何意义"></p><p>$(b_1,b_2,b_3)\\=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + b_3\textbf{v}_3\\<br>=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + (1-b_1-b_2)\textbf{v}_3\\<br>=&gt; b_1\textbf{v}_1 + b_2\textbf{v}_2 + \textbf{v}_3 - b_1\textbf{v}_3-b_2\textbf{v}_3\\<br>=&gt; \textbf{v}_3 + b_1(\textbf{v}_1 -\textbf{v}_3) + b_2(\textbf{v}_2 - \textbf{v}_3)<br>$</p><h2 id="计算重心坐标"><a href="#计算重心坐标" class="headerlink" title="计算重心坐标"></a>计算重心坐标</h2><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/3.png" alt="重心坐标"></p><p>已知p的坐标和$v_1,v_2,v_3$的顶点坐标，求p的重心坐标$(b_1,b_2,b_3)$,只需要求解线性方程组即可：</p><p>$\begin{cases}<br>    b_1x_1 +b_2x_2 + b_3x_3 = p_x\\<br>    b_1y_1 +b_2y_2 + b_3y_3 = p_x\\<br>    b_1+b_2+b_3 = 1<br>\end{cases}$</p><p>求解该方程组得到：</p><p>$b_1 = \dfrac{(p_y-y_3)(x_2-x_3)+(y_2-y_3)(x_3-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>$b_1 = \dfrac{(p_y-y_1)(x_3-x_1)+(y_3-y_1)(x_1-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>$b_1 = \dfrac{(p_y-y_2)(x_1-x_2)+(y_1-y_2)(x_2-p_x)}{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}$</p><p>可以看到每个表达式中的分母是相同的，根据三角形的面积公式可得：$A = \dfrac{(y_1-y_3)(x_2-x_3)+(y_2-y_3)(x_3-x_1)}{2}$，它等于三角形面积的两倍，而且对于每个重心坐标$b_i$来说，其分子等于“子三角形”$T_i$的面积的两倍：</p><p>$b_1 = \dfrac{A(T_1)}{A(T)}, b_2 = \dfrac{A(T_2)}{A(T)}, b_3 = \dfrac{A(T_3)}{A(T)}$</p><p>因此得出结论：<strong>重心坐标等于对面子三角形与大三角形的比例。</strong></p><p>所以计算重心坐标可先叉乘计算面积，再求面积比。另外因为公底边三角形面积比等于高(有向高)的比，因此：</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/4.png" alt="重心坐标"></p><p>$\begin{cases}<br>    b_1 = \dfrac{h_1}{H_1}\\<br>    b_2 = \dfrac{h_2}{H_2}\\<br>    b_3 = \dfrac{h_3}{H_3}\\<br>\end{cases}$</p><h2 id="重心-内心-外心"><a href="#重心-内心-外心" class="headerlink" title="重心 内心 外心"></a>重心 内心 外心</h2><h3 id="重心（-Center-of-Gravity-）"><a href="#重心（-Center-of-Gravity-）" class="headerlink" title="重心（$Center of Gravity$）"></a>重心（$Center of Gravity$）</h3><p>重心，也称为质心($Centroid$)，是三角形完美平衡的点。它是中线的交点（中线是从一个顶点到对边中点的直线）。如下图：</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/5.png" alt="重心坐标"></p><p>重心是三个顶点的几何平均值：</p><p>$C_{gravity} = \dfrac{\textbf{v}_1 + \textbf{v}_2 + \textbf{v}_3}{3}$</p><p>重心的重心坐标为：$(\dfrac{1}{3},\dfrac{1}{3},\dfrac{1}{3})$</p><h3 id="内心（-Incenter-）"><a href="#内心（-Incenter-）" class="headerlink" title="内心（$Incenter$）"></a>内心（$Incenter$）</h3><p>内心是三角形三条角平分线的交点。它也是三角形内切圆的圆心。由此可知，内心与三角形各条边的距离是相等的：</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/6.jpg" alt="内心"></p><p>假设$P = l_1 + l_2 + l_3$为三角形的周长,$l_1,l_2,l_3为每条边长$，则内心的重心坐标可是表示为边长与周长比：</p><p>$(\dfrac{l_1}{p},\dfrac{l_2}{p},\dfrac{l_3}{p})$</p><p>内心的坐标：</p><p>$C_{Incenter} = \dfrac{l_1\textbf{v}_1 + l_2\textbf{v}_2+ l_3\textbf{v}_3}{p}$</p><p>内切圆半径为三角形面积除以三角形周长：</p><p>$r_{Incenter} = \dfrac{A}{p}$</p><h3 id="外心（-Circumcenter-）"><a href="#外心（-Circumcenter-）" class="headerlink" title="外心（$Circumcenter$）"></a>外心（$Circumcenter$）</h3><p>外心是三角形中与顶点等距的点。它是围绕三角形的外接圆的圆心。外心构造为各条边的垂直平分线的交点。</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/7.jpg" alt="内心"></p><h4 id="外心的计算"><a href="#外心的计算" class="headerlink" title="外心的计算"></a>外心的计算</h4><p>$d_1 = -\vec{e_2}\cdot\vec{e_3}$</p><p>$d_2 = -\vec{e_3}\cdot\vec{e_1}$</p><p>$d_3 = -\vec{e_1}\cdot\vec{e_2}$</p><p>$c_1 = d_2d_3$</p><p>$c_2 = d_3d_1$</p><p>$c_3 = d_1d_2$</p><p>$c = c_1 + c_2 + c_3$</p><p>外心重心坐标：$(\dfrac{c_2+c_3}{2c},\dfrac{c_3+c_1}{2c},\dfrac{c_1+c_2}{2c})$</p><p>外心坐标：$C_Circumcenter = \dfrac{(c_2+c_3)\textbf{v}_1+(c_3+c_1)\textbf{v}_2+(c_1+c_2)\textbf{v}_3}{2c}$</p><p>外接圆半径：$r_Circumcenter = \dfrac{\sqrt{(d_1+d_2)(d_2+d_3)(d_3+d_1)}}{2}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十八）：几何图元-三角形</title>
      <link href="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十八）：几何图元-三角形"><a href="#图形学的数学基础（十八）：几何图元-三角形" class="headerlink" title="图形学的数学基础（十八）：几何图元-三角形"></a>图形学的数学基础（十八）：几何图元-三角形</h1><p>三角形在图形学中具有重要性的意义。复杂三维对象的表面与许多三角形近似。这样一组链接的三角形可形成一个三角形网格（$Triangle\;Mesh$），本章将介绍三角形基本属性，重点是重心坐标。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个三角形，只需要三个顶点即可，这些点的顺序至关重要，因为它们的顺序决定了三角面的正反，在右手系中，当从三角形正面看时，通常按逆时针方向枚举点（右手螺旋定则）。</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/1.jpg" alt="三角形定义"></p><p>边矢量，边长 顶点定义如下：</p><p>$\vec{e_1} = \textbf{v}_3 - \textbf{v}_2$</p><p>$\vec{e_2} = \textbf{v}_1 - \textbf{v}_3$</p><p>$\vec{e_3} = \textbf{v}_2 - \textbf{v}_1$</p><p>$l_1 = ||\vec{e_1}||$</p><p>$l_2 = ||\vec{e_2}||$</p><p>$l_3 = ||\vec{e_3}||$</p><h2 id="三角形常用公式"><a href="#三角形常用公式" class="headerlink" title="三角形常用公式"></a>三角形常用公式</h2><ul><li>正弦定理：$\dfrac{\sin\theta_1}{l_1} = \dfrac{\sin\theta_2}{l_2} = \dfrac{\sin\theta_3}{l_3}$</li></ul><ul><li><p>余弦定理：$\begin{cases}<br>  {l_1}^2 = {l_2}^2 + {l_3}^2-2l_2l_3\cos\theta_1\\<br>  {l_2}^2 = {l_1}^2 + {l_3}^2-2l_1l_3\cos\theta_2\\<br>  {l_3}^2 = {l_1}^2 + {l_2}^2-2l_1l_2\cos\theta_3\\<br>\end{cases}$</p></li><li><p>三角形周长：$p = l_1+l_2+l_3$</p></li></ul><h2 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h2><h3 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h3><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/2.png" alt="三角形定义"></p><p>由上图可知，平行四边形的面积等于底乘高，而三角形占据了平行四边形面积的一半，因此三角形面积为：</p><p>$\textbf{A} = \dfrac{base.h}{2}$</p><h3 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h3><p>求解三角形面积的第二种方式是海伦公式。</p><p>$s = \dfrac{l_1+l_2+l_3}{2} = \dfrac{p}{2}$</p><p>$\textbf{A} = \sqrt{s(s-l_1)(s-l_2)(s-l_3)}$</p><h3 id="顶点坐标"><a href="#顶点坐标" class="headerlink" title="顶点坐标"></a>顶点坐标</h3><p>一般来说,边的高度或长度不太好计算,因为所有的已知条件都是顶点的笛卡尔坐标(当然骂我们总是可以通过坐标计算边长,但在有些情况下我们尽量避免这种相对昂贵的计算).接下来将介绍通过顶点坐标计算三角形面积的方法。</p><p>基本思想就是为三角形的每条边计算提醒的有符号面积，该面积由边和下方的x轴所界定。</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E4%B8%89%E8%A7%92%E5%BD%A2/3.jpg" alt="边矢量面积"></p><p>根据梯形面积公式：</p><p>$\textbf{A} = \dfrac{(上底 + 下底).高}{2}$，则三角形三条边的面积公式分别为：</p><p>$\textbf{A}(e_1) = \dfrac{(y_2+y_3)(x_2-x_3)}{2}$</p><p>$\textbf{A}(e_2) = \dfrac{(y_3+y_1)(x_3-x_1)}{2}$</p><p>$\textbf{A}(e_3) = \dfrac{(y_2+y_1)(x_2-x_1)}{2}$</p><p><strong>可以通过对三个提醒的有符号面积求和，获得三角形本身的面积。实际上可以用这个思路求解任意多边形面积。</strong></p><p>$\textbf{A} = \textbf{A}(e_1) + \textbf{A}(e_2) + \textbf{A}(e_3)\\<br>    =\dfrac{(y_2+y_3)(x_2-x_3) + (y_3+y_1)(x_3-x_1) + (y_2+y_1)(x_2-x_1)}{2}\\<br>    =\dfrac{y_1(x_3-x_2) + y_2(x_1-x_3) + y_3(x_1-x_2)}{2}<br>$</p><p>平移三角形不会改变三角形面积，因此我们可以将每个$y$坐标减去$y_3$,进一步做简化：</p><p>$\textbf{A} = \dfrac{(y_1-y_3)(x_3-x_2) + (y_2-y_3)(x_1-x_3) + (y_3-y_3)(x_1-x_2)}{2}\\<br>        =\dfrac{(y_1-y_3)(x_3-x_2) + (y_2-y_3)(x_1-x_3)}{2}\\<br>$</p><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>三维中可以使用叉积计算三角形的面积，根据叉积的定义，两个矢量的叉积的大小等于通过矢量两条边形成的平行四边形的面积。由于三角形的面积是平行四边形面积的一半，因此：</p><p>$\textbf{A} = \dfrac{||\vec{e_1}\times\vec{e_2}||}{2}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十七）：几何图元-平面(下)</title>
      <link href="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%B9%B3%E9%9D%A2-%E4%B8%8B/"/>
      <url>/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%B9%B3%E9%9D%A2-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十七）：几何图元-平面-下"><a href="#图形学的数学基础（十七）：几何图元-平面-下" class="headerlink" title="图形学的数学基础（十七）：几何图元-平面(下)"></a>图形学的数学基础（十七）：几何图元-平面(下)</h1><p>转载请注明出处</p><p>上章推导了平面方程的定义。这章介绍几种和平面有关的常见求交和计算点到平面距离的方法。</p><h2 id="平面距原点的最短（垂直）距离"><a href="#平面距原点的最短（垂直）距离" class="headerlink" title="平面距原点的最短（垂直）距离"></a>平面距原点的最短（垂直）距离</h2><p>如果平面的法线是单位矢量,则平面方程的常数项$d$是原点到平面的有符号距离。</p><p><img src="/2022/09/06/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E5%B9%B3%E9%9D%A2-%E4%B8%8B/1.jpg" alt="原点距平面距离"></p><p>假设单位矢量$\hat{n}$ $\begin{bmatrix}a\\ b\\ c\\ \end{bmatrix}$,则平面上的一点$\textbf{P}_1$可以写成$\begin{bmatrix}Da\\ Db\\ Dc\end{bmatrix}$的形式，D是从原点到平面的垂直有符号距离。因此我们可以将平面方程重写如下：</p><p>$\begin{bmatrix}a\\ b\\ c\\\end{bmatrix}\cdot\begin{bmatrix}x-Da\\ y-Db\\ z-Dc\\\end{bmatrix} = 0$</p><p>$a(x-Da) + b(y-Db) + c(z-Dc) = 0$</p><p>$ax + by + cz -D(a^2 + b^2 + c^2) = 0$</p><p>$ax + by + cz -D||\vec{n}|| = 0$</p><p>因此原点到平面的垂直有符号距离 $D = \dfrac{d}{||\vec{n}||}$,其中$\textbf{d}$为平面方程的常数项。</p><h2 id="任意点到平面的最短（垂直）距离"><a href="#任意点到平面的最短（垂直）距离" class="headerlink" title="任意点到平面的最短（垂直）距离"></a>任意点到平面的最短（垂直）距离</h2><p>很多时候我们可能会有一个平面和一个不在平面内的点$\textbf{q}$，然后想要计算从该平面到$\textbf{q}$的距离。如果该距离为负数，则$\textbf{q}$在平面的背面，反之在正面。为此我们假设平面中的一个点$\textbf{p}$，它是该平面中与$\textbf{q}$最近的点，显然从$\textbf{p}到\textbf{q}$的矢量垂直于平面，因此它是$a\vec{n}$的另外一种形式。</p><p>对于平面$ax + by + cz+d = 0$，任意一点$\textbf{q}$到平面的最短距离推导如下：</p><p>$\textbf{p} + a\vec{n} = \textbf{q}$</p><p>$(\textbf{p} + a\vec{n})\cdot\vec{n} = \textbf{q}\cdot\vec{n}$</p><p>$\textbf{p}\cdot\vec{n} + a\vec{n}\cdot\vec{n} = \textbf{q}\cdot\vec{n}$</p><p>$d||\vec{n}|| + a||\vec{n}||^2 = \textbf{q}\cdot\vec{n}$</p><p>$d||\vec{n}|| + a||\vec{n}||^2 = \textbf{q}\cdot\hat{n}||\vec{n}||$</p><p>$d + a||\vec{n}|| = \textbf{q}\cdot\hat{n}$</p><p>$a = \dfrac{\textbf{q}\cdot\hat{n} - d}{||\vec{n}||}$</p><p>对于单位矢量则有：</p><p>$a = \textbf{q}\cdot\hat{n} - d$</p><h2 id="求解三平面的交点"><a href="#求解三平面的交点" class="headerlink" title="求解三平面的交点"></a>求解三平面的交点</h2><p>求解三平面相交交点，我们只需要解三个平面方程组成的线性方程组即可：</p><p>$\begin{cases}<br>    a_1x+b_1y+c_1z + d_1 = 0\\<br>    a_2x+b_2y+c_2z + d_2 = 0\\<br>    a_3x+b_3y+c_3z + d_3 = 0\\<br>\end{cases}$<br>可以写成矩阵的形式：</p><p>$\begin{bmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{bmatrix}\begin{bmatrix}<br>    x\\ y\\ z\\<br>\end{bmatrix} = \begin{bmatrix}<br>    -d_1\\<br>    -d_2\\<br>    -d_3\\<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>    x\\ y\\ z\\<br>\end{bmatrix} = \begin{bmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{bmatrix}^{-1}\begin{bmatrix}<br>    -d_1\\<br>    -d_2\\<br>    -d_3\\<br>\end{bmatrix}$</p><h2 id="平面直线相交"><a href="#平面直线相交" class="headerlink" title="平面直线相交"></a>平面直线相交</h2><p>空间中的平面和直线可能会相较于某一点，交点可以通过平面和直线的线性方程组求解：</p><p>$\begin{cases}<br>    \textbf{Plane}, &amp; ax+by+cz+d = 0\\<br>    \textbf{Line}, &amp; \textbf{p}_1 + t\vec{v} = (x_1+tv_x,y_1+tv_y,z_1+tv_z)<br>\end{cases}$</p><p>$t = \dfrac{-(ax_1+by_1+cz_1+d)}{av_x+bv_y+cv_z}=\dfrac{-(\vec{n}\cdot\textbf{p}_1+d)}{\vec{n}\cdot\vec{v}}$</p><h3 id="克莱默法则（-Cramer’s-Rule-）"><a href="#克莱默法则（-Cramer’s-Rule-）" class="headerlink" title="克莱默法则（$Cramer’s\;Rule$）"></a>克莱默法则（$Cramer’s\;Rule$）</h3><p>克莱默法则，用于求解具有n个线性方程的方程组。</p><p>$\begin{cases}<br>   a_{11}x_1+a_{12}x_2 +…+ a_{1n}x_n = b_1\\<br>   a_{21}x_1+a_{22}x_2 +…+ a_{2n}x_n = b_2\\<br>   …………………………………..\\<br>   a_{n1}x_1+a_{n2}x_2 +…+ a_{nn}x_n = b_n<br>\end{cases}$</p><p>若线性方程组的系数行列式不等于0，即$\det{A} =\begin{vmatrix}<br>    a_{11}…a_{1n}\\<br>    …………\\<br>    a_{n1}…a_{nn}\\<br>\end{vmatrix} != 0$</p><p>则线性方程组的解可以用行列式来表示：</p><p>$x_1 = \dfrac{\det{A_1}}{\det{A}}, x_2 = \dfrac{\det{A_2}}{\det{A}}, x_n = \dfrac{\det{A_n}}{\det{A}}$</p><p>其中$\det{A_n}$是把行列式$\det{A}$中第n列的所有元素，依次用方程组右端的常数项替换。</p><h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p>根据克莱默法则，可知：</p><p>$x = \dfrac{\det{A_x}}{\det{A}},y = \dfrac{\det{A_y}}{\det{A}},z = \dfrac{\det{A_z}}{\det{A}}$</p><p>$\det{A} = \begin{vmatrix}<br>    a_1&amp;b_1&amp;c_1\\<br>    a_2&amp;b_2&amp;c_2\\<br>    a_3&amp;b_3&amp;c_3\\<br>\end{vmatrix}$</p><p>$\det{A_x} = \begin{vmatrix}<br>    -d_1&amp;b_1&amp;c_1\\<br>    -d_2&amp;b_2&amp;c_2\\<br>    -d_3&amp;b_3&amp;c_3\\<br>\end{vmatrix},\det{A_y} = \begin{vmatrix}<br>    a_1&amp;-d_1&amp;c_1\\<br>    a_2&amp;-d_2&amp;c_2\\<br>    a_3&amp;-d_3&amp;c_3\\<br>\end{vmatrix},\det{A_z} = \begin{vmatrix}<br>    a_1&amp;b_1&amp;-d_1\\<br>    a_2&amp;b_2&amp;-d_2\\<br>    a_3&amp;b_3&amp;-d_3\\<br>\end{vmatrix}$</p><p>$p = \dfrac{-d_1(\vec{n_2}\times\vec{n_3}) -d_2(\vec{n_3}\times\vec{n_1})-d_3(\vec{n_1}\times\vec{n_2})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{n_3})}$</p><h2 id="求两平面相交的直线方程"><a href="#求两平面相交的直线方程" class="headerlink" title="求两平面相交的直线方程"></a>求两平面相交的直线方程</h2><p>两个非平行平面会相交与一条线，直线方程可以用一个方向矢量$\vec{v}$和一个点$\textbf{p}_o$来表示：$\textbf{p}_o + t\vec{v}$,<br>$\vec{v}$垂直于两个平面的法线$\vec{n_1}和\vec{n_2}$，因此$\vec{v} = \vec{n_1}\times\vec{n_2}$</p><p>现在需要找到直线上的任意一点$\textbf{p}_o$,根据上节内容，三个平面相交于一点，因此我们只需要构造出第三个平面（法线为$\vec{v}$并且d = 0），因此第三个平面方程为：</p><p>$v_xx+v_yy+v_zz = 0$</p><p>根据上节三平面求交点公式：</p><p>$\textbf{p}_o = \dfrac{-d_1(\vec{n_2}\times\vec{n_3}) -d_2(\vec{n_3}\times\vec{n_1})-d_3(\vec{n_1}\times\vec{n_2})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{n_3})}$</p><p>$\textbf{p}_o = \dfrac{-d_1(\vec{n_2}\times\vec{v})-d_2(\vec{v}\times\vec{n_1})}{\vec{n_1}\cdot(\vec{n_2}\times\vec{v})}$</p><p>$\textbf{p}_o =\dfrac{(-d_1\vec{n_2} + d_2\vec{n_1})\times\vec{v}}{\vec{v}\cdot\vec{v}}$</p><p>$\textbf{Line} = \textbf{p}_o + t\vec{v}\\<br>= \dfrac{(-d_1\vec{n_2} + d_2\vec{n_1})\times\vec{v}}{\vec{v}\cdot\vec{v}} + t\vec{v}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="http://www.songho.ca/math/plane/plane.html">songho-openGL</a></p><p><a href="https://zhuanlan.zhihu.com/p/161429987">克莱默法则</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十六）：几何图元-球体圆形和平面</title>
      <link href="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/"/>
      <url>/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十六）：几何图元-球体圆形和平面"><a href="#图形学的数学基础（十六）：几何图元-球体圆形和平面" class="headerlink" title="图形学的数学基础（十六）：几何图元-球体圆形和平面"></a>图形学的数学基础（十六）：几何图元-球体圆形和平面</h1><pre><code>转载请注明出处</code></pre><h2 id="球体和圆形"><a href="#球体和圆形" class="headerlink" title="球体和圆形"></a>球体和圆形</h2><p>球体是一个三维对象，定义与给定点具有固定距离的所有点的集合。从球体中心到点的距离称为球体半径（$Radius$），球体的直接表示方式是描述其中心$\textbf{c}$和半径$r$。</p><h3 id="球体的隐式表述"><a href="#球体的隐式表述" class="headerlink" title="球体的隐式表述"></a>球体的隐式表述</h3><p>$||\textbf{p} - \textbf{c}|| = r$</p><p>$(x-x_c)^2 + (y-y_c)^2 + (z-z_c)^2 = r^2$</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><ul><li>直径 $D = 2r$</li><li>圆周长 $C = 2\pi{r}$</li><li>圆面积 $A = \pi{r^2}$</li><li>球体表面积 $S = 4\pi{r^2}$</li><li>球体体积 $S = \dfrac{4}{3}\pi{r^3}$</li></ul><p><strong>圆面积对r的导数是圆周长，球体的体积对r的导数是其表面积。</strong></p><h2 id="平面-Plane"><a href="#平面-Plane" class="headerlink" title="平面($Plane$)"></a>平面($Plane$)</h2><p>平面是三维的扁平的二维子空间。平面的定义类似于二维中直线的定义。定义中的种种相似性暗示了三维中的平面与二维中的无限直线有许多共同属性的事实。</p><h3 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h3><p>3D空间的平面方程是由一个法线$\vec{n}$($normal\;vector$)和平面上的一个点$p_1$来定义的。</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/1.jpg" alt="平面定义"></p><p>由于$\hat{n}$与平面垂直，所以从平面上任意一点$\textbf{P}$到$\textbf{P}_1$所形成的矢量$\vec{P} - \vec{P_1}$必然与$\hat{n}$垂直。</p><p>$\vec{P} - \vec{P_1} = (x-x_1,y-y_1,z-z_1)$</p><p>$\hat{n}\cdot(\vec{P} - \vec{P_1}) = 0$</p><p>$\begin{bmatrix}<br>    a\\ b\\ c\\<br>\end{bmatrix}\cdot\begin{bmatrix}x-x_1\\ y-y_1\\ z-z_1\\ \end{bmatrix} = 0$</p><p>$a(x-x_1) + b(y-y_1) + c(z-z_1) = 0$</p><p>$ax + by + cz -(ax_1 + by_1 + cz_1) = 0$</p><p>假设常量项$-(ax_1 + by_1 + cz_1) = d$,则：</p><p>$ax+by+cz+d = 0$</p><h4 id="平面方程的几何解释"><a href="#平面方程的几何解释" class="headerlink" title="平面方程的几何解释"></a>平面方程的几何解释</h4><p>$\textbf{p}\cdot\hat{n} = d$</p><p>由矢量点积的几何意义可知，上式说明了矢量$\vec{p}$到$\hat{n}$的投影长度都为固定长度d。</p><p>矢量$\vec{n}$称为平面法线（$Normal$），因为它与平面垂直，法线决定了平面的方向性，d则定义了从原点到平面的有符号垂直距离（跟直线的定义很相似，只不过拓展到了三维空间），增加d将使平面朝法线方向滑动，如果 d &gt; 0，则原点位于平面的背面，如果d &lt; 0则原点位于正面。</p><p>我们通常认为平面具有正面和背面，平面的正面就是$\hat{n}$所指的方向。</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/2.jpg" alt="平面定义"></p><h3 id="三个点定义平面"><a href="#三个点定义平面" class="headerlink" title="三个点定义平面"></a>三个点定义平面</h3><p>定义平面的另一种方式是给出位于平面的三个非共线点。三个共线的点无法定义平面，因为会有无数个包含该直线的平面，并且无法确定我们指的是其中哪一个。</p><p>假设三个非共线点$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$,要确定一个平面，必须求出$\hat{n}和d$，首先必须计算$\hat{n}$，$\hat{n}$会朝哪个方向呢？在左手系中执行此操作的标准方法是假设从平面的正面观察时，$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$按顺时针方向列出（右手系为逆时针方向）：</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%90%83%E4%BD%93%E5%9C%86%E5%BD%A2%E5%92%8C%E5%B9%B3%E9%9D%A2/3.jpg" alt="三点定义平面"></p><p>注：<strong>按照右手系方式定义</strong></p><p>按照逆时针方向构造两个矢量$\vec{e_1}和\vec{e_2}$,$\hat{n}$与$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$构造的平面垂直，那么必然也与$\vec{e_1}和\vec{e_2}$垂直。因此自然可以想到矢量叉积.</p><p>$\vec{e_3} = \textbf{p}_2 - \textbf{p}_1$</p><p>$\vec{e_1} = \textbf{p}_3 - \textbf{p}_2$</p><p>$\hat{n} = \dfrac{\vec{e_3}\times\vec{e_1}}{||\vec{e_3}\times\vec{e_1}||}$</p><p> 计算出了$\hat{n}$，剩下的就是计算$d$，取$\textbf{p}_1,\textbf{p}_2,\textbf{p}_3$中任意一点，和$\hat{n}$做点积即可。</p><p> 完整计算过程如下：</p><p>$\vec{e_3} = \textbf{p}_2 - \textbf{p}_1$</p><p>$\vec{e_1} = \textbf{p}_3 - \textbf{p}_2$</p><p>$\hat{n} = \dfrac{\vec{e_3}\times\vec{e_1}}{||\vec{e_3}\times\vec{e_1}||}$</p><p>$d = \vec{p_1}\cdot\hat{n} = \vec{p_1}\dfrac{(\textbf{p}_2 - \textbf{p}_1)\times(\textbf{p}_3 - \textbf{p}_1)}{||(\textbf{p}_2 - \textbf{p}_1)\times(\textbf{p}_3 - \textbf{p}_1)||}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="http://www.songho.ca/math/plane/plane.html">songho-openGL</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十五）：几何图元-直线和光线</title>
      <link href="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/"/>
      <url>/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="几何图元-直线和光线"><a href="#几何图元-直线和光线" class="headerlink" title="几何图元-直线和光线"></a>几何图元-直线和光线</h1><h2 id="几何表述"><a href="#几何表述" class="headerlink" title="几何表述"></a>几何表述</h2><p>在计算机图形学中，描述几何形状的主要策略有两大类：隐式几何和显示几何。</p><h3 id="隐式几何（-implicit-Geometry-）"><a href="#隐式几何（-implicit-Geometry-）" class="headerlink" title="隐式几何（$implicit Geometry$）"></a>隐式几何（$implicit Geometry$）</h3><p>通过隐函数的方式描述一个对象,一般采用$f(x,y,z) = 0$的定义方式，告诉了我们$x,y,z$需要满足的关系。例如对于三维空间以原点为圆心的单位球可以这表示：</p><p>$x^2+y^2+z^2 = 1$</p><p>隐函数形式可以方便的通过将点带入函数，很方便的判断点是否在几何表面上，之内或之外。但是隐函数无法直观的告诉有哪些点是满足这种关系的。</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/1.jpg" alt="隐式几何"></p><ul><li>代数方法</li><li>CSG</li><li>distance Function</li><li>level Set Methods</li><li>Fractals</li></ul><h3 id="显示几何（-explicit-Geometry-）"><a href="#显示几何（-explicit-Geometry-）" class="headerlink" title="显示几何（$explicit Geometry$）"></a>显示几何（$explicit Geometry$）</h3><p>描述几何的另外一种方式是参数方程。同样地，几何仍由函数定义，但这一次$x,y,z$不是作为输入，而是作为输出。我们以二维平面的单位圆为例：</p><p>$x(t) = \cos2\pi{t}$</p><p>$y(t) = \sin2\pi{t}$</p><p>当t从0变为1时，点$(x(t),y(t))$将显示要描述的形状的轮廓:</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/2.jpg" alt="显示几何-单位元"></p><p>另外一个例子，uv坐标映射为三维空间的$x,y,z$：</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/3.jpg" alt="隐式几何-马鞍"></p><p>通常情况下，参数会被归一化为$[0,1]$之间。</p><p>显示几何跟隐式几何相反，它可以直观的告诉空间中的哪些点满足要求，但是对于空间中的一个点，它不好判定点是否在几何表面。</p><h2 id="光线（-Ray-）"><a href="#光线（-Ray-）" class="headerlink" title="光线（$Ray$）"></a>光线（$Ray$）</h2><p>从现在开始将逐步展开介绍特定的几何图元。首先从最基本也是最重要的一个开始，线性段（$Linear Segment$），有三种基本类型的线性段，分别为：</p><ul><li>直线：可以在两个方向上无限延伸</li><li>线段：具有两个端点的直线的有限部分</li><li>光线：具有原点并在一个方向上无限延申</li></ul><h3 id="光线定义"><a href="#光线定义" class="headerlink" title="光线定义"></a>光线定义</h3><p>光线有两个属性，分别为起点和方向,那么在任意时间t（$0 &lt;= t &lt;\infin$）,光线到达的位置由以下方程定义：</p><p>$\textbf{Ray}(t) = \textbf{origin} + t\textbf{d}\;\;\;\;(0 &lt;= t &lt;\infin)$</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/4.jpg" alt="隐式几何-马鞍"></p><p>尽管矢量格式更紧凑，并且具有很好的属性，但是也可以为每个坐标写出一个单独的标量函数：</p><p>$x(t) = origin_x + td_x$</p><p>$y(t) = origin_y + td_y$</p><p>$z(t) = origin_z + td_z$</p><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>直线虽然简单，却有好几种不同的定义方式，这些定义从不同的角度理解直线。</p><h3 id="斜截式（-Slope-Intercept-）"><a href="#斜截式（-Slope-Intercept-）" class="headerlink" title="斜截式（$Slope-Intercept$）"></a>斜截式（$Slope-Intercept$）</h3><p>斜截式是一种在二维中表达直线的形式，符号$m$表示竖直高度与水平高度的比率（斜率），$y_0$<br>表示y轴截距，是直线与y轴交叉的位置。</p><p>$y = mx + y_0$</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/5.jpg" alt="斜截式"></p><p>注：垂直线有无限斜率（$x = n$），无法用$y = mx + y_0$的方式表达，可以通过以下略有不同的隐函数解决这个奇点问题：</p><p>$ax + by = d$</p><h3 id="点乘法"><a href="#点乘法" class="headerlink" title="点乘法"></a>点乘法</h3><p>$ax + by = d$可以看作$点p\begin{bmatrix}<br>    x\\ y\\<br>\end{bmatrix}$和矢量$n\begin{bmatrix}<br>    a\\ b\\<br>\end{bmatrix}$的点积，即：</p><p>$\textbf{p}\cdot\textbf{n} = d$</p><p>根据矢量点积的定义，$\textbf{p}\cdot\textbf{n}$等于$\textbf{p}$在$\textbf{n}$上投影的长度：</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/6.jpg" alt="点乘法"></p><p><strong>矢量$\hat{n}$是与直线垂直的的单位矢量。d是从原点到直线的有符号垂直距离。任何投影到$\hat{n}$的长度等于$d$的点都满足直线方程。这里之所以采用有符号距离，意思是如果直线位于和法线点相同的原点的一侧，则$d$为正，随着$d$的增加，直线将沿着$\hat{n}$的方向移动。</strong></p><h3 id="垂直平分线（-Perpendicular-Bisector-）"><a href="#垂直平分线（-Perpendicular-Bisector-）" class="headerlink" title="垂直平分线（$Perpendicular\;Bisector$）"></a>垂直平分线（$Perpendicular\;Bisector$）</h3><p>定义直线的最后一种方式是作为两点的垂直平分线：</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%A0%E4%BD%95%E5%9B%BE%E5%85%83-%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%85%89%E7%BA%BF/7.jpg" alt="点乘法"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十四）：极坐标系</title>
      <link href="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十四）：极坐标系"><a href="#图形学的数学基础（十四）：极坐标系" class="headerlink" title="图形学的数学基础（十四）：极坐标系"></a>图形学的数学基础（十四）：极坐标系</h1><p>笛卡尔坐标系不是精确绘制空间和定义位置的唯一系统。笛卡尔系统的替代方案是极坐标系($Polar\;Coordinate\;System$)</p><h2 id="二维极坐标系"><a href="#二维极坐标系" class="headerlink" title="二维极坐标系"></a>二维极坐标系</h2><p>二维笛卡尔坐标系有一个原点和两个穿过原点的轴（x，y）。二维极坐标空间也有一个原点，称为极点（$Pole$）-定义了坐标空间的中心,不同的是,极坐标系只有一个轴,称为极轴（$Polar\; Axis$）,</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/1.png" alt="二维极坐标系"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在极坐标系中,我们通常用$(r,\theta)$定义一个点,r为极轴的长度,$\theta$为极轴旋转角度(逆时针方向).</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/2.jpg" alt="二维极坐标系"></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>极坐标系中有一个不同于笛卡尔坐标系的显著特征.笛卡尔坐标系中空间中一个点对应唯一的坐标(x,y)，而在极坐标中，空间中的一个点可能对应多个坐标.原因就在于极坐标系的定义($r, \theta$)。$\theta与\theta + 360^°$指定的是同一个方向。也可以将$\theta + 180^°$同时r取反来实现。</p><p>因此：$(r,\theta) = (r, \theta + 360^°) = ((-1)^kr, \theta + k180^° )$。<br>尽管存在别名，但是我们尽可能需要采用最优的描述点的方式。描述任何给定点的“首选”方式称为该点的规范（$Canonical$）坐标,规范化坐标需要满足以下三个条件：</p><ul><li>$r&gt;=0$</li><li>$-180^° &lt; \theta &lt;= 180^°$</li><li>$如果 r = 0，则 \theta = 0$</li></ul><h3 id="笛卡尔坐标系和极坐标转换-二维"><a href="#笛卡尔坐标系和极坐标转换-二维" class="headerlink" title="笛卡尔坐标系和极坐标转换(二维)"></a>笛卡尔坐标系和极坐标转换(二维)</h3><p>假设二维空间中的一点$P$，笛卡尔坐标为$(x, y)$，极坐标表述为$(r, \theta)$,则它们之间的转换关系如下：</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/3.jpg" alt="二维极坐标系"></p><p><strong>笛卡尔坐标系和极坐标转换主要用到了三角函数</strong>.</p><h4 id="二维极坐标系转换为笛卡尔坐标系"><a href="#二维极坐标系转换为笛卡尔坐标系" class="headerlink" title="二维极坐标系转换为笛卡尔坐标系"></a>二维极坐标系转换为笛卡尔坐标系</h4><p>$x = r\cos\theta$</p><p>$y = r\sin\theta$</p><h4 id="笛卡尔坐标系转换极坐标系"><a href="#笛卡尔坐标系转换极坐标系" class="headerlink" title="笛卡尔坐标系转换极坐标系"></a>笛卡尔坐标系转换极坐标系</h4><p>$r = \sqrt{x^2 + y^2}$</p><p>$\theta = \arctan2(y,x)$</p><h2 id="三维极坐标系"><a href="#三维极坐标系" class="headerlink" title="三维极坐标系"></a>三维极坐标系</h2><p>极坐标系同样可应用于三维，三维极坐标系有三个值，是从二维极坐标系拓展而来的，第三个坐标值可以是角度也可以是另外个长度。这样就衍生出了两种极坐标系。</p><h3 id="圆柱坐标（-Cylindrical-Coordinate-）"><a href="#圆柱坐标（-Cylindrical-Coordinate-）" class="headerlink" title="圆柱坐标（$Cylindrical\;Coordinate$）"></a>圆柱坐标（$Cylindrical\;Coordinate$）</h3><p>如果第三个极坐标值添加的是线性距离（$z$），那么得到的就是一个圆柱坐标。</p><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/4.jpg" alt="二维极坐标系"></p><h4 id="球面坐标和三维笛卡尔坐标转换"><a href="#球面坐标和三维笛卡尔坐标转换" class="headerlink" title="球面坐标和三维笛卡尔坐标转换"></a>球面坐标和三维笛卡尔坐标转换</h4><p>由上图可知，球面坐标和三维笛卡尔坐标的z值是相同的，因此只需要按照二维极坐标的转换逻辑转换xy值即可</p><p>圆柱坐标转换为三维坐标：</p><p>$x = r\cos\theta$</p><p>$y = r\sin\theta$</p><p>$z = z$</p><p>三维坐标转换为圆柱坐标：</p><p>$r = \sqrt{x^2+y^2}$</p><p>$\theta = \arctan2(y, x)$</p><p>$z = z$</p><h3 id="球面坐标（-Spherical-Coordinate-System-）"><a href="#球面坐标（-Spherical-Coordinate-System-）" class="headerlink" title="球面坐标（$Spherical\;Coordinate\;System$）"></a>球面坐标（$Spherical\;Coordinate\;System$）</h3><p>更常见的三维坐标系是球面坐标系，球面坐标具有两个角度和一个距离$(r, \theta, \phi)$。三维球形空间中有两个极轴：  第一个水平轴，对应二维极坐标中的极轴，另一个垂直轴 对应三维笛卡尔坐标的$+y$。</p><h4 id="三维极坐标定位方式"><a href="#三维极坐标定位方式" class="headerlink" title="三维极坐标定位方式"></a>三维极坐标定位方式</h4><ul><li>站在原点，面向水平极轴方向（$x$），垂直轴的指向从脚指向头部。右臂向上。指向垂直极轴。</li><li>逆时针旋转$\theta$</li><li>将手臂向下旋转角度$\phi$，右臂现在指向极角$\theta和\phi$的方向。</li><li>沿着该方向从原点移动距离r，这时你就叨叨了球面坐标$(r,\theta,\phi)$描述的点。</li></ul><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/6.jpg" alt="二维极坐标系"></p><p>水平角$\theta$称为方位角（$Azimuth$）,$\phi$称为天顶($Zenith$)。我们日常使用的经纬度其实也是一种球面坐标系。经度($Longitude$)与$\theta$相同，维度($Latitude$)是$90^° - \phi$。由于我们通常只描述行星表面的点，所以r是个常数。</p><h4 id="球面坐标规范化条件"><a href="#球面坐标规范化条件" class="headerlink" title="球面坐标规范化条件"></a>球面坐标规范化条件</h4><ul><li>$r &gt;= 0$</li><li>$180^° &lt; \theta &lt;= 180^°$</li><li>$-90^° &lt; \phi &lt;= 90^°$</li><li>$如果r = 0，则\theta = 0^° \phi = 0^°$</li><li>$如果|\phi| = 90^°，则\theta = 0^°$</li></ul><h4 id="球面坐标和三维笛卡尔坐标的转换（右手系）"><a href="#球面坐标和三维笛卡尔坐标的转换（右手系）" class="headerlink" title="球面坐标和三维笛卡尔坐标的转换（右手系）"></a>球面坐标和三维笛卡尔坐标的转换（右手系）</h4><p><img src="/2022/09/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/7.jpg" alt="二维极坐标系"></p><p>由上图可知：<br><strong>球面坐标-&gt;三维笛卡尔坐标：</strong></p><p>$d = r\sin\phi$</p><p>$x = d\cos\theta = r\sin\phi\cos\theta$</p><p>$y = d\sin\theta = r\sin\phi\sin\theta$</p><p>$z = r\cos\phi$</p><p><strong>三维笛卡尔坐标-&gt;球面坐标：</strong></p><p>$r=\sqrt{x^2+y^2+z^2}$</p><p>$\theta = \arctan2(y,x)$</p><p>$\phi = \arctan2(r, z)$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十三）：mvp变换(下)</title>
      <link href="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十三）：mvp变换（下）"><a href="#图形学的数学基础（十三）：mvp变换（下）" class="headerlink" title="图形学的数学基础（十三）：mvp变换（下）"></a>图形学的数学基础（十三）：mvp变换（下）</h1><p>本章我们将实现mvp变换中的投影变换（$projection Transform$和视口变换($viewport)，投影变换有两种方式，分别为正交投影（$Orthographic projection$）和透视投影（$perspective projection$）.两种投影方式最终都将视景体内的物体投影到近平面上（将视图从相机空间映射到$[-１,１]^３$），也是3D空间映射到2D屏幕空间最为关键的一步。的标准立方体中，如下图所示：</p><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/3.png" alt="正交投影和透视投影"></p><h2 id="正交投影（-Orthographic-projection-）"><a href="#正交投影（-Orthographic-projection-）" class="headerlink" title="正交投影（$Orthographic projection$）"></a>正交投影（$Orthographic projection$）</h2><p>正交投影会保持几何图元相对位置关系不变，平行的线永远平行。不满足透视关系。又叫做平行投影。</p><p>正交投影的“视景体”是一个长方形，由 top bottom left right near far6个参数定义。如下图所示：<br><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/4.png" alt="正交投影和透视投影"></p><p>如何将该长方体映射到$[-1,1]^3$呢?和$\textbf{M}_{view}$类似,我们先将立方体中心移动到原地,然后根据每个方向的长度,缩放到[-1,1]之间.即$\textbf{M}_{scale}$$\textbf{M}_{translate}$.需要一次平移变换 + 一次缩放变换.</p><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/5.jpg" alt="正交投影和透视投影"></p><h3 id="textbf-M-translate-平移矩阵"><a href="#textbf-M-translate-平移矩阵" class="headerlink" title="$\textbf{M}_{translate}$平移矩阵"></a>$\textbf{M}_{translate}$平移矩阵</h3><p>根据正交投影视景体的6个参数,我们可以计算出它的中心位置.即:</p><p>$\textbf{center} = \begin{bmatrix}<br>    \dfrac{r+l}{2}\\<br>    \dfrac{t+b}{2}\\<br>    \dfrac{n+f}{2}\\<br>\end{bmatrix}$</p><p>$\textbf{M}_{translate} = \begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="textbf-M-scale-缩放矩阵"><a href="#textbf-M-scale-缩放矩阵" class="headerlink" title="$\textbf{M}_{scale}$缩放矩阵"></a>$\textbf{M}_{scale}$缩放矩阵</h3><p>同样的,根据视景体6个参数,可以计算出立方体的长宽高(假设z方向的边为长,y方向的边为高)分别为:<br>$n-f, r-l, t-b$.</p><p>根据缩放矩阵的定义可知:<br>$\textbf{M}_{scale} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h3><p>$\textbf{M}_{orthographic} = \textbf{M}_{scale}$$\textbf{M}_{translate} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h2 id="透视投影（-perspective-projection-）"><a href="#透视投影（-perspective-projection-）" class="headerlink" title="透视投影（$perspective projection$）"></a>透视投影（$perspective projection$）</h2><p>透视投影满足透视关系，即近大远小的效果。平行的线可能在远处相较于某一点。符合人眼视觉系统。计算机图形学中绝大部分都是使用透视投影，来模拟人自然看到物体的样子。<br><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/2.png" alt="正交投影和透视投影"></p><h3 id="视锥体（-Frustum-）定义"><a href="#视锥体（-Frustum-）定义" class="headerlink" title="视锥体（$Frustum$）定义"></a>视锥体（$Frustum$）定义</h3><p>和正交投影不同,透视投影的视景体是个截锥体(Frustum)<br><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/6.jpg" alt="正交投影和透视投影"><br>视锥体由以下几个参数定义：</p><ul><li>fov（field of view）: 视角范围</li><li>aspectRatio（长宽比）：定义近平面的宽高比</li><li>n（近平面距离）：近平面距离原点距离</li></ul><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/8.jpg" alt="正交投影和透视投影"></p><p>由视锥体的参数可以推导出$l,r,b,t$：</p><p>$\tan\dfrac{fov}{2} = \dfrac{t}{|n|}$</p><p>$aspectRatio = \dfrac{r}{t}$</p><h3 id="推导原理"><a href="#推导原理" class="headerlink" title="推导原理"></a>推导原理</h3><p>观察上图我们发现,透视投影远平面比近平面要大些,除了这些两个视景体几乎是一样的。所以在我们做透视投影变换时，不妨先将其转换为右侧的长方体，然后再做一次正交投影变换即可。</p><p>$\textbf{M}_{perspective} = \textbf{M}_{orthographic}\textbf{M}_{persp-&gt;ortho}$</p><h3 id="“挤压变换”"><a href="#“挤压变换”" class="headerlink" title="“挤压变换”"></a>“挤压变换”</h3><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/7.jpg" alt="正交投影和透视投影"></p><p>任选一点P，如果将其“挤压”至P1点，我们观察$\triangle{OPR}和\triangle{NPP1}$,不难发现两个三角形是相似三角形，根据相似三角形定律: $y^丶 = \dfrac{ny}{z}$,同理 $x^丶 = \dfrac{nx}{z}$.</p><p>在齐次坐标下：</p><p>$\textbf{M}_{persp-&gt;ortho}\begin{bmatrix}<br>    x\\ y\\ z\\ 1\\<br>\end{bmatrix} = \begin{bmatrix}\dfrac{nx}{z}\\ \dfrac{ny}{z}\\ unknown \\1 \end{bmatrix} = \begin{bmatrix}nx\\ ny\\ unknown \\z \end{bmatrix}$</p><p>$\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    ?&amp;?&amp;?&amp;?\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><p>近平面的任意一点在挤压后的z值不会改变：</p><p>$\begin{bmatrix}\dfrac{nx}{n}\\ \dfrac{ny}{n}\\ n \\1 \end{bmatrix} = \begin{bmatrix}nx\\ ny\\ n^2  \\n\end{bmatrix}$</p><p>$\begin{bmatrix}<br>    0&amp;0&amp;A&amp;B<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ n\\ 1\\ \end{bmatrix} = n^2$</p><p>$An + B = n^2$</p><p>远平面的任意一点挤压后z值不会改变,更特殊的是，远平面的中心点（0，0，f）在挤压后仍然在（0，0，f），根据这一特性我们能够得到：</p><p>$\begin{bmatrix}0\\ 0\\ f \\1 \end{bmatrix} = \begin{bmatrix}0\\ 0\\ f^2  \\f\end{bmatrix}$</p><p>$Af + B = f^2$</p><p>解二元一次方程组：</p><p>$An + B = n^2$</p><p>$Af + B = f^2$</p><p>$A = n+f$  </p><p>$B = -nf$</p><p>$\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    ?&amp;?&amp;?&amp;?\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix} \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;A&amp;B\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix} = \begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;n+f&amp;-nf\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><p>$\textbf{M}_{perspective} = \textbf{M}_{orthographic}\textbf{M}_{persp-&gt;ortho} = \begin{bmatrix}<br>    \dfrac{2}{r-l}&amp;0&amp;0&amp;0\\<br>    0&amp;\dfrac{2}{t-b}&amp;0&amp;0\\<br>    0&amp;0&amp;\dfrac{2}{n-f}&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;\dfrac{r+l}{2}\\<br>    0&amp;1&amp;0&amp;\dfrac{t+b}{2}\\<br>    0&amp;0&amp;1&amp;\dfrac{n+f}{2}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    n&amp;0&amp;0&amp;0\\<br>    0&amp;n&amp;0&amp;0\\<br>    0&amp;0&amp;n+f&amp;-nf\\<br>    0&amp;0&amp;1&amp;0\\<br>\end{bmatrix}$</p><h2 id="视口变换-viewport"><a href="#视口变换-viewport" class="headerlink" title="视口变换($viewport$)"></a>视口变换($viewport$)</h2><p>经过复杂的投影变换后，我们将空间中的一个视景体映射到了$[-1,1]^3$的标准立方体中，接下来我们将通过视口变换将其映射到屏幕空间中。</p><h3 id="屏幕空间（-screenSpace-）定义"><a href="#屏幕空间（-screenSpace-）定义" class="headerlink" title="屏幕空间（$screenSpace$）定义"></a>屏幕空间（$screenSpace$）定义</h3><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/9.jpg" alt="正交投影和透视投影"></p><ul><li>屏幕左下角为原点（0，0）</li><li>向右为x，向上为y</li><li>像素（pixel）的坐标以（x，y）表示，xy均为整数</li><li>像素坐标的范围 （0，0） ~ （width - 1，height - 1）</li><li>Pixel（x，y）的中心点位于（x+0.5，y+0.5）</li><li>每个像素形成单位宽高的“正方体”</li><li>屏幕空间覆盖范围为（0，0）~（width，height）</li></ul><h3 id="从-1-1-2-到-0-width-0-height"><a href="#从-1-1-2-到-0-width-0-height" class="headerlink" title="从$[-1,1]^2 到 [0,width] [0,height]$"></a>从$[-1,1]^2 到 [0,width] [0,height]$</h3><p>原地缩放 $\begin{bmatrix}<br>     \dfrac{width}{2}\\<br>    \dfrac{height}{2}<br>\end{bmatrix}$，然后平移到$\begin{bmatrix}<br>    \dfrac{width}{2}\\<br>    \dfrac{height}{2}<br>\end{bmatrix}$</p><p>$\textbf{M}_{viewport} = \begin{bmatrix}<br>    \dfrac{width}{2}&amp;0&amp;0&amp;\dfrac{width}{2}\\<br>    0&amp;\dfrac{height}{2}&amp;0&amp;\dfrac{height}{2}\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=5&amp;spm_id_from=pageDriver&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://item.jd.com/10037953813770.html">fundamentals-of-computer-graphics</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十二）：mvp变换（上）</title>
      <link href="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十二）：mvp变换（上）"><a href="#图形学的数学基础（十二）：mvp变换（上）" class="headerlink" title="图形学的数学基础（十二）：mvp变换（上）"></a>图形学的数学基础（十二）：mvp变换（上）</h1><p>图形系统的一个重要任务是将三维空间中的模型映射到二维平面上（以像素为单位），这是一个复杂的过程，取决于许多因素，包括但不限于相机的位置，方向，投影的类型（正交/透视），fov，和viewport宽高，对于所有复杂的矩阵变换，最好的做法是将其分解为几个更简单的矩阵乘积。大多数图形系统通过使用四个转换序列来实现m,以openGL为例：</p><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/1.png" alt="mvp变换"></p><ol><li><p><strong>modelMatrix</strong>：将视图从模型空间转换为世界空间。直白的说就是将模型摆放到世界坐标空间的何处。这一步确立了世界空间中各模型的相对布局，摆放位置。</p></li><li><p><strong>viewMatrix</strong>：将视图从世界空间转换到相机空间。简单来讲就是：我们从何处，在什么角度，朝什么方向观察我们的世界。</p></li><li><p><strong>Projection</strong>：将视图从相机空间映射到$[-１,１]^３$，的单位立方体中，为了下一步viewport变换做准备</p></li><li><p><strong>viewport</strong>: 将视图从单位立方体映射到所需的屏幕空间（screenSpace），取决于输出图像的大小和位置。</p></li></ol><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/2.png" alt="mvp变换"></p><h2 id="view-Transform"><a href="#view-Transform" class="headerlink" title="view Transform"></a>view Transform</h2><p>现实生活中，如果相机和所有物体一起移动（相对位置关系不变），则拍出来的照片也都是一样的。根据这个原理我们得出：将相机移动到原点，朝向-z方向，构造出一个变换矩阵$\textbf{M}_{view}$，其他物体随着相机一起移动（应用$\textbf{M}_{view}$）。即可完成viewTransform。如何构造$\textbf{M}_{view}$？将视图从世界空间转换到相机空间？首先需要定义相机参数：</p><ul><li>位置（eye Position）：$\mathbf{e}$</li><li>观测方向（gaze Direction）：$\vec{g}$</li><li>向上方向（up Direction）：$\vec{t}$</li></ul><p>根据这些信息，我们可以构造一个以$\mathbf{e}$为原点的uvw标准正交基。</p><ul><li>矢量正交化</li><li>将$\mathbf{e}$移动到原点</li><li>旋转$\vec{g}$ 到-z方向</li><li>旋转$\vec{t}$到y方向</li><li>旋转$\vec{g}\times \vec{t}$到x方向。</li></ul><p>因此我们可以将$\textbf{M}_{view}$拆解成平移和旋转两个部分.首先需要对相机参数的矢量进行正交化。</p><p>$\textbf{M}_{view}$ = $\textbf{R}_{view}$$\textbf{T}_{view}$</p><p><img src="/2022/09/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Amvp%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/3.png" alt="mvp变换"></p><h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><p>根据前边章节讲过的矢量叉乘正交化的方法，可以计算出：</p><p>$\hat{w} = -\dfrac{\vec{g}}{||g||}$</p><p>$\hat{u} = \dfrac{\mathbf{t}\times \mathbf{w}}{||\mathbf{t}\times \mathbf{w}||}$</p><p>$\hat{v} = \mathbf{w}\times \mathbf{u}$</p><h3 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h3><p>$\textbf{T}_{view}$ = $\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-x_{e}\\<br>    0&amp;1&amp;0&amp;-y_{e}\\<br>    0&amp;0&amp;1&amp;-z_{e}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>旋转矩阵不好写，但是我们可以反过来思考这个问题，将x（1，0，0），y（0，1，0），z（0，0，1）分别旋转到$\hat{u}$,$\hat{v}$, $-\hat{w}$是很好写的，由于这两个矩阵互为逆矩阵，根据旋转矩阵的性质，旋转矩阵都是正交的，而正交矩阵的逆矩阵等于其转置。所以我们可以先求$\textbf{R}_{view}$的逆矩阵，然后将其转置，即可得到$\textbf{R}_{view}$：</p><p>$\textbf{R}_{view}^{-1}$ = $\begin{bmatrix}<br>    x_u&amp;x_v&amp;x_w&amp;0\\<br>    y_u&amp;y_v&amp;y_w&amp;0\\<br>    z_u&amp;z_v&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><p>$\textbf{R}_{view}$ = $\begin{bmatrix}<br>    x_u&amp;y_u&amp;z_u&amp;0\\<br>    x_v&amp;y_v&amp;z_v&amp;0\\<br>    x_w&amp;y_w&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h3 id="合到一起"><a href="#合到一起" class="headerlink" title="合到一起"></a>合到一起</h3><p>$\textbf{M}_{view} = \textbf{R}_{view}\textbf{T}_{view} = \begin{bmatrix}<br>    x_u&amp;y_u&amp;z_u&amp;0\\<br>    x_v&amp;y_v&amp;z_v&amp;0\\<br>    x_w&amp;y_w&amp;z_w&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>    1&amp;0&amp;0&amp;-x_{e}\\<br>    0&amp;1&amp;0&amp;-y_{e}\\<br>    0&amp;0&amp;1&amp;-z_{e}\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://item.jd.com/10037953813770.html">fundamentals-of-computer-graphics</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十一）：深入矩阵（下）</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十一）：深入矩阵（下）"><a href="#图形学的数学基础（十一）：深入矩阵（下）" class="headerlink" title="图形学的数学基础（十一）：深入矩阵（下）"></a>图形学的数学基础（十一）：深入矩阵（下）</h1><p>本章是深入矩阵的下半部分，将详细介绍正交矩阵，矩阵的正交化，齐次矩阵。</p><h2 id="正交矩阵（-Orthogonal-Matrix-）"><a href="#正交矩阵（-Orthogonal-Matrix-）" class="headerlink" title="正交矩阵（$Orthogonal\;Matrix$）"></a>正交矩阵（$Orthogonal\;Matrix$）</h2><h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><p>当且仅当矩阵及其转置的乘积是单位矩阵时，方形矩阵$\textbf{M}$是正交的。定义如下：</p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}\textbf{M}^T = \textbf{I}$</p><p>根据上一章逆矩阵的定义，矩阵与其逆相乘等于单位矩阵（$\textbf{M}\textbf{M}^{-1} = \textbf{I}$）,因此，<strong>如果矩阵是正交的，则其转置矩阵和逆矩阵是相等的。</strong></p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}^T = \textbf{M}^{-1}$</p><p>利用正交矩阵的这一特性,我们可以轻易的得到矩阵的逆,只要证明其是正交矩阵即可,这样就避免了复杂的的逆矩阵计算过程(使用转置矩阵即可)。图形学中有很多正交矩阵，例如旋转矩阵和反射矩阵都是正交的。</p><h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>在许多情况下，我们可能获得有关矩阵构造方式的信息，因此可以先验地知道矩阵仅包含旋转或反射。但是如果在我们事先对矩阵一无所知的情况下，如何判断矩阵的正交性呢？</p><p>根据正交矩阵的定义可知：</p><p>$M是正交矩阵  &lt;=&gt;  \textbf{M}\textbf{M}^T = \textbf{I}$</p><p>$\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\ m_{21}&amp;m_{22}&amp;m_{23}\\ m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix}\begin{bmatrix}m_{11}&amp;m_{21}&amp;m_{31}\\ m_{12}&amp;m_{22}&amp;m_{32}\\ m_{13}&amp;m_{23}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\end{bmatrix}$</p><p>设以下矢量$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$代表$\textbf{M}$的行：</p><p>$\textbf{M} = \begin{bmatrix}-&amp;r_1&amp;-\\ -&amp;r_2&amp;-\\ -&amp;r_3&amp;-\\ \end{bmatrix}$</p><p>简化上述矩阵和转置相乘的表达式可得：</p><p>$\mathbf{r_1}\cdot\mathbf{r_1} = 1\;\;\;\;\;\;\mathbf{r_1}\cdot\mathbf{r_2} = 0\;\;\;\;\;\;\mathbf{r_1}\cdot\mathbf{r_3} = 0$</p><p>$\mathbf{r_2}\cdot\mathbf{r_1} = 0\;\;\;\;\;\;\mathbf{r_2}\cdot\mathbf{r_2} = 1\;\;\;\;\;\;\mathbf{r_2}\cdot\mathbf{r_3} = 0$</p><p>$\mathbf{r_3}\cdot\mathbf{r_1} = 0\;\;\;\;\;\;\mathbf{r_3}\cdot\mathbf{r_2} = 0\;\;\;\;\;\;\mathbf{r_3}\cdot\mathbf{r_3} = 1$</p><p>通过上述式子我们推导出正交矩阵需要满足以下几个条件：</p><ol><li>当且仅当矢量为单位矢量时，矢量与自身的点积才为1。 因此$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$为单位矢量。即矩阵的每一行必须是单位矢量。</li><li>当且仅当两个矢量相互垂直时，点积才为0， 因此$\mathbf{r_1},\mathbf{r_2},\mathbf{r_3}$相互垂直，即矩阵的行相互垂直。</li></ol><p><strong>结论： 当且仅当矩阵每一行都为单位矢量且相互垂直的矩阵才是正交矩阵。可以对矩阵的列做同样的描述。因为如果$\textbf{M}$是正交的，$\textbf{M}^T$必然也是正交的。</strong></p><h3 id="矩阵的正交化"><a href="#矩阵的正交化" class="headerlink" title="矩阵的正交化"></a>矩阵的正交化</h3><p>用于构造一组标正交基矢量的标准算法是$Gram-Schmidt$正交化。基本思想是按顺序遍历基矢量。对每个基矢量，减去与基向量平行的矢量，这必然会产生垂直矢量，具体推导细节可以参考之前的文章。</p><p>$\textbf{Gram-Schmidt}\begin{cases}<br>    \vec{v_1} = \vec{x_1}\\<br>    \vec{v_2} = \vec{v_∥} = \vec{x_2} - \vec{x_⊥} = \vec{x_2} - \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}\\<br>    \vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2} = \vec{x_3} - \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}\hat{v_1} - \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}\hat{v_2}<br>\end{cases}$</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（十）：矩阵进阶（上）</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（十）：矩阵进阶（上）"><a href="#图形学的数学基础（十）：矩阵进阶（上）" class="headerlink" title="图形学的数学基础（十）：矩阵进阶（上）"></a>图形学的数学基础（十）：矩阵进阶（上）</h1><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>对于方形矩阵，有一个特殊的标量称为矩阵的行列式（$Determinant$。方形矩阵$\textbf{M}$的行列式表示为$|\textbf{M}|$,也表示为“det M”。非方形矩阵的行列式是未定义的。</p><h3 id="2-times-2-和-3-times-3-矩阵的行列式"><a href="#2-times-2-和-3-times-3-矩阵的行列式" class="headerlink" title="$2\times 2$和$3\times 3$矩阵的行列式"></a>$2\times 2$和$3\times 3$矩阵的行列式</h3><p>$2\times 2$矩阵行列式：</p><p>$\begin{vmatrix}M\end{vmatrix} = \begin{vmatrix}m_{11}&amp;m_{12}\\ m_{21}&amp;m_{22}\end{vmatrix} = m_{11}m_{22} - m_{12}m_{21}$</p><p>$3\times 3$矩阵行列式：</p><p>$\begin{vmatrix}M\end{vmatrix} = \begin{vmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\ m_{21}&amp;m_{22}&amp;m_{23}\\ m_{31}&amp;m_{32}&amp;m_{33}\end{vmatrix} = m_{11}m_{22} - m_{12}m_{21} = m_{11}m_{22}m_{33} + m_{12}m_{23}m_{31} + m_{13}m_{21}m_{32} - m_{13}m_{22}m_{31} - m_{12}m_{21}m_{33} - m_{11}m_{23}m_{32} = m_{11}(m_{22}m_{33} - m_{23}m_{32}) + m_{12}(m_{23}m_{31} - m_{21}m_{33}) + m_{13}(m_{21}m_{32} - m_{22}m_{31})$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8A%EF%BC%89/1.png" alt="3x3矩阵行列式"></p><p>如果将$X\times 3$矩阵的行解释为3个矢量，那么该矩阵的行列式等价于3个矢量的三重积。</p><p>$\begin{vmatrix}<br>    a_x&amp;a_y&amp;a_z\\ b_x&amp;b_y&amp;b_z\\ c_x&amp;c_y&amp;c_z<br>\end{vmatrix}$ = $(a_yb_z -a_zb_y)c_x + (a_zb_x - a_xb_z)c_y + (a_xb_y - a_yb_x)c_z = (\mathbf{a}\times \mathbf{b})\cdot \mathbf{c}$</p><h3 id="子矩阵行列式-Minor-和余子式-Cofactor"><a href="#子矩阵行列式-Minor-和余子式-Cofactor" class="headerlink" title="子矩阵行列式($Minor$)和余子式($Cofactor$)"></a>子矩阵行列式($Minor$)和余子式($Cofactor$)</h3><h3 id="子矩阵行列式"><a href="#子矩阵行列式" class="headerlink" title="子矩阵行列式"></a>子矩阵行列式</h3><p>假设$\textbf{M}$具有r行和c列的矩阵，考虑通过$\textbf{M}$中删除行i和列j而获得的矩阵。该矩阵具有r-1行和c-1列。这个矩阵的行列式表示为$\textbf{M}^{ij}$,被称为$\textbf{M}$的子矩阵行列式。</p><h4 id="余子式"><a href="#余子式" class="headerlink" title="余子式"></a>余子式</h4><p>给定行和列的方形矩阵$\textbf{M}$的余子式与相应的子矩阵行列式相同，但余子式会交替变负，正负取决于因子$(-1)^{i + j}$.矩阵的余子式用来计算$n\times n$任意维度矩阵的行列式。</p><p>$C^{ij} = (-1)^{i+j}M^{ij}$</p><p>我们使用$C^{ij}$表示行i列j中的$\textbf{M}$的余子式。<br>+&amp;-&amp;+&amp;-&amp;…\\<br>$\begin{bmatrix}<br>    +&amp;-&amp;+&amp;-&amp;…\\ -&amp;+&amp;-&amp;+&amp;…\\ +&amp;-&amp;+&amp;-&amp;…\\  -&amp;+&amp;-&amp;+&amp;…\\ …&amp;…&amp;…&amp;…&amp;…<br>\end{bmatrix}$</p><h3 id="行列式的数学定义"><a href="#行列式的数学定义" class="headerlink" title="行列式的数学定义"></a>行列式的数学定义</h3><p>对于任意维度$n\times n$矩阵的行列式，可以通过它的余子式计算。这个定义是递归的，因为<strong>余子式本质上是有符号的行列式</strong>。首先从矩阵中任意选择一行或一列。对于行或列中的每个元素，将此元素诚意相应的余子式，对这些乘积求和可得出颠的行列式：</p><p>$\begin{vmatrix}<br>    \textbf{M}<br>\end{vmatrix} = \sum\limits_{j=1}^n{m_{ij}C^{ij}} = \sum\limits_{j=1}^n{m_{ij}(-1)^{i + j}M^{ij}}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>．任何维度单位矩阵的行列式等于1：$\begin{vmatrix}I\end{vmatrix} = 1$</p><p>．矩阵乘积的行列式等于行列式的乘积：　$\begin{vmatrix}AB\end{vmatrix} = \begin{vmatrix}A\end{vmatrix}\begin{vmatrix}B\end{vmatrix}$</p><p>. 矩阵转置的行列式等于原始行列式：$\begin{vmatrix}M^T\end{vmatrix} = \begin{vmatrix}M\end{vmatrix}$<br>. 如果矩阵中的任何行或者列包含全0元素，则该矩阵的行列式为0<br>. 交换任意行对都会让行列式变负</p><h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p><strong>在几何上行列式表示了当前变换矩阵对空间的压缩或者拉伸程度。</strong>。即经过一次变换后，空间被压缩或者拉伸了多少。二维中，行列式等于具有基矢量作为两条边的平行四边形的有符号面积。三维中，行列式是平行六面体的体积。</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B8%8A%EF%BC%89/2.webp" alt="行列式的几何意义"></p><h2 id="逆矩阵（Inverse）"><a href="#逆矩阵（Inverse）" class="headerlink" title="逆矩阵（Inverse）"></a>逆矩阵（Inverse）</h2><p>对于方形矩阵来说，另一个重要运算是矩阵的逆矩阵。方形矩阵$\textbf{M}$的逆矩阵表示为$\textbf{M}^-1$.</p><p>并非所有矩阵都有逆矩阵。如果某个矩阵具有逆矩阵，则称其为可逆或者非奇异（$Nonsingular$）矩阵。不具有逆的矩阵被认为是不可逆或奇异矩阵。<strong>可逆矩阵的列是先行独立的，列也如此。奇异矩阵的行和列是线性相关的。</strong></p><p>奇异矩阵的行列式为零。非奇异矩阵的行列式为非零。一般情况下检查行列式的大小是最常用的可逆性测试。但是也有极端情况，本章对于此暂不讨论。</p><h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><h4 id="经典伴随矩阵（-Classical-Adjoint-）"><a href="#经典伴随矩阵（-Classical-Adjoint-）" class="headerlink" title="经典伴随矩阵（$Classical\;Adjoint$）"></a>经典伴随矩阵（$Classical\;Adjoint$）</h4><p>本小节我们会使用基于经典伴随矩阵的方法，计算矩阵的逆。<br><strong>矩阵$\textbf{M}$的经典伴随矩阵，表示为“adj M”,被定义为$\textbf{M}$的余子式的矩阵的转置</strong></p><p>$adj M(3\times 3) = \begin{bmatrix}<br>    C^{11}&amp;C^{12}&amp;C^{13}\\<br>    C^{21}&amp;C^{22}&amp;C^{23}\\<br>    C^{31}&amp;C^{32}&amp;C^{33}<br>\end{bmatrix}^T$</p><p><strong>矩阵的逆等于经典伴随矩阵除以行列式</strong></p><p>$\textbf{M}^{-1} = \dfrac{adj\;M}{\begin{vmatrix}<br>    \textbf{M}<br>\end{vmatrix}}$</p><p>注：上式同时也证明了，矩阵行列式为0，则不可逆，其实这点从几何角度也可以做成解释，行列式为0，表示空间至少为压缩了一个维度。我们无法从低维度恢复到高纬度，因为不是1对1的关系。</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol><li>矩阵的逆矩阵的逆是原始矩阵：$(\textbf{M}^{-1})^{-1} = \textbf{M}$</li><li>矩阵转置的逆矩阵是矩阵逆的转置：$(\textbf{M}^T)^{-1} = (\textbf{M}^{-1})^T$</li><li>矩阵乘积的逆等于矩阵的逆的乘积：$(\textbf{AB})^{-1} = \textbf{B}^{-1}\textbf{A}^{-1}$</li><li>逆矩阵的行列式是原始矩阵行列式的倒数：$\begin{vmatrix}M^{-1}\end{vmatrix} = \dfrac{1}{\begin{bmatrix}M\end{bmatrix}}$</li></ol><h3 id="几何解释-1"><a href="#几何解释-1" class="headerlink" title="几何解释"></a>几何解释</h3><p>从几何的视角来看，逆矩阵通常代表了“反向”或“撤销”操作。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（九）：仿射变换和齐次坐标</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E5%92%8C%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E5%92%8C%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（九）：仿射变换和齐次坐标"><a href="#图形学的数学基础（九）：仿射变换和齐次坐标" class="headerlink" title="图形学的数学基础（九）：仿射变换和齐次坐标"></a>图形学的数学基础（九）：仿射变换和齐次坐标</h1><p>上一章中我们讨论了很多利用矩阵变换矢量的例子，在二维空间中这些变换具有以下形式：</p><p>$\mathbf{x^丶} = m_{11}\mathbf{x} + m_{12}\mathbf{y}$</p><p>$\mathbf{y^丶} = m_{21}\mathbf{x} + m_{22}\mathbf{y}$</p><p>这种形式的变换都满足矩阵中某个元素和x，y的线性组合，原点(0,0)在线性变换下始终保持不变，这种变换我们称为“<strong>线性变换</strong>”。无法通过这种方式实现平移。平移只能添加额外的表达式，无法在一个矩阵中完成。如下：</p><p>$\begin{bmatrix}<br>    x^丶\\ y^丶<br>\end{bmatrix}$ = $\begin{bmatrix}<br>    a&amp;b\\ c&amp;d<br>\end{bmatrix}$ $\begin{bmatrix}<br>    x\\ y<br>\end{bmatrix}$ + $\begin{bmatrix}<br>    t_x\\ t_y<br>\end{bmatrix}$</p><p>这种变换方式称为“<strong>仿射变换($Affine Transformations$)</strong>”。简而言之就是“线性变换” + “平移”。这种方式存在的问题就是写法过于繁琐，不简洁，无法在一个矩阵中完成。因此引入了“齐次坐标”的概念。</p><h2 id="齐次坐标（Homogenous-Coordinates）"><a href="#齐次坐标（Homogenous-Coordinates）" class="headerlink" title="齐次坐标（Homogenous Coordinates）"></a>齐次坐标（Homogenous Coordinates）</h2><p>没有办法通过$\begin{bmatrix}x\\ y\end{bmatrix}$乘以一个2 × 2的矩阵来实现平移。 一个在线性变换矩阵中加入平移的可能性方案是简单地将一个单独的平移矢量与每个变换矩阵相关联，让矩阵负责缩放和旋转而矢量负责平移。</p><p>这样就可以通过一次简单的矩阵乘法完成所有变换操作。方法是将点$\begin{bmatrix}x\\ y\end{bmatrix}$通过增加额外的维度（$\mathbf{w}$分量）$\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$来表达。矩阵增加额外的一列用于表示平移，这样平移分量就和x y的线性关系完全独立出来了。</p><p>$\begin{bmatrix}<br>    x^丶\\  y^丶\\ 1<br>\end{bmatrix}$ = $\begin{bmatrix}<br>    m_{11}&amp;m_{12}&amp;t_x\\ m_{21}&amp;m_{22}&amp;t_y\\ 0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$ = $\begin{bmatrix}<br>    m_{11}x + m_{12}y + t_x\\ m_{21}x + m_{22}y + t_y\\ 1<br>\end{bmatrix}$.</p><p>这个单一的矩阵实现了一个线性变换，然后是一个平移。这种变换叫做仿射变换，这种方法<br>通过添加额外维度实现仿射变换被称为齐次坐标（(Roberts, 1965; Riesenfeld, 1981; Penna &amp; Patterson,1986）。</p><p>当我们需要变换的是矢量时，表示方向或偏移量的矢量不应该改变，可以简单的将$\mathbf{w}$分量设置为0.  </p><p>$\begin{bmatrix}<br>    1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}x\\ y\\ 0\end{bmatrix} = \begin{bmatrix}x\\ y\\ 0\end{bmatrix}$.</p><p>因此齐次坐标对于矢量和点有不同的表达方式，矢量的$\mathbf{w}$分量为0，而点的$\mathbf{w}$分量为1.</p><ol><li><p>$vector$: $\begin{bmatrix}x\\ y\\ 0\end{bmatrix}$</p></li><li><p>$pointer$: $\begin{bmatrix}x\\ y\\ 1\end{bmatrix}$</p></li></ol><h3 id="齐次坐标的几何解释"><a href="#齐次坐标的几何解释" class="headerlink" title="齐次坐标的几何解释"></a>齐次坐标的几何解释</h3><p>接下来让我们从几何的视角观察齐次坐标所代表的含义。<br>当我们在三维空间中做基于$z$的切变时，我们会得到如下形式：</p><p>$\begin{bmatrix}1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\ y\\ z\end{bmatrix} = \begin{bmatrix}x+{t_x}z\\ y+{t_y}z\\ z\end{bmatrix}$.</p><p>这种形式和我们在二维空间中做平移变换非常相似。仅仅是z所代表的含义不同。关键点来了，让我们把z设为1.得到了二维平移仿射变换：</p><p>$\begin{bmatrix}1&amp;0&amp;t_x\\ 0&amp;1&amp;t_y\\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\ y\\ 1\end{bmatrix} = \begin{bmatrix}x+{t_x}\\ y+{t_y}\\ 1\end{bmatrix}$.</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E5%92%8C%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87/1.gif" alt="仿射变换于错切"></p><p><strong>结论：低维度的仿射变换(<script type="math/tex">Affine\;Transformations</script>)可以被认为是高纬度的错切变换($Shearing\;Transformations$)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（八）：矩阵线性变换</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（八）：矩阵线性变换"><a href="#图形学的数学基础（八）：矩阵线性变换" class="headerlink" title="图形学的数学基础（八）：矩阵线性变换"></a>图形学的数学基础（八）：矩阵线性变换</h1><p>我们可以通过添加一些值到它的坐标来平移一个点。 我们还可以利用三角函数来旋转矢量。 简而言之，<strong>矩阵只是将所有这些变换(缩放、旋转、反射、错切、平移)组合成一个单一结构的一种方式。</strong> 通过矩阵的方式我们可以方便的对空间中的点或矢量进行变换，而不用写一大堆的公式。这就是矩阵为何在图形渲染管线中存在重要意义的原因。<strong>图形中的任意变换都可以通过一个矩阵完成。</strong> 对同一个对象的多次变换可以通过矩阵乘积转换为单个矩阵。如下图：</p><p><em>注：本文所有推导和公式均使用列矢量形式。</em></p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/1.jpg" alt="alt"></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="缩放（Scale）"><a href="#缩放（Scale）" class="headerlink" title="缩放（Scale）"></a>缩放（Scale）</h3><h3 id="沿主轴缩放"><a href="#沿主轴缩放" class="headerlink" title="沿主轴缩放"></a>沿主轴缩放</h3><p>最简单的缩放是沿每个轴线应用单独的或者统一的缩放。</p><h4 id="均匀缩放"><a href="#均匀缩放" class="headerlink" title="均匀缩放"></a>均匀缩放</h4><p>保留原始对象的角度和比例， 使被缩放对象统一增大或者减少s因子。</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/2.jpg" alt="alt"></p><p>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}S&amp;0\\0&amp;S\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>同理三维空间中采用以下形式:</p><p>$\begin{bmatrix}x^丶\\y^丶\\z^丶\end{bmatrix} = \begin{bmatrix}S&amp;0&amp;0\\0&amp;S&amp;0\\0&amp;0&amp;S\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h4 id="非均匀缩放"><a href="#非均匀缩放" class="headerlink" title="非均匀缩放"></a>非均匀缩放</h4><p>如果希望”拉伸”或者”挤压”对象,则可以在不同方向上应用不同的缩放因子，这样会导致非均匀缩放。非均匀缩放不会保留原始对象的角度。</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/3.jpg" alt="alt"></p><p>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}S_x&amp;0\\0&amp;S_y\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>同理三维空间中采用以下形式:</p><p>$\begin{bmatrix}x^丶\\y^丶\\z^丶\end{bmatrix} = \begin{bmatrix}S_x&amp;0&amp;0\\0&amp;S_y&amp;0\\0&amp;0&amp;S_z\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h3 id="任意方向缩放"><a href="#任意方向缩放" class="headerlink" title="任意方向缩放"></a>任意方向缩放</h3><p>除了沿主轴线缩放外，还可以应用独立于坐标系的缩放，即沿任意方向的缩放。设$\hat{n}$缩放方向（缩放沿着$\hat{n}$执行），缩放因子s。以下将逐步实现沿任意方向缩放的方法。</p><p><strong>step1</strong>:  推导表达式，给定任意矢量$\mathbf{v}$，用$\mathbf{v},s,\hat{n}$计算$\mathbf{v^丶}$。基本思路是将矢量$\mathbf{v}$在$\hat{n}$上投影，分解为$\vec{v_∥}和\vec{v_⊥}$。其中$\vec{v_∥}$根据k因子缩放，$\vec{v_⊥}$保持不变。以下为推导过程：</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/4.png" alt="alt"><br>$\vec{v} = \vec{v_∥} + \vec{v_⊥}$</p><p>$\vec{v_∥} = (\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶_⊥} = \vec{v_⊥} = \vec{v} - \vec{v_∥} = \vec{v} - (\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶_∥} = s\vec{v_∥} = s(\vec{v}.\hat{n})\hat{n}$</p><p>$\vec{v^丶} = \vec{v^丶_⊥} + \vec{v^丶_∥} = \vec{v} - (\vec{v}.\hat{n})\hat{n} + s(\vec{v}.\hat{n})\hat{n} = \vec{v} + (s-1)(\vec{v}.\hat{n})\hat{n}$</p><p><strong>step2</strong>: 既然我们知道了如何缩放任意矢量，则可以计算出缩放后的基矢量值，将原始基矢量$x = \begin{bmatrix}1\\0\end{bmatrix},y = \begin{bmatrix}0\\1\end{bmatrix}$带入上式可得：</p><p>$\vec{x^丶} = \vec{x} + (s-1)(\vec{x}.\hat{n})\hat{n}\\\quad\quad= \begin{bmatrix}1\\0\end{bmatrix} + (s-1)(\begin{bmatrix}1\\0\end{bmatrix}.\begin{bmatrix}n_x\\n_y\end{bmatrix}).\begin{bmatrix}n_x\\n_y\end{bmatrix} \\\quad\quad= \begin{bmatrix}1\\0\end{bmatrix} + (s-1)n_x.\begin{bmatrix}n_x\\n_y\end{bmatrix}\\\quad\quad= \begin{bmatrix}1 + (s-1){n_x}^2\\ (s-1)n_xn_y\end{bmatrix}$</p><p>$\vec{y^丶} = \begin{bmatrix}(s-1)n_xn_y\\1 + (s-1)(n_y)^2\end{bmatrix}$</p><p>推导出二维和三维矢量空间沿任意方向$\hat{n}$缩放s的矩阵为：</p><p>$\textbf{Scale}^2(\hat{n},s) = \begin{bmatrix}1 + (s-1)(n_x)^2&amp;&amp;(s-1)n_xn_y\\  (s-1)n_xn_y&amp;&amp;1+(s-1){n_y}^2\end{bmatrix}$</p><p>$\textbf{Scale}^3(\hat{n},s) = \begin{bmatrix}1 + (s-1)(n_x)^2&amp;&amp;(s-1)n_xn_y&amp;&amp;(s-1)n_xn_z\\ (s-1)n_xn_y&amp;&amp;1+(s-1){n_y}^2&amp;&amp;(s-1)n_yn_z\\ (s-1)n_xn_z&amp;&amp;(s-1)n_yn_z&amp;&amp;1+(s-1){n_z}^2\end{bmatrix}$</p><h3 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h3><p><strong>反射其实是一种特殊的缩放，即按照某个轴线执行-1缩放。</strong></p><h4 id="沿主轴线的反射"><a href="#沿主轴线的反射" class="headerlink" title="沿主轴线的反射"></a>沿主轴线的反射</h4><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/5.png" alt="alt"><br>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}-1&amp;0\\0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><h4 id="沿任意轴反射"><a href="#沿任意轴反射" class="headerlink" title="沿任意轴反射"></a>沿任意轴反射</h4><p>根据沿任意轴缩放得到的矩阵公式，将-1带入，可得沿任意轴反射的矩阵公式：</p><p>$\textbf{Reflection}^2(\hat{n}) = \begin{bmatrix}1 + (-1-1)(n_x)^2&amp;&amp;(-1-1)n_xn_y\\ (-1-1)n_xn_y&amp;&amp;1+(-1-1){n_y}^2\end{bmatrix}$</p><p>$\textbf{Reflection}^3(\hat{n}) = \begin{bmatrix}1 + (-1-1)(n_x)^2&amp;&amp;(-1-1)n_xn_y&amp;&amp;(-1-1)n_xn_z\\ (-1-1)n_xn_y&amp;&amp;1+(-1-1){n_y}^2&amp;&amp;(-1-1)n_yn_z\\ (-1-1)n_xn_z&amp;&amp;(-1-1)n_yn_z&amp;&amp;1+(-1-1){n_z}^2\end{bmatrix}$</p><h3 id="错切（Shaearing）"><a href="#错切（Shaearing）" class="headerlink" title="错切（Shaearing）"></a>错切（Shaearing）</h3><p>错切是一种“倾斜”坐标空间的变形。它将不均匀的拉伸空间，不保留角度。但是保留面积和体积。基本思路是将一个坐标的倍数添加到另一个坐标上。<br><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/6.jpg" alt="alt"><br>$\begin{bmatrix}x^丶\\y^丶\end{bmatrix} = \begin{bmatrix}1&amp;a\\0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}$</p><p>二维错切矩阵公式：</p><p>$\textbf{H}_x(s) = \begin{bmatrix}1&amp;s\\0&amp;1\end{bmatrix}$ (沿x轴方向拉拽)</p><p>$\textbf{H}_y(s) = \begin{bmatrix}1&amp;0\\s&amp;1\end{bmatrix}$ (沿y轴方向拉拽)</p><p>三维错切矩阵公式：</p><p>$\textbf{H}_{xy}(s,t) = \begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\s&amp;t&amp;1\end{bmatrix}$</p><p>$\textbf{H}_{xz}(s,t) = \begin{bmatrix}1&amp;0&amp;0\\s&amp;1&amp;t\\s&amp;t&amp;1\end{bmatrix}$</p><p>$\textbf{H}_{yz}(s,t) = \begin{bmatrix}1&amp;s&amp;t\\0&amp;1&amp;0\\s&amp;t&amp;1\end{bmatrix}$</p><h3 id="旋转（Rotation）"><a href="#旋转（Rotation）" class="headerlink" title="旋转（Rotation）"></a>旋转（Rotation）</h3><h4 id="二维空间绕原点的旋转"><a href="#二维空间绕原点的旋转" class="headerlink" title="二维空间绕原点的旋转"></a>二维空间绕原点的旋转</h4><p>在二维空间中只能绕点旋转，本小节公式和实例将旋转点限定为坐标系原点（绕任意点的旋转需要先平移 再旋转 再平移回去，涉及到齐次坐标，暂不讨论）。<br>定义二维空间中旋转角度为$\theta$，根据三角函数的定义可知，基矢量$\vec{x},\vec{y}$绕原点旋转后得到$\vec{x^丶},\vec{y^丶}$如下图所示：</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/7.png" alt="alt"></p><p>$\textbf{R}(\theta) = \begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}$</p><h4 id="三维空间绕主轴线的旋转"><a href="#三维空间绕主轴线的旋转" class="headerlink" title="三维空间绕主轴线的旋转"></a>三维空间绕主轴线的旋转</h4><p>和二维不同，三种中旋转是绕某个轴线进行的。本小节将介绍围绕主轴线（$\mathbf{x}，\mathbf{y}，\mathbf{z}$）的旋转.<br>和缩放矩阵的推导类似，首先我们对三个基矢量进行变换,以围绕$\mathbf{x}$轴旋转为例：</p><p><strong>step1</strong>：对基矢量应用旋转变换：</p><p>$\mathbf{x^丶} =  \mathbf{x} = \begin{bmatrix}1\\0\\0\end{bmatrix}$</p><p>$\mathbf{y^丶} = \begin{bmatrix}0\\\cos\theta\\\sin\theta\end{bmatrix}$</p><p>$\mathbf{z^丶} = \begin{bmatrix}0\\ -\sin\theta\\\cos\theta\end{bmatrix}$</p><p><strong>step2</strong>:组合基矢量形成旋转矩阵：</p><p>$\textbf{R}_x(\theta) = \begin{bmatrix}1&amp;0&amp;0\\0&amp;\cos\theta&amp;-\sin\theta\\0&amp;\sin\theta&amp;\cos\theta\end{bmatrix}$</p><p>同理可推导出沿$\mathbf{y},\mathbf{z}$轴的旋转矩阵公式如下：</p><p>$\textbf{R}_y(\theta) = \begin{bmatrix}\cos\theta&amp;0&amp;\sin\theta\\0&amp;1&amp;0\\ -\sin\theta&amp;0&amp;\cos\theta\end{bmatrix}$</p><p>$\textbf{R}_z(\theta) = \begin{bmatrix}\cos\theta&amp;-\sin\theta&amp;0\\\sin\theta&amp;\cos\theta&amp;0\\0&amp;0&amp;1\end{bmatrix}$</p><h4 id="三维空间绕任意轴的旋转"><a href="#三维空间绕任意轴的旋转" class="headerlink" title="三维空间绕任意轴的旋转"></a>三维空间绕任意轴的旋转</h4><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/8.jpg" alt="alt"></p><p>让我们推导出一个围绕$\hat{n}$旋转$\theta$角度的矩阵$\textbf{R}(\hat{n},\theta)$,使得当矩阵$\textbf{R}(\hat{n},\theta)$乘以矢量$\mathbf{v}$得到的矢量$\mathbf{v^丶}$是将$\mathbf{v}$围绕$\hat{n}$旋转$\theta$角度的结果.</p><p>$\mathbf{v^丶} = \textbf{R}(\hat{n},\theta)\mathbf{v}$</p><p><strong>推导思路</strong></p><ol><li>为了得到矩阵$\textbf{R}(\hat{n},\theta)$,需要用$\mathbf{v}, \hat{n}, \theta$来表达$\mathbf{v^丶}$,基本思路是解决垂直于$\hat{n}$的平面中的问题,为此,将$\mathbf{v}$分解为$\mathbf{v_∥}和\mathbf{v_⊥}$两个矢量,分别平行和垂直于单位矢量$\hat{n}$.通过单独旋转每个分量,剋将矢量作为一个整体旋转.即: $\mathbf{v^丶} = \mathbf{v_∥^丶} + \mathbf{v_⊥^丶}$.</li><li>由于$\mathbf{v_∥}$与$\hat{n}$平行,因此它不受旋转影响.即: $\mathbf{v^丶_∥} = \mathbf{v_∥}$</li><li>根据矢量的投影计算可得: $\mathbf{v_∥} = (\mathbf{v}.\hat{n})\hat{n}$     $\mathbf{v_⊥} = \mathbf{v} - \mathbf{v_∥}$</li><li>利用矢量叉积构造$\mathbf{w}$: $\mathbf{w} = \hat{n}\times\mathbf{v_⊥} = \hat{n}\times\mathbf{v}$</li><li>注意上图所示,矢量$\mathbf{w}和\mathbf{v_⊥}$构成了一个二维空间.$\mathbf{v_⊥}$作为x轴,$\mathbf{w}$作为y轴.$\mathbf{v^丶_⊥}$是在这个平面上按角度$\theta$旋转$\mathbf{v_⊥}$的结果.</li></ol><p><strong>推导过程</strong></p><p>$\mathbf{v_∥} = (\mathbf{v}.\hat{n})\hat{n}$</p><p>$\mathbf{v_⊥} = \mathbf{v} - \mathbf{v_∥} = \mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}$</p><p>$\mathbf{w} = \hat{n}\times\mathbf{v_ ⊥} = \hat{n}\times\mathbf{v}$</p><p>$\mathbf{v^丶_⊥} = \cos\theta\mathbf{v_⊥} + \sin\theta\mathbf{w} = \cos\theta(\mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}) + \sin\theta(\hat{n}\times\mathbf{v})$</p><p>$\mathbf{v^丶} = \mathbf{v^丶_⊥} + \mathbf{v_∥} = \cos\theta(\mathbf{v} - (\mathbf{v}.\hat{n})\hat{n}) + \sin\theta(\hat{n}\times\mathbf{v}) + (\mathbf{v}.\hat{n})\hat{n}$</p><p>接下来,计算变换后的基矢量.简单的带入上式即可.</p><p>$\mathbf{x^丶} = \begin{bmatrix}{n_x}^2(1-\cos\theta) + \cos\theta\\{n_x}{n_y}(1-\cos\theta)+{n_z}\sin\theta\\{n_x}{n_z}(1-\cos\theta)-{n_y}\sin\theta\end{bmatrix}$</p><p>$\mathbf{y^丶} = \begin{bmatrix}{n_x}{n_y}(1-\cos\theta) - {n_z}\sin\theta\\{n_y}^2(1-\cos\theta)+\cos\theta\\{n_y}{n_z}(1-\cos\theta)+{n_x}\sin\theta\end{bmatrix}$</p><p>$\mathbf{z^丶} = \begin{bmatrix}{n_x}{n_z}(1-\cos\theta) + {n_y}\sin\theta\\{n_y}{n_z}(1-\cos\theta)-{n_x}\sin\theta\\{n_z}^2(1-\cos\theta)+\cos\theta\end{bmatrix}$</p><p>通过变换后基矢量的简单组合,即可构造出旋转矩阵</p><p>$\textbf{R}(\hat{n},\theta) = \begin{bmatrix}|&amp;|&amp;|\\ \mathbf{x^丶}&amp;\mathbf{y^丶}&amp;\mathbf{z^丶}\\ |&amp;|&amp;|\end{bmatrix} = \begin{bmatrix}{n_x}^2(1-\cos\theta) + \cos\theta&amp;{n_x}{n_y}(1-\cos\theta) - {n_z}\sin\theta&amp;{n_x}{n_z}(1-\cos\theta) + {n_y}\sin\theta\\{n_x}{n_y}(1-\cos\theta)+{n_z}\sin\theta&amp;{n_y}^2(1-\cos\theta)+\cos\theta&amp;{n_y}{n_z}(1-\cos\theta)-{n_x}\sin\theta\\{n_x}{n_z}(1-\cos\theta)-{n_y}\sin\theta&amp;{n_y}{n_z}(1-\cos\theta)+{n_x}\sin\theta&amp;{n_z}^2(1-\cos\theta)+\cos\theta\end{bmatrix}$.</p><p>至此绕任意轴的三维旋转矩阵推导完毕.</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=3&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p><p><a href="https://www.scratchapixel.com/">scratchapixel</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（七）：矩阵基础</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（七）：矩阵基础"><a href="#图形学的数学基础（七）：矩阵基础" class="headerlink" title="图形学的数学基础（七）：矩阵基础"></a>图形学的数学基础（七）：矩阵基础</h1><blockquote><p>不幸的是，没有人能够告诉我们矩阵是什么。你必须亲自去看看。<br>                                              -墨菲斯《黑客帝国》</p></blockquote><p>矩阵在3D数学中具有重要意义，它们主要用于描述两个坐标空间之间的关系，通过矩阵和矢量相乘，可以将矢量从某一坐标空间转换到另一个坐标空间。通过矩阵和矩阵相乘，可以描述一系列的变换动作。</p><h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>在线性代数中，矩阵是排列成行和列的矩形数字网格。矩阵可以定义为数字的二维数组。因此矢量是标量的数组，而矩阵是矢量的数组。</p><h3 id="矩阵维度和表示法"><a href="#矩阵维度和表示法" class="headerlink" title="矩阵维度和表示法"></a>矩阵维度和表示法</h3><p>通过计算矩阵包含的行数和列数来定义矩阵的大小，对于具有r行和c列的矩阵，称为 $r \times c$矩阵。<br>当希望引用矩阵中的各个元素时，将使用下标表示法。符号$m_{ij}$表示矩阵Mi行j列对应的元素。需要注意的是，矩阵其实索引为1.并不是0.</p><h3 id="方阵（Square-Matrice）"><a href="#方阵（Square-Matrice）" class="headerlink" title="方阵（Square Matrice）"></a>方阵（Square Matrice）</h3><p>具有相同行数和列数的矩阵称为方形矩阵，方阵的对角元素是行和列索引相同的元素。例如 $3\times3$矩阵M的对角元素是$m_{11},m_{22},m_{33}$。<br>如果矩阵中所有的非对角元素都为零，则该矩阵为对角矩阵（Diagonal Matrix）。</p><h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>有一类特殊的对角矩阵叫单位矩阵（Identity Matrix）。其对角线上的值为1，其它元素均为0.单位矩阵记作I.单位矩阵有一个重要的性质，即它是矩阵的乘法单位元素。如果将矩阵乘以单位矩阵，则得到原始矩阵。单位矩阵对于矩阵的意义，相当于标量中的数字1.</p><h3 id="作为矩阵的矢量"><a href="#作为矩阵的矢量" class="headerlink" title="作为矩阵的矢量"></a>作为矩阵的矢量</h3><p>矩阵可以包含任何正数的行和列，包括一个，维数$n$的矢量可以被视为$1\times n$矩阵，或者被视为$n\times 1$矩阵。$1\times n$矩阵称为行矢量（$Row Vector$），$n\times 1$矩阵被称为列矢量（$Column Vector$）</p><p>$1\times 3$矩阵 $\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}$</p><p>$3\times 1$矩阵 $\begin{bmatrix}x\\y\\z\end{bmatrix}$</p><h3 id="矩阵转置（Transpose）"><a href="#矩阵转置（Transpose）" class="headerlink" title="矩阵转置（Transpose）"></a>矩阵转置（Transpose）</h3><p>给定$r\times c$矩阵M的转置表示为$M^T$,是$c\times r$矩阵，其中列由M的行构成，即 $M^T_{ij} = M_{ji}$</p><p>$\begin{bmatrix}a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i\end{bmatrix}^T$ = $\begin{bmatrix}a&amp;d&amp;g\\b&amp;e&amp;h\\c&amp;f&amp;i\end{bmatrix}$</p><p>对于矢量，转置会将行矢量转换为列矢量，反之亦然。</p><h4 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h4><ul><li>对于任意矩阵转置的转置等于其自身：$(M^T)^T = M$</li><li>对于任意对角矩阵D，其转置等于自身：$D^T = D$</li></ul><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="矩阵与标量相乘"><a href="#矩阵与标量相乘" class="headerlink" title="矩阵与标量相乘"></a>矩阵与标量相乘</h3><p>矩阵M与标量k相乘，得到与M相同维度的矩阵。结果矩阵$k\textbf{M}$中的每个元素是$k$与$\textbf{M}$中相应元素的乘积。</p><p>$k\textbf{M} = k\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}km_{11}&amp;km_{12}&amp;km_{13}\\km_{21}&amp;km_{22}&amp;km_{23}\\km_{31}&amp;km_{32}&amp;km_{33}\end{bmatrix}$</p><h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><p>相较矩阵和标量乘法简单和宽松的定义，矩阵之间相乘是有一定条件的，只有满足特定条件的矩阵才可以相乘。具体规则如下：设矩阵$\textbf{A}为r \times m$, 矩阵$\textbf{B}为 n \times c$矩阵，只有当$m == n$时，$\textbf{A} \times \textbf{B}$才有意义。即第一个矩阵的列数等于第二个矩阵的行数，得到的结果为 $\textbf{C}为 r \times c$矩阵。</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/1.jpg" alt="alt"></p><p>$\textbf{C}$中每个元素$\textbf{C}_{ij}$等于$\textbf{A} $的第i行与 $\textbf{B}$的第j列点乘的结果。</p><p>$\textbf{C}_{ij} = \sum\limits_{k=1}^{n} a_{ik}b_{kj}$</p><h4 id="矩阵相乘性质"><a href="#矩阵相乘性质" class="headerlink" title="矩阵相乘性质"></a>矩阵相乘性质</h4><ul><li>任何矩阵和单位矩阵相乘等于自身：$\textbf{MI} = \textbf{IM} = \textbf{M}$ </li><li>矩阵乘法是不可交换的：$\textbf{AB} ≠ \textbf{BA}$</li><li>矩阵乘法是可结合的：$\textbf{ABC} = \textbf{A(BC)}$</li><li>两个矩阵乘积的转置两个矩阵分别转置以相反的顺序乘积：$(\textbf{AB})^T$ = $\textbf{B}^T\textbf{A}^T$</li></ul><h3 id="矢量矩阵相乘"><a href="#矢量矩阵相乘" class="headerlink" title="矢量矩阵相乘"></a>矢量矩阵相乘</h3><p>由于矢量可以被认为具有一行（$Row Vector$）或者一列（$Column Vector$）的矩阵，因此可以应用上一小节矩阵相乘的规则将矢量和矩阵相乘。</p><p><strong>当矢量为行矢量（$1 \times n$）时，可以与矩阵（$n \times m$）相乘，结果为$1 \times m$行矢量。行矢量与矩阵相乘时，矢量位于左侧，矩阵位于右侧。</strong></p><p>$\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix} = \begin{bmatrix}xm_{11} + ym_{21} + zm_{31}&amp;xm_{12} + ym_{22} + zm_{32}&amp;xm_{13} + ym_{23} + zm_{33}\end{bmatrix}$</p><p><strong>当矢量为列矢量（$n \times 1$）时，可以与矩阵（$m \times n$）相乘，结果为$m \times 1$列矢量。列矢量与矩阵相乘时，矢量位于右侧，矩阵位于左侧。</strong></p><p>$\begin{bmatrix}m_{11}&amp;m_{12}&amp;m_{13}\\m_{21}&amp;m_{22}&amp;m_{23}\\m_{31}&amp;m_{32}&amp;m_{33}\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix} = \begin{bmatrix}xm_{11} + ym_{12} + zm_{13}\\xm_{21} + ym_{22} + zm_{23}\\xm_{31} + ym_{32} + zm_{33}\end{bmatrix}$</p><ol><li>结果矢量中每个元素是原始矢量与矩阵中的单个行或者列的点积。</li><li>矩阵中的每个元素确定输入矢量中特定元素对输出矢量的元素有多大的“权重”。</li><li>乘法的结果是矩阵的行或列的线性组合。</li></ol><h3 id="行与列矢量"><a href="#行与列矢量" class="headerlink" title="行与列矢量"></a>行与列矢量</h3><p>当对行矢量应用多个变换时，可以从左到右依次对矢量进行矩阵乘法。例如对矢量$\vec{v}$应用变换$\textbf{A},\textbf{B},\textbf{C}$时，表示为：$\vec{v}\textbf{ABC}$.<br>同理如果对列矢量应用相同的变换。则相应的乘法被写为：$\textbf{C}^T\textbf{B}^T\textbf{A}^T\vec{v}$.</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（六）：施密特正交化与叉乘正交化</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%E4%B8%8E%E5%8F%89%E4%B9%98%E6%AD%A3%E4%BA%A4%E5%8C%96/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%E4%B8%8E%E5%8F%89%E4%B9%98%E6%AD%A3%E4%BA%A4%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（六）：施密特正交化-Schmidt-orthogonalization-与叉乘正交化"><a href="#图形学的数学基础（六）：施密特正交化-Schmidt-orthogonalization-与叉乘正交化" class="headerlink" title="图形学的数学基础（六）：施密特正交化(Schmidt orthogonalization)与叉乘正交化"></a>图形学的数学基础（六）：施密特正交化(Schmidt orthogonalization)与叉乘正交化</h1><h2 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h2><p>在很多情况下，例如在计算相机的lookAt矩阵中，由于传入的$\mathbf{direction}$ $\mathbf{up}$ $\mathbf{right}$三个基矢量不一定是规范化的，需要对三个矢量进行正交化处理，这样才能组成标准正交基。<br>本文将介绍两种常见的矢量正交化方法。施密特正交化和矢量叉积。</p><h2 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h2><p>施密特正交化是求欧式空间正交基的一种方法。从欧式空间任意线性无关的向量组$\mathbf{\alpha_1},\mathbf{\alpha_2},…,\mathbf{\alpha_m}$出发，求得正交向量组 $\mathbf{\beta_1},\mathbf{\beta_2},…,\mathbf{\beta_m}$,再将正交向量组中每个向量归一化，得到一个标准正交向量组，这种方法称为施密特正交化。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>如果$\vec{x_1},\vec{x_2},…\vec{x_n}$是某向量空间的基，那么可以通过以下公式找到该向量空间中的n个两两正交的向量$\vec{v_1},\vec{v_2},…\vec{v_n}$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%E4%B8%8E%E5%8F%89%E4%B9%98%E6%AD%A3%E4%BA%A4%E5%8C%96/1.jpg" alt="alt"><br>配图来源：《马同学图解数学-如何理解施密特正交化？》</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>施密特正交化主要利用了矢量点积的投影性质，可以将矢量分解为平行和垂直两个矢量。以下我们分别以二维向量空间和三维向量空间为例详细介绍施密特正交化的推导过程。</p><h4 id="二维向量空间的推导"><a href="#二维向量空间的推导" class="headerlink" title="二维向量空间的推导"></a>二维向量空间的推导</h4><ol><li>假设二维空间的任意向量$\vec{x_1}$ $\vec{x_2}$</li></ol><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%E4%B8%8E%E5%8F%89%E4%B9%98%E6%AD%A3%E4%BA%A4%E5%8C%96/2.png" alt="alt"></p><ol><li>任选其一作为$\vec{v_1}$,比如$\vec{x_1}$.利用向量点积，将$\vec{x_2}$在$\vec{v_1}$上投影。得到$\vec{x_⊥}$，根据向量的三角形法则，$\vec{x_∥} = \vec{x_2} - \vec{x_⊥}$即为要求的$\vec{v_2}$</li></ol><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96%E4%B8%8E%E5%8F%89%E4%B9%98%E6%AD%A3%E4%BA%A4%E5%8C%96/3.jpg" alt="alt"></p><p>$\vec{v_1} = \vec{x_1}$</p><p>$\vec{x_⊥} = \dfrac{\vec{x_2}.\vec{v_1}}{||\vec{v_1}||} \hat{v_1} = \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}} \hat{v_1}||\vec{v_1}|| = \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}$</p><p>$\vec{v_2} = \vec{v_∥} = \vec{x_2} - \vec{x_⊥} = \vec{x_2} - \dfrac{\vec{x_2}.\vec{v_1}}{\vec{v_1}.\vec{v_1}}\vec{v_1}$</p><p>$\hat{v_1} = \dfrac{\vec{v_1}}{||\vec{v_1}||}$</p><p>$\hat{v_2} = \dfrac{\vec{v_2}}{||\vec{v_2}||}$</p><h4 id="三维向量空间的推导"><a href="#三维向量空间的推导" class="headerlink" title="三维向量空间的推导"></a>三维向量空间的推导</h4><p>三维向量空间的正交化推导与二维空间类似，假设三维空间的任意向量 $\vec{x_1}$ $\vec{x_2}$ $\vec{x_3}$.<br>先任选两个向量做二维空间的正交化，例如$\vec{x_1}$ $\vec{x_2}$,得到$\hat{v_1}$,$\hat{v_2}$.<br>将 $\vec{x_3}$在$\hat{v_1}$,$\hat{v_2}$所张成的二维平面上投影，得到$\vec{x_3⊥}$，由于$\vec{x_3⊥}$在$\hat{v_1}$,$\hat{v_2}$的张成平面上，所以$\vec{x_3⊥}$是$\hat{v_1}$,$\hat{v_2}$的线性组合。</p><p>$\vec{x_3⊥} = k_1\hat{v_1} + k_2\hat{v_2}$</p><p>$\vec{v_3} = \vec{x_3} - \vec{x_3⊥}$</p><p>$\vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2}$</p><p>由于$\vec{v_3}$垂直于$\hat{v_1}$和${\hat{v_2}}$, $\hat{v_1}$,${\hat{v_2}}$正交，因此：</p><p>$ \vec{v_3}.\hat{v_1} = 0$</p><p>$\vec{v_3}.\hat{v_2} = 0$</p><p>$\hat{v_2}.\hat{v_1} = 0$</p><p>由此可以推导出：</p><p>$\vec{v_3}.\hat{v_1} = (\vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2}).\hat{v_1} = 0$</p><p>$\vec{x_3}.\hat{v_1} - k_1\hat{v_1}.\hat{v_1} - k_2\hat{v_2}.\hat{v_1} = 0 $</p><p>$\vec{x_3}.\hat{v_1} - k_1\hat{v_1}.\hat{v_1} = 0 $</p><p>$k_1 = \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}$</p><p>同理可得出： $k_2 = \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}$</p><p>$\vec{v_3} = \vec{x_3} - k_1\hat{v_1} - k_2\hat{v_2} = \vec{x_3} - \dfrac{\vec{x_3}.\hat{v_1}}{\hat{v_1}.\hat{v_1}}\hat{v_1} - \dfrac{\vec{x_3}.\hat{v_2}}{\hat{v_2}.\hat{v_2}}\hat{v_2}$</p><h2 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h2><p>假设三维空间中的三个向量$\vec{x_1}$ $\vec{x_2}$ $\vec{x_3}$.下边我们使用向量叉乘的方法对对其正交化。</p><ul><li><p>任选其一作为$\vec{v_1}$,例如$\vec{x_1}$ </p><p>  $\vec{v_1} = \vec{x_1}$</p></li><li><p>任选另外两个向量其一和$\vec{v_1}$叉乘例如$\vec{v_1} \times \vec{x_2}$ 得到$\vec{v_3}$</p><p>   $\vec{v_3} = \vec{v_1} \times \vec{x_2}$</p></li><li><p>用$\vec{v_3}和\vec{v_1}$叉乘得到$\vec{v_2}$</p><p>  $\vec{v_2} = \vec{v_3} \times \vec{x_1}$</p></li><li><p>$\hat{v_1} = \dfrac{\vec{v_1}}{||\vec{v_1}||}$  $\hat{v_2} = \dfrac{\vec{v_2}}{||\vec{v_2}||}$  $\hat{v_3} = \dfrac{\vec{v_3}}{||\vec{v_3}||}$</p></li></ul><p>至此通过以上几个步骤，完成了矢量的正交化。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/485838766">如何理解施密特正交化</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（五）：标准正交基/坐标系</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（五）：标准正交基-坐标系"><a href="#图形学的数学基础（五）：标准正交基-坐标系" class="headerlink" title="图形学的数学基础（五）：标准正交基/坐标系"></a>图形学的数学基础（五）：标准正交基/坐标系</h1><h2 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h2><p>对于三维空间任意的三个矢量,如果它们满足</p><ul><li>$||\vec{u}|| = ||\vec{v}|| = ||\vec{w}|| = 1$</li><li>$\vec{u}.\vec{v} = \vec{v}.\vec{w} = \vec{u}.\vec{w} = 0$</li><li>$\vec{w} = \vec{u} \times \vec{v}$ (右手系)</li></ul><p>即矢量的长度都为1,相互垂直, 这样的三个矢量构成的坐标系称为<strong>标准正交基</strong>,$\vec{u} ,\vec{v},\vec{w}$称为标准正交基的<strong>基矢量</strong>.</p><h2 id="为什么需要标准正交基"><a href="#为什么需要标准正交基" class="headerlink" title="为什么需要标准正交基"></a>为什么需要标准正交基</h2><p>定义这样的坐标系,带来的一点好处就是, 空间中任意一矢量,都可以分解到标准正交基的三个轴上,需要用到前边向量投影的相关知识. 即<strong>矢量可以表示为基矢量的线性组合</strong>.<br><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/1.jpg" alt="alt"></p><p>$||\vec{b_⊥}|| = ||\vec{b}|| \cos\theta$</p><p>此时的$\vec{a}$为单位向量,即$||\vec{a}|| = 1$</p><p>因此 $||\vec{b_⊥}|| = ||\vec{b}||||\vec{a}|| \cos\theta = \mathbf{b}.\mathbf{a}$</p><p>重要结论:</p><p>$\vec{p} = (\vec{p}.\vec{u})\vec{u} + (\vec{p}.\vec{v})\vec{v} + (\vec{p}.\vec{w})\vec{w}$</p><p>$x = \vec{p}.\vec{u}$ </p><p>$y = \vec{p}.\vec{v}$</p><p>$z = \vec{p}.\vec{w}$</p><p><strong>将三维矢量表示为基矢量的线性组合</strong></p><p>$\vec{p} = x\vec{u} + y\vec{v} + z\vec{w}$</p><h2 id="多个坐标空间"><a href="#多个坐标空间" class="headerlink" title="多个坐标空间"></a>多个坐标空间</h2><p>在图形学中,我们经常发现需要使用多个坐标空间,例如世界空间, 对象空间, 相机空间等等,为什么需要很繁琐地定义多个坐标空间?毕竟坐标系可以无限延伸,可以表达我们想要的任何信息.原因就在于,某些信息仅在特定的上下文环境(坐标系)中才是有意义的或者说可以用的.这样做,可以为开发提供很多便利.</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>世界坐标系(World Coordinate System)是一个特殊的坐标系,它为所有其它要指定的坐标系建立了一个”全局”参考系.换句话说,我们可以用世界坐标空间来表达其它坐标空间的位置,但是我们不能用更待的外部坐标空间来表示世界坐标空间.<br><strong>非技术意义上, 世界坐标系建立了我们关心的”最大”坐标系,大多数情况下,它实际上并不是整个世界,而是由我们定义的.</strong></p><h3 id="对象空间"><a href="#对象空间" class="headerlink" title="对象空间"></a>对象空间</h3><p>对象空间(Object Space)是与特定对象关联的坐标空间,每个对象都有自己独立的对象空间.当一个对象移动或者改变方向,与该对象关联的对象坐标空间被随之携带.因此它也会移动或改变方向.<br>在图形学中,对象空间也被称为模型空间, 因为模型顶点的坐标以模型空间表示.</p><h3 id="相机空间"><a href="#相机空间" class="headerlink" title="相机空间"></a>相机空间</h3><p>相机空间中, 相机位于原点, +x指向右侧, +z指向前方(指向屏幕),+y指向”向上”(此处按照左手系约定),如果右手系,则-z指向屏幕方向.</p><h3 id="直立空间"><a href="#直立空间" class="headerlink" title="直立空间"></a>直立空间</h3><p>对象的直立空间是是世界空间与其对象空间之间的”过渡”,因为直立空间的轴线与世界空间的轴线平行,而直立空间的原点则于与对象空间的原点重合.</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA-%E5%9D%90%E6%A0%87%E7%B3%BB/2.png" alt="alt"></p><p>图片来源《3D Math Primer for Graphics and Game Development, 2nd Edition》</p><p><strong>因此通过旋转可以实现直立空间和对象空间的转换,通过平移可以实现世界空间和直立空间的转换(lookAt矩阵)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（四）：向量叉积</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（四）：向量叉积（Cross-Product）"><a href="#图形学的数学基础（四）：向量叉积（Cross-Product）" class="headerlink" title="图形学的数学基础（四）：向量叉积（Cross Product）"></a>图形学的数学基础（四）：向量叉积（Cross Product）</h1><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积是另一种向量乘积，与上节讲到的点积不同，叉积的结果是一个向量，该向量垂直于原始的两个向量，即垂直于原始两个向量所构成的平面。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/1.jpg" alt="alt"></p><ul><li><p>$\mathbf{a} \times \mathbf{b}$将产生一个垂直于$\mathbf{a}$和$\mathbf{b}$所构成平面的向量，这样的向量可能有两个，彼此方向相反，朝向由右手螺旋定则判定，具体在后文会详细介绍。</p></li><li><p><strong>$\mathbf{a} \times \mathbf{b}$的长度等于$\mathbf{a}$和$\mathbf{b}$长度的乘积再乘以$\mathbf{a}$和$\mathbf{b}$之间角度的正弦值。</strong></p><p>  $||\mathbf{a} \times \mathbf{b}|| = ||\mathbf{a}|||| \mathbf{b} || \sin\theta$</p></li></ul><p>实际上根据定义不难理解， $\mathbf{a} \times \mathbf{b}$的长度等于由两个边$\mathbf{a}$ $\mathbf{b}$所形成的平行四边形的面积。</p><p>$\textbf{A} =  bh = b(a\sin\theta) = ||\mathbf{a}||||\mathbf{b}||\sin\theta = ||\mathbf{a} \times \mathbf{b}||$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/2.jpg" alt="alt"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>叉积交换的，实际上，它是反交换的（anticommutative）的：$\mathbf{a} \times \mathbf{b} = - (\mathbf{b} \times \mathbf{a})$</li><li>向量自身的叉积等于零向量 $ \mathbf{a} \times \mathbf{a} = \vec{0} $</li><li>叉积满足分配律：$ \mathbf{a} \times(\mathbf{b} + \mathbf{c}) = \mathbf{a} \times \mathbf{b} + \mathbf{a} \times \mathbf{c} $</li><li>叉积满足结合律：$ \mathbf{a} \times (k\mathbf{b}) = k(\mathbf{a} \times \mathbf{b})$</li></ul><h2 id="右手螺旋定则"><a href="#右手螺旋定则" class="headerlink" title="右手螺旋定则"></a>右手螺旋定则</h2><p>先将两向量移动到同一起点，右手四指从A转动到B，则拇指所指方向，即为结果向量的方向。<br>符合右手螺旋定则的坐标系称之为右手坐标系，即 $\vec{x} \times \vec{y} = \vec{z}$,否则为左手系。<br><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/3.jpg" alt="alt"></p><p>$\vec{x} \times \vec{y} = +\vec{z}$</p><p>$\vec{y} \times \vec{x} = -\vec{z}$</p><p>$\vec{y} \times \vec{z} = +\vec{x}$</p><p>$\vec{z} \times \vec{y} = -\vec{x}$</p><p>$\vec{z} \times \vec{x} = +\vec{y}$</p><p>$\vec{x} \times \vec{z} = -\vec{y}$</p><h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><h3 id="判定两向量的相对位置关系"><a href="#判定两向量的相对位置关系" class="headerlink" title="判定两向量的相对位置关系"></a>判定两向量的相对位置关系</h3><p>向量叉积可以用于判定两个向量的相对位置关系，比如如果我们想知道一个向量在另外一个的左侧还是右侧，可以通过两个向量叉积结果的符号来判断。</p><p>$\mathbf{a} \times \mathbf{b}  = + \mathbf{z}$<br>因此$\mathbf{b}在\mathbf{a}的左侧$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/4.jpg" alt="alt"></p><h3 id="判定点是否在三角形内"><a href="#判定点是否在三角形内" class="headerlink" title="判定点是否在三角形内"></a>判定点是否在三角形内</h3><p>分别使用三角形的三边向量 $\vec{AB}$ $\vec{BC}$ $\vec{CA}$，叉乘三角形每个顶点与P点构成的向量，如果得到的三个结果向量方向一致，则认为P点在三角形 $\triangle{ABC}$内,否则P点在三角形外。</p><p>$\vec{AB} \times \vec{AP}$</p><p>$\vec{BC} \times \vec{BP}$</p><p>$\vec{CA} \times \vec{CP}$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%8F%89%E7%A7%AF/5.png" alt="alt"></p><h3 id="构造三维直角坐标系"><a href="#构造三维直角坐标系" class="headerlink" title="构造三维直角坐标系"></a>构造三维直角坐标系</h3><p>$\vec{x} \times \vec{y} = \vec{z}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（三）：向量点积</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（三）：向量点积"><a href="#图形学的数学基础（三）：向量点积" class="headerlink" title="图形学的数学基础（三）：向量点积"></a>图形学的数学基础（三）：向量点积</h1><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积($Dot Product$)是向量乘法中比较简单的一种(另外一种叫做叉乘),但是点积在图形学中应用非常广泛,与许多其它运算有重要的关系,例如矩阵乘法、信号卷积、统计相关、和傅里叶变换等。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>向量点积等于两个向量的长度相乘再乘以两向量夹角的余弦.</strong></p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/1.jpg" alt="alt"></p><p>$\mathbf{a}\cdot\mathbf{b} = ||\mathbf{a}|| ||\mathbf{b}||\cos{\theta}$</p><p>推导:</p><p>$\cos\theta = \dfrac{\mathbf{a}\cdot\mathbf{b}}{||\mathbf{a}|| ||\mathbf{b}||}$</p><p>对于单位向量来说<br>$\cos\theta = \mathbf{a}\cdot\mathbf{b}$</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p><strong>两个向量的点积是相应分量的乘积之和，得到的结果是一个标量</strong>，因此也叫做标量乘法(Scalar Product)。</p><p>$\mathbf{a}.\mathbf{b} = \sum\limits_{i=1}^na_ib_i$</p><p>二维和三维向量点积</p><p>$\mathbf{a}.\mathbf{b} = a_xb_x + a_yb_y$</p><p>$\mathbf{a}.\mathbf{b} = a_xb_x + a_yb_y + a_zb_z$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>交换律</p><p>  $\mathbf{a}.\mathbf{b} = \mathbf{b}.\mathbf{a}$</p></li><li><p>结合律</p><p>  $(k\mathbf{a}).\mathbf{b} = \mathbf{a}.(k\mathbf{b}) = k(\mathbf{a}.\mathbf{b})$</p></li></ul><ul><li><p>分配律</p><p>   $\mathbf{a}.(\mathbf{b} + \mathbf{c}) = \mathbf{a}.\mathbf{b} + \mathbf{a}.\mathbf{c}$</p></li></ul><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>向量点积的几何意义对于我们来说至关重要,因为涉及到图形学的方方面面,以下我们将从两个方面进行探讨.</p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p><strong>点积$\mathbf{a}.\mathbf{b}$等于$\mathbf{b}$投影到平行于$\mathbf{a}$的直线上的有符号号长度,乘以$\mathbf{a}$的长度.</strong><br>如何理解这句话呢?根据点积的定义及直角三角形余弦定理我们得知</p><p>$\mathbf{a}.\mathbf{b} = ||\mathbf{a}|| ||\mathbf{b}||\cos\theta$</p><p>-&gt;</p><p>$||\mathbf{b_⊥}|| = \cos\theta ||\mathbf{b}||$</p><p>-&gt;</p><p>$\mathbf{b_⊥} = ||\mathbf{b_⊥}||\hat{a} = \cos\theta||\mathbf{b}||\hat{a}$</p><p>-&gt;</p><p>$\mathbf{a}\cdot\mathbf{b} = ||\mathbf{a}||||\mathbf{b}|| \cos\theta = ||\mathbf{b_⊥}|| ||  \mathbf{a}||$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/2.jpg" alt="alt"></p><h4 id="分解向量"><a href="#分解向量" class="headerlink" title="分解向量"></a>分解向量</h4><p>根据上小节向量投影的介绍我们能够得到$\mathbf{b}$向量在$\mathbf{a}$向量上的投影向量,因此我们可以将$\mathbf{b}$向量进行分解,其中一条沿着$\mathbf{a}$方向即$\mathbf{b_⊥}$,另外一条垂直于$\mathbf{a}$向量,即$\mathbf{b_∥}$,如下图所示</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/3.jpg" alt="alt"></p><p>$\mathbf{b_⊥} = ||\mathbf{b_⊥}|| \hat{a} = \cos\theta ||\mathbf{b}|| \hat{a}$</p><p>$\mathbf{b_∥} = \mathbf{b} - \mathbf{b_⊥}$</p><h4 id="向量大小于点积的关系"><a href="#向量大小于点积的关系" class="headerlink" title="向量大小于点积的关系"></a>向量大小于点积的关系</h4><p>$\mathbf{v}.\mathbf{v} = ||\mathbf{v}||^2$</p><h4 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h4><ol><li><strong>点积的符号可以给予我们对两个向量相对方向的粗略分类</strong></li></ol><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF/4.jpg" alt="alt"></p><ol><li><p>两个单位向量的点积等于夹角的余弦.</p><p> $\hat{a}\cdot\hat{b} = \cos\theta$</p></li><li><p>使用点积计算两个向量之间的角度</p><p> $\theta = \arccos(\dfrac{\mathbf{a}\cdot\mathbf{b}}{||\mathbf{a}||||\mathbf{b}||})$</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://item.jd.com/12659881.html">《3D数学基础》图形和游戏开发(第二版)</a></p><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&amp;vd_source=b3b87210888ec87be647603921054a36">GAMES101 -现代计算机图形学入门-闫令琪</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（二）：向量运算</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（二）：向量运算"><a href="#图形学的数学基础（二）：向量运算" class="headerlink" title="图形学的数学基础（二）：向量运算"></a>图形学的数学基础（二）：向量运算</h1><h2 id="标量和向量的乘法"><a href="#标量和向量的乘法" class="headerlink" title="标量和向量的乘法"></a>标量和向量的乘法</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>标量与向量的乘法，只需要用标量乘以矢量的每个分量即可。</p><p>$k\begin{bmatrix}x\\ y\\ z\end{bmatrix} = \begin{bmatrix}x\\ y\\ z\end{bmatrix}k = \begin{bmatrix}kx\\ ky\\ kz\end{bmatrix}$</p><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>将向量乘以标量k具有将向量的长度按照因数|k|缩放的效果.例如为了使向量长度加倍,可以将向量乘以2;如果k &lt; 0,则翻转向量的方向.</p><h2 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>两个向量相加等于它们相应的分量相加得到的向量.向量不能和标量相加或者相减, 也不能和不同维度的向量进行加减运算.向量的减法可以理解为加一个负向量.</p><h3 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h3><p>我们可以按照几何形式将向量相加,方法是定位向量使得各向量的头尾相连, 然后绘制一条从第一条向量尾部到最后一条向量头部的向量,即为相加的结果向量.如下图:</p><p>$\vec{e} = \vec{a} + \vec{b} + \vec{c} + \vec{d}$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/1.jpg" alt="alt"></p><h2 id="向量大小"><a href="#向量大小" class="headerlink" title="向量大小"></a>向量大小</h2><p>向量的大小也成为向量的长度(Length)或范数(Norm),在数学中通常使用围绕向量的双垂直直线来表示.$||\mathbf{v}||$</p><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h3><p><strong>向量的大小是向量分量的平方和的平方根.</strong></p><p>$||\mathbf{v}|| = \sqrt{\sum\limits_{i=1}^n{v_i}^2}$</p><h3 id="几何意义-2"><a href="#几何意义-2" class="headerlink" title="几何意义"></a>几何意义</h3><p>以二维向量为例, 任何向量v(除去0向量)可以形成一个直角三角形,其中v作为斜边,v向量的两个分量作为直角边.根据毕达哥拉斯定理,对于任何直角三角形,斜边的长度的平方等于另外两边长度的平方和.</p><p>$||\mathbf{v}|| = \sqrt{ {v_x}^2 + {v_y}^2}$</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/2.jpg" alt="alt"></p><h2 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h2><p>对于许多向量,我们只关心其方向性,使用单位向量通常会很方便(点乘),单位向量是大小(Norm)为1的向量,单位向量也被称为归一化的向量($Normalized Vector$).</p><h3 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h3><p>对于任何非零向量,可以计算出指向v相同方向的单位向量,此过程称为向量的归一化(normalize).为了归一化向量,可以将向量除以其大小:</p><p>${v_i} = \dfrac{\mathbf{v}}{||\mathbf{v}||}$</p><h3 id="几何意义-3"><a href="#几何意义-3" class="headerlink" title="几何意义"></a>几何意义</h3><p>以二维向量为例,将单位向量尾部固定在原点,则向量头部将接触到以原点为中心的单位圆(半径为1).三维中,单位向量接触到的是单位球面(半径为1).</p><h2 id="两点距离"><a href="#两点距离" class="headerlink" title="两点距离"></a>两点距离</h2><p>两点之间的距离本质上是求从一点到另外一点向量的长度,根据向量的三角形法则.可以得到:</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/3.jpg" alt="alt"></p><p>$\mathbf{d} = \mathbf{b} - \mathbf{a}$</p><p>$\mathbf{d} = \begin{bmatrix}b_x - a_x\\b_y - a_y\end{bmatrix}$</p><p>$\textbf{distance}(\mathbf{a},\mathbf{b}) = ||\mathbf{d}|| = \sqrt{ {d_x}^2 + {d_y}^2 }$</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的数学基础（一）：向量基础</title>
      <link href="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="图形学的数学基础（一）：向量"><a href="#图形学的数学基础（一）：向量" class="headerlink" title="图形学的数学基础（一）：向量"></a>图形学的数学基础（一）：向量</h1><h2 id="前边的话"><a href="#前边的话" class="headerlink" title="前边的话"></a>前边的话</h2><p>本系列是阅读《3D数学基础： 图形和游戏开发（第二版）》整理汇总的学习笔记，整个系列的结构排布基于原书的章节安排，针对其中的每个知识点做了适当的补充和拓展，其中不免有遗漏和错误之处，望各位读者批评指正。本篇文章做为该系列的第一章，主要介绍向量相关内容，涉及空间中向量的几何意义，各种运算，重点介绍点乘和叉乘的几何解释及在图形学中的应用场景。</p><h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>对于数学家来说向量是一个数组，数组的长度代表向量所在的空间维度。程序中表示向量通常有两种方式，行向量（$Row Vector$）和列向量（$Column Vector$）,至于为什么要区分两种书写方式,我们放到矩阵章节再详细说明.</p><p>$V_{column} = \begin{bmatrix}1\\ 2\\ 3\end{bmatrix}$</p><p>$V_{row} = \begin{bmatrix}1&amp;2&amp;-1\end{bmatrix}$</p><h2 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h2><p>从几何学上讲,向量是具有大小和方向的<strong>有向线段</strong>.讨论向量在空间中的哪个位置,是没有意义的,<strong>向量不具备位置属性</strong>.向量是一种相对偏移量的表示方法.如下图二维笛卡尔坐标系中,向量U和V是相等的.</p><ul><li>大小: 矢量的长度,矢量可以具有任何非负长度.</li><li>方向:空间中指定的方向.</li></ul><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80/1.jpg" alt="alt"></p><h2 id="笛卡尔坐标系下的向量"><a href="#笛卡尔坐标系下的向量" class="headerlink" title="笛卡尔坐标系下的向量"></a>笛卡尔坐标系下的向量</h2><p>当使用笛卡尔坐标来描述向量时,每个坐标将度量相应维度中有符号位移.</p><p><img src="/2022/08/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80/2.jpg" alt="alt"></p><h2 id="向量与点的关系"><a href="#向量与点的关系" class="headerlink" title="向量与点的关系"></a>向量与点的关系</h2><p>点用于描述空间中的某一位置.向量用于描述空间中的一段位移,表达相对位置.那么点与向量之间有着怎样的关系呢?两者之间如何完成相互转换?其实很简单,本质上就一句话,<strong>任何点都可以表示为来自原点的向量</strong>.从原点开始按照向量[x,y]指定的量移动,最终会抵达点(x,y)所描述的位置, 同理向量[x,y]给出了从原点到点(x,y)的位移.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
          <category> 计算机图形学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反函数和反三角函数</title>
      <link href="/2022/04/03/%E5%8F%8D%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/03/%E5%8F%8D%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数函数和对数函数</title>
      <link href="/2022/04/03/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/03/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="指数法则"><a href="#指数法则" class="headerlink" title="指数法则"></a>指数法则</h2><blockquote><ol><li><p>$b^0=1$</p></li><li><p>$b^1=b$</p></li><li><p>$b^xb^y=b^{x+y}$</p></li><li><p>$\frac{b^x}{b^y}=b^{x-y}$</p></li><li><p>$(b^x)^y=b^{xy}$</p></li></ol></blockquote><h2 id="对数法则"><a href="#对数法则" class="headerlink" title="对数法则"></a>对数法则</h2><blockquote><ol><li><p>$b^{\log_by}=y$</p></li><li><p>$\log_b1=0$</p></li><li><p>$\log_bb=1$</p></li><li><p>$\log_b{(xy)}=\log_bx+\log_by$</p></li><li><p>$\log_b(\frac{x}{y})=\log_bx-\log_by$</p></li><li><p>$\log_b(x^y)=y\log_bx$</p></li><li><p>$\log_bx=\frac{\log_cx}{\log_cb}$</p></li><li><p>$\log_xy=\frac{1}{\log_yx}$</p></li></ol></blockquote><h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><p>关于e的四个定义:</p><blockquote><p>$\lim_{h \to \infty}(1+\frac{r}{h})^h=e^r$</p><p>$\lim_{h \to 0}(1+rh)^{\frac{1}{h}}=e^r$</p><p>$\lim_{h \to \infty}(1+\frac{1}{h})^h=e$</p><p>$\lim_{h \to 0}(1+h)^{\frac{1}{h}}=e$</p><h1 id="对数函数和指数函数求导"><a href="#对数函数和指数函数求导" class="headerlink" title="对数函数和指数函数求导"></a>对数函数和指数函数求导</h1></blockquote><h2 id="对数函数和指数函数求导-1"><a href="#对数函数和指数函数求导-1" class="headerlink" title="对数函数和指数函数求导"></a>对数函数和指数函数求导</h2><p>$令f(x)=\log_bx$</p><p>根据导数定义可知</p><p>$f’(x)=\lim_{h \to 0}\frac{\log_b(x+h)-\log_bx}{h}$</p><p>$f’(x)=\lim_{h \to 0}\frac{1}{h}(\log_b(\frac{x+h}{x}))$</p><p>$f’(x)=\lim_{h \to 0}\log_b((\frac{x+h}{x})^{\frac{1}{h}})$</p><p>$f’(x)=\lim_{h \to 0}\log_b((1+\frac{h}{x})^{\frac{1}{h}})$</p><p>$f’(x)=\log_b(e^{\frac{1}{x}})=\frac{1}{x}\log_be=\frac{1}{x\ln_b}$</p><p>以上可以推导出</p><blockquote><p>$\frac{\mathrm{d}}{\mathrm{d}x}\log_bx=\frac{1}{x\ln_b}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}\ln_x=\frac{1}{x}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}b^x=b^x\ln_b$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}e^x=e^x$</p></blockquote><h1 id="对数函数和指数函数的极限"><a href="#对数函数和指数函数的极限" class="headerlink" title="对数函数和指数函数的极限"></a>对数函数和指数函数的极限</h1><h1 id="取对数求导法"><a href="#取对数求导法" class="headerlink" title="取对数求导法"></a>取对数求导法</h1><p>$处理像f(x)^{g(x)}这种底数和指数均有x的函数的导数问题时,取对数求导法是个很有用的技巧.$</p><p>$令f(x)=x^x,根据对数法则$</p><p>$\ln_(x^x)=x\ln_x=\ln_y$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}\ln_y=\ln_x+x\frac{1}{x}$</p><p>$\frac{1}{y}\frac{\mathrm{d}y}{\mathrm{d}x}=\ln_x+1$</p><p>$\frac{\mathrm{d}y}{\mathrm{d}x}=(\ln_x+1)x^x$</p><h1 id="指数增长和指数衰变"><a href="#指数增长和指数衰变" class="headerlink" title="指数增长和指数衰变"></a>指数增长和指数衰变</h1><h2 id="指数增长"><a href="#指数增长" class="headerlink" title="指数增长"></a>指数增长</h2><p>假设$y=e^{kx}$,那么$\frac{\mathrm{d}y}{\mathrm{d}x}=ke^{kx}=ky$</p><blockquote><p>如果$\frac{\mathrm{d}y}{\mathrm{d}x}=ky,那么y=Ae^{kx},其中A为某个常数$</p></blockquote><p>这意味着,y的变化率等于ky.一个量变化的速率取决于这个量的大小.如果这个量越大, 那么它就会增长得越快(假设 k &gt; 0).</p><blockquote><p>指数增长方程: $P(t)=P_0e^{kt},其中P_0是初始的总数,k是增长常数$</p></blockquote><h2 id="指数衰变"><a href="#指数衰变" class="headerlink" title="指数衰变"></a>指数衰变</h2><blockquote><p>指数衰变方程: $P(t)=P_0e^{-kt}$</p></blockquote><h1 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h1><h2 id="双曲余弦函数-双曲正弦函数"><a href="#双曲余弦函数-双曲正弦函数" class="headerlink" title="双曲余弦函数 双曲正弦函数"></a>双曲余弦函数 双曲正弦函数</h2><p><img src="/2022/04/03/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0/1.jpg" alt="alt"></p><blockquote><p>$coshx=\frac{e^x+e^{-x}}{2}$</p><p>$sinhx=\frac{e^x-e^{-x}}{2}$</p><p>$cosh^2(x)-sinh^2(x)=1$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}sinhx=coshx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}coshx=sinhx$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐函数求导</title>
      <link href="/2022/04/02/%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E5%8C%96%E7%8E%87/"/>
      <url>/2022/04/02/%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E5%8C%96%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h1><p>考虑方程$x^2 + y^2 = 4$,求$\frac{\mathrm{d}y}{\mathrm{d}x}$,对等号两边同时添加一个$\frac{\mathrm{d}}{\mathrm{d}x}$,<br>$\frac{\mathrm{d}}{\mathrm{d}x}{(x^2 + y^2)} = \frac{\mathrm{d}}{\mathrm{d}x}{4}$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}{x^2} + \frac{\mathrm{d}}{\mathrm{d}x}{y^2} = 0$</p><p>$2x +2y\frac{\mathrm{d}y}{\mathrm{d}x}=0$</p><p><strong><em>注:这一步应用链式求导法则</em></strong></p><p>$\frac{\mathrm{d}y}{\mathrm{d}x}=-\frac{x}{y}$</p><p>隐函数求导法则:</p><ul><li>在原始方程中, 对一切求导并使用链式求导法则、乘积法则以及商法则进行化简</li><li>如果想要求 dy/dx, 可重新整理并作除法来求解 dy/dx; 不过如果想要求的是斜率或求曲线一个特定点上的切线方程, 可先代入 x 和 y的已知值, 接着重新整理并求 dy/dx, 然后如果需要的话, 使用点斜式来求切线方程</li></ul><h1 id="隐函数求二阶导"><a href="#隐函数求二阶导" class="headerlink" title="隐函数求二阶导"></a>隐函数求二阶导</h1><p>求导两次可以得到二阶导.例如,如果$2y+siny = \frac{x^2}{\pi}+1$,那么该曲线上点(π, π/2)处的$\frac{\mathrm{d}y^2}{\mathrm{d}x^2}$的值是什么呢？再一次地, 你应该先通过代入 x 和 y 的值, 看看方程是否成立来检验该点是否位于曲线上. 现在, 如果你想要求导两次, 必须先从求导一次开始! 使用链式求导法则来处理$sin(y)$这一项, 你应该会得到</p><p>① $2\frac{\mathrm{d}y}{\mathrm{d}x} + cosy\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{1}{\pi}2x$</p><p>然后进行二次求导.如下:<br>② $\frac{\mathrm{d}}{\mathrm{d}x}(2\frac{\mathrm{d}y}{\mathrm{d}x}) + \frac{\mathrm{d}}{\mathrm{d}x}(cosy\frac{\mathrm{d}y}{\mathrm{d}x})=\frac{\mathrm{d}}{\mathrm{d}x}(\frac{1}{\pi}2x)$</p><p>根据乘积法则和链式求导法则可推出:<br>③ $2\frac{\mathrm{d}y^2}{\mathrm{d}x^2}-sin(y)(\frac{\mathrm{d}y}{\mathrm{d}x}^2) + cos(y)\frac{\mathrm{d}y^2}{\mathrm{d}x^2}=\frac{2}{\pi}$</p><p>根据式①带入(π, π/2)得到$\frac{\mathrm{d}y}{\mathrm{d}x}=1$.将其带入二阶导方程得知$\frac{\mathrm{d}y^2}{\mathrm{d}x^2}=\frac{1}{\pi}+\frac{1}{2}$</p>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数的极限和导数</title>
      <link href="/2022/04/02/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/"/>
      <url>/2022/04/02/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="三角函数的极限"><a href="#三角函数的极限" class="headerlink" title="三角函数的极限"></a>三角函数的极限</h1><h2 id="小数的情况"><a href="#小数的情况" class="headerlink" title="小数的情况"></a>小数的情况</h2><blockquote><p>${\lim_{x \to 0} \frac{sinx}{x}} = 1$</p><p>$\lim_{x \to 0} cosx = 1$</p><p>$\lim_{x \to 0} \frac{tanx}{x} = 1$</p><p>$\lim_{x \to 0} \frac{1-cosx}{x} = 0$</p></blockquote><h2 id="大数的情况"><a href="#大数的情况" class="headerlink" title="大数的情况"></a>大数的情况</h2><p>考虑极限$\lim_{x \to \infty}$</p><p>对于任意的x $-1 &lt;= sinx &lt;=1$  $-1 &lt;=cosx &lt;= 1$</p><p>应用三明治定理 $\lim_{x \to \infty} \frac{sinx}{x} = 0$</p><h2 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h2><p>考虑极限$\lim_{x \to \frac{\pi}{2}}\frac{cosx}{x-\frac{\pi}{2}}$<br>这次的三角函数是余弦, 且要在 π/2 的附近求值. 这既不是小数的情况也不是大数的情况, 因此很明显, 之前的情况都不适用.<strong><em>面对 x → a 的极限, 而a != 0 时, 有一个很好的一般原则, 那就是用 t = x − a作替换, 将问题转化为 t→0</em></strong></p><p>$\lim_{x \to \frac{\pi}{2}}\frac{cosx}{x-\frac{\pi}{2}}$</p><p>$\lim_{t \to 0}\frac{cos(t+\frac{\pi}{2})}{t}$</p><p>$cos(\frac{\pi}{2}+t) = sin(-t) = -sint$</p><p>$\lim_{t \to 0}\frac{-sint}{t} = -1$</p><h1 id="三角函数的导数"><a href="#三角函数的导数" class="headerlink" title="三角函数的导数"></a>三角函数的导数</h1><blockquote><p>$\frac{\mathrm{d}}{\mathrm{d}x}sinx = cosx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cosx = -sinx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}tanx = (secx)^2$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}secx = secxtanx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cscx = -cscxcotx$</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}cotx = -(cscx)^2$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求解微分问题</title>
      <link href="/2022/03/31/%E6%B1%82%E8%A7%A3%E5%BE%AE%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/31/%E6%B1%82%E8%A7%A3%E5%BE%AE%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="求解微分常用技巧"><a href="#求解微分常用技巧" class="headerlink" title="求解微分常用技巧"></a>求解微分常用技巧</h1><h2 id="使用定义求导"><a href="#使用定义求导" class="headerlink" title="使用定义求导"></a>使用定义求导</h2><p>根据导数的定义:<br>$f’(x) = \lim_{h \to 0}\frac{f(x+h) - f(x)}{h}$</p><p>$例如:对于 f(x) = \frac{1}{x}$</p><p>$f’(x) = \lim_{h \to 0}\frac{\frac{1}{x+h} - \frac{1}{x}}{h}$</p><p>$f’(x)=\lim_{h \to 0}\frac{\frac{x-(x+h)}{x(x+h)}}{h}=\lim_{h \to 0}\frac{-h}{hx(x+h)}=-\frac{1}{x^2}$</p><blockquote><p>$\frac{d}{dx}(\frac{1}{x})=-\frac{1}{x^2}$</p><p>$\frac{d}{dx}\sqrt{x}=\frac{1}{2\sqrt{x}}$</p><p>$\frac{d}{dx}x^a=ax^{a-1}$</p></blockquote><h2 id="函数的常数倍"><a href="#函数的常数倍" class="headerlink" title="函数的常数倍"></a>函数的常数倍</h2><p>处理一个函数的常数倍时,只需要用常数乘以该函数的导数就可以了.</p><blockquote><p>$\frac{d}{dx}Cf(x)=Cf’(x)$</p></blockquote><h2 id="函数和与函数差"><a href="#函数和与函数差" class="headerlink" title="函数和与函数差"></a>函数和与函数差</h2><p>对函数和与函数差求导,需要对每一部分求导然后再相加或者相减.</p><blockquote><p>$\frac{d}{dx}(f(x) + g(x))=f’(x)+g’(x)$</p></blockquote><h2 id="乘积法则"><a href="#乘积法则" class="headerlink" title="乘积法则"></a>乘积法则</h2><blockquote><p>$乘积法则(版本一):如果h(x)=f(x)g(x)那么 h’(x)=f’(x)g(x)+f(x)g’(x)$</p><p>$乘积法则(版本二):如果y=uv, 则 \frac{dy}{dx}=v\frac{du}{dx}+u\frac{dv}{dx}$</p></blockquote><h2 id="商法则"><a href="#商法则" class="headerlink" title="商法则"></a>商法则</h2><blockquote><p>$商法则(版本一):如果h(x)=\frac{f(x)}{g(x)},那么h’(x)=\frac{f’(x)g(x)-f(x)g’(x)}{g(x)^2}$</p><p>$商法则(版本二):如果y=\frac{u}{v},那么\frac{dy}{dx}=\frac{v\frac{du}{dx}-u\frac{dv}{dx}}{v^2}$</p></blockquote><h2 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h2><blockquote><p>$链式求导法则(版本一):如果h(x)=f(g(x)),那么h’(x)=f’(g(x))g’(x)$</p><p>$链式求导法则(版本二):如果y是u的函数,并且u是x的函数,那么\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$</p></blockquote><h1 id="切线方程"><a href="#切线方程" class="headerlink" title="切线方程"></a>切线方程</h1><ul><li>求斜率:通过导函数并带入给定的x值,求x点的斜率m</li><li>求直线上的一个点:通过将给定的x值带入原始函数本身得到y0值得到(x0, y0)</li><li>使用点斜式 $y-y0=m(x-x0)$</li></ul><h1 id="导数伪装的极限"><a href="#导数伪装的极限" class="headerlink" title="导数伪装的极限"></a>导数伪装的极限</h1><p>考虑求解以下极限<br>$\lim_{h \to 0}\frac{\sqrt[5]{32+h}-2}{h}$</p><p>它和以下公式非常相似:</p><p>$f’(x) = \lim_{h \to 0}\frac{f(x+h)-f(x)}{h}$</p><p>$假设f(x)=\sqrt[5]{x},则f’(x)=\lim_{h \to 0}\frac{\sqrt[5]{x+h}-\sqrt[5]{x}}{h}=\frac{1}{5}x^{\frac{-4}{5}}$<br>$设x = 32 = 2^5$</p><p>$由此可知问题可以转换为函数f(x)=\sqrt[5]{x}在x = 32时的导数即 \frac{1}{5}32^{\frac{-4}{5}}$</p>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续性和可导性</title>
      <link href="/2022/03/30/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E5%8F%AF%E5%AF%BC%E6%80%A7/"/>
      <url>/2022/03/30/%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E5%8F%AF%E5%AF%BC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h1><p>我们先从一个函数是连续的, 这到底意味着什么开始. 正如我上面所说, 直觉上, 可以一笔画出连续函数的图像.</p><h2 id="在一点处的连续"><a href="#在一点处的连续" class="headerlink" title="在一点处的连续"></a>在一点处的连续</h2><p>如果f(x)在a点连续,则必须满足以下三个条件:</p><ul><li>双侧极限${\lim_{x \to a} f(x)}$存在并且是有限的</li><li>函数在点a处有定义,$f(a)$存在并且是有限的</li><li>以上两个量相等,即: ${\lim_{x \to a} f(x) = f(x)}$</li></ul><h2 id="在一个区间上连续"><a href="#在一个区间上连续" class="headerlink" title="在一个区间上连续"></a>在一个区间上连续</h2><p>函数f在[a, b] 上连续,需满足以下三个条件:</p><ul><li>f在(a,b)的每一点都连续</li><li>函数f在x = a处右连续,即 ${\lim_{x \to a^+} f(x)} = f(a)$</li><li>函数f在x = b处左连续,即 ${\lim_{x \to b^-} f(x)} = f(b)$</li></ul><p><strong><em>★介值定理</em></strong></p><blockquote><p>$如果f(x)在[a, b]上连续, 并且f(a) &lt; 0且f(b) &gt; 0,那么在区间(a, b) 上至少有一点 c, 使得 f(c) = 0. 代之以 f(a) &gt; 0 且 f(b) &lt; 0, 同样成立.$</p></blockquote><p><strong><em>★最大值与最小值定理</em></strong></p><blockquote><p>如果f(x)在[a, b]上连续, 那么f(x)在[a, b]上至少有一个最大值和一个最小值.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数</title>
      <link href="/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="角度弧度换算"><a href="#角度弧度换算" class="headerlink" title="角度弧度换算"></a>角度弧度换算</h2><blockquote><p>用弧度度量的角 = π/180 × 用度度量的角</p><p>用角度度量的角 = 180/π × 用弧度度量的角</p></blockquote><h2 id="sin-cos-tan-csc-sec-cot"><a href="#sin-cos-tan-csc-sec-cot" class="headerlink" title="sin cos tan csc sec cot"></a>sin cos tan csc sec cot</h2><p><img src="/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/1.jpg" alt="alt"></p><blockquote><p>sin(θ) = 对边/斜边 </p><p>cos(θ) = 临边/斜边</p><p>tan(θ) = 对边/临边 = sin(θ)/cos(θ)</p><p>csc(θ) = 1/sin(θ)</p><p>sec(θ) = 1/cos(θ)</p><p>cot(θ) = 1/tan(θ)</p></blockquote><h2 id="常用三角函数速记表"><a href="#常用三角函数速记表" class="headerlink" title="常用三角函数速记表"></a>常用三角函数速记表</h2><p><img src="/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/2.jpg" alt="alt"></p><h2 id="计算三角函数"><a href="#计算三角函数" class="headerlink" title="计算三角函数"></a>计算三角函数</h2><h3 id="参考角"><a href="#参考角" class="headerlink" title="参考角"></a>参考角</h3><blockquote><p>θ 的参考角是在表示角 θ 的射线和 x 轴之间的最小的角, 它必定介于 0 到 π/2之间</p></blockquote><h3 id="ASTC表示法"><a href="#ASTC表示法" class="headerlink" title="ASTC表示法"></a>ASTC表示法</h3><p><img src="/2022/03/29/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/3.jpg" alt="alt"></p><h2 id="三角恒等式"><a href="#三角恒等式" class="headerlink" title="三角恒等式"></a>三角恒等式</h2><blockquote><p>$sin(θ)^2 + cos(θ)^2 = 1$</p><p>$1 + tan(θ)^2 = sec(θ)^2$</p><p>$cot(θ)^2 + 1 = csc(θ)^2$</p><p>$sin(A + B) = sinAcosB + cosAsinB$</p><p>$cos(A + B) = cosAcosB - sinAsinB$</p><p>$sin(A - B) = sinAcosB - cosAsinB$</p><p>$cos(A - B) = cosAcosB + sinAsinB$</p><p>$sin(2x) = 2sinxcosx$</p><p>$cos(2x) = 2(cosx)^2 - 1 = 1 - 2(sinx)^2$</p></blockquote><h2 id="正弦定理"><a href="#正弦定理" class="headerlink" title="正弦定理"></a>正弦定理</h2><p><strong><em>在任意一个平面三角形中，各边和它所对角的正弦值的比相等且等于外接圆的直径</em></strong></p><blockquote><p>$a/sinA = b/sinB = c/sinC = 2R$</p></blockquote><h2 id="余弦定理"><a href="#余弦定理" class="headerlink" title="余弦定理"></a>余弦定理</h2><p><strong><em>在任意一个平面三角形中，任何一边的平方等于其他两边平方的和减去这两边与它们夹角的余弦的积的两倍。</em></strong></p><blockquote><p>$a^2 = b^2 + c^2 -2bccosA$</p><p>$b^2 = a^2 + c^2 -2accosB$</p><p>$c^2 = a^2 + b^2 -2abcosC$</p></blockquote><h2 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h2><p>设三角形的三条边为abc.则面积s</p><blockquote><p>$p = (a + b + c) / 2$</p><p>$s = \sqrt[2]{p(p-a)(p-b)(p-c)}$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数 图形和直线</title>
      <link href="/2022/03/29/%E5%87%BD%E6%95%B0-%E5%9B%BE%E5%BD%A2%E5%92%8C%E7%9B%B4%E7%BA%BF/"/>
      <url>/2022/03/29/%E5%87%BD%E6%95%B0-%E5%9B%BE%E5%BD%A2%E5%92%8C%E7%9B%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="奇函数与偶函数"><a href="#奇函数与偶函数" class="headerlink" title="奇函数与偶函数"></a>奇函数与偶函数</h1><ul><li>当对f定义域内所有的x都有f(-x) = -f(x)时,f是奇函数.奇函数的图像关于原点有180°的对称性.</li><li>当对f定义域内所有的x都有f(-x) = f(x)时,f是偶函数,偶函数的图像关于y轴具有镜面对称性.</li></ul><h1 id="线性函数的图像"><a href="#线性函数的图像" class="headerlink" title="线性函数的图像"></a>线性函数的图像</h1><p>形如f(x) = mx + b的函数叫做线性函数,函数的图像为直线,斜率为m.</p><p> <strong><em>点斜式</em></strong></p><blockquote><p>如果已知直线通过点(x0, y0),斜率为m,则它的方程为 y - y0 = m(x - x0)</p><p>如果一条直线通过点 (x1, y1) 和 (x2, y2), 则它的斜率等于 (y2 − y1) / (x2 − x1)</p></blockquote><h1 id="常见函数及其图像"><a href="#常见函数及其图像" class="headerlink" title="常见函数及其图像"></a>常见函数及其图像</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>有许多函数是基于 x 的非负次幂建立起来的.你可以以 1、x、$x^2$、$x^3$等为基本项, 然后用实数同这些基本项做乘法, 最后把有限个这样的项加到一起.基本项 $x^n$ 的倍数叫作 $x^n$ 的系数.最大的幂指数n(该项系数不能为零) 叫作多项式的次数.</p><h3 id="二次函数"><a href="#二次函数" class="headerlink" title="二次函数"></a>二次函数</h3><p>次数为2的多项式叫做二次函数,即 p(x) = $ax^2 + bx + c$,根据判别式的符号可以判断二次函数到底有两个 一个还是没有实数解.</p><p><strong><em>判别式</em></strong></p><blockquote><p>$\bigtriangleup$ = $b^2 - 4ac$</p></blockquote><p>它共有三种可能性. 如果 $\bigtriangleup$ &gt; 0, 有两个不同的解; 如果 $\bigtriangleup$ = 0, 只有一个解, 也可以说有两个相同的解; 如果 $\bigtriangleup$ &lt; 0, 在实数范围内无解</p><h2 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h2><h2 id="指数和对数函数"><a href="#指数和对数函数" class="headerlink" title="指数和对数函数"></a>指数和对数函数</h2><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h2 id="带有绝对值的函数"><a href="#带有绝对值的函数" class="headerlink" title="带有绝对值的函数"></a>带有绝对值的函数</h2>]]></content>
      
      
      <categories>
          
          <category> calculus </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calculus </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理映射</title>
      <link href="/2022/03/09/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"/>
      <url>/2022/03/09/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;当试图重现真实世界的样貌时，人们很快就会意识到任何物体都有自己的特征。木材随纹理生长;皮肤长出皱纹;布显示其编织结构;油漆显示了刷子或辊子留下的痕迹。即使是光滑的塑料也是用模压成型的凸起物制成的，而光滑的金属则显示出制造它的加工过程的痕迹。曾经毫无特色的材料很快就会被标记、凹痕、污渍、划痕、指纹和污垢所覆盖.<br>&nbsp;&nbsp;&nbsp;&nbsp;在图形学中,我们把所有这些现象归结为”空间性的改变物体属性”- 物体表面属性因位置而异，但并不真正改变物体形状几何构造.为了实现这些效果，所有类型的建模和渲染系统都提供了一些纹理映射的方法:使用称为纹理映射的图像、纹理图像或者纹理来存储数据, 然后通过数学的方法将图片映射到物体表面.<br>&nbsp;&nbsp;&nbsp;&nbsp;事实证明,除了表现物体表面细节的基本目的外，还有许多其他应用纹理映射的方式.例如:生成阴影(shadow mapping), 反射, 提供光照(Environment mapping),甚至定义形状(bump mapping).<br>本章讨论通过纹理来表示表面细节、阴影和反射。虽然基本思想简单，但仍然面临几个问题需要处理.</p><ol><li>实现从纹理到物体表面的映射函数.</li><li>纹理映射是一个重采样的过程,就像重新调整一张图片的大小, 重采样会产生走样问题.</li></ol><h1 id="纹理查询"><a href="#纹理查询" class="headerlink" title="纹理查询"></a>纹理查询</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们考虑一个简单的纹理映射应用。我们有一个木地板的场景，我们希望地板的漫反射颜色是由一个木地板木纹图像控制。无论我们使用光线追踪或光栅化,着色代码需要知道当前作色点对应的纹理图片的颜色值,用作布林冯光照模型中的漫反射颜色系数.<br>为了拿到着色点对应纹理图片的颜色值, 着色器会执行一次纹理查询(<strong><em>texture lookup</em></strong>)-它计算在纹理图像的坐标系统中，对应于着色点的位置，然后读取图像中的颜色，从而得到纹理样本.这种颜色随后被用于着色.伪代码如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Color texture_lookup(Texture t, float u, float v) &#123;</span><br><span class="line">    int i = round(u * t.width() - 0.5)</span><br><span class="line">    int j = round(v * t.height() - 0.5)</span><br><span class="line">    return t.get_pixel(i,j)</span><br><span class="line">&#125;</span><br><span class="line">Color shade_surface_point(Surface s, Point p, Texture t) &#123;</span><br><span class="line">    Vector normal = s.get_normal(p)</span><br><span class="line">    (u,v) = s.get_texcoord(p)</span><br><span class="line">    Color diffuse_color = texture_lookup(u,v)</span><br><span class="line">    // compute shading using diffuse_color and normal</span><br><span class="line">    // return shading result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="纹理坐标方程"><a href="#纹理坐标方程" class="headerlink" title="纹理坐标方程"></a>纹理坐标方程</h1><h2 id="平铺-环绕方式-纹理坐标变换"><a href="#平铺-环绕方式-纹理坐标变换" class="headerlink" title="平铺, 环绕方式, 纹理坐标变换"></a>平铺, 环绕方式, 纹理坐标变换</h2><p>模型的纹理坐标不总是在[0,1]的区间内,纹理映射机制有不同的处理方式.<br>如果一张纹理被设计只覆盖部分表面，但纹理坐标已经设置好将整个表面映射到单元正方形，其中一种方式是准备一个几乎是空白的纹理图像，其中的内容位于一个小区域。<br>但这可能需要非常高分辨率的纹理图像来获得相关区域的足够细节。另一种做法是缩放所有纹理坐标，使它们覆盖更大的范围，例如，到位置在表面中心面积为十分之一的正方形单位。<br>在这种情况下，纹理覆盖的单元正方形区域之外的纹理查找应该返回一个固定的背景色。一种方法是设置一个背景色，由单元正方形外的纹理查找返回。如果已经有一个恒定的背景颜色纹理图像(例如,一个标志在白色背景),另一种方法是返回纹理图像的颜色最接近边缘的颜色.<br>有时我们想要一个重复的图案，比如棋盘，瓷砖地板，或砖墙。如果可以使图案在矩形网格上重复，那么使用相同数据的许多副本创建图像将是一种浪费。相反，我们可以使用环绕索引处理纹理图像外部的纹理查找—当查找点离开纹理图像的右边缘时，它会绕到左边缘。使用像素坐标上的整数余数操作可以非常简单地处理这个问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//repeat</span><br><span class="line">Color texture_lookup_wrap(Texture t, float u, float v) &#123;</span><br><span class="line">int i = round(u * t.width() - 0.5)</span><br><span class="line">int j = round(v * t.height() - 0.5)</span><br><span class="line">return t.get_pixel(i % t.width(), j % t.height())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//clamp </span><br><span class="line">Color texture_lookup_wrap(Texture t, float u, float v) &#123;</span><br><span class="line">int i = round(u * t.width() - 0.5)</span><br><span class="line">int j = round(v * t.height() - 0.5)</span><br><span class="line">return t.get_pixel(max(0, min(i, t.width()-1)),</span><br><span class="line">(max(0, min(j, t.height()-1))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上是纹理查询在越界查找时的两种不同规则,具体选择哪种由纹理的环绕方式指定,环绕方式包含平铺,约束以及两者的各种组合和变体构成.拿openGL来说,wrapMode有以下四种方式:<br><img src="/2022/03/09/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/1.jpg" alt="alt"></p><h2 id="透视矫正插值"><a href="#透视矫正插值" class="headerlink" title="透视矫正插值"></a>透视矫正插值</h2><h1 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h1>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Texture Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>着色</title>
      <link href="/2022/03/09/%E7%9D%80%E8%89%B2/"/>
      <url>/2022/03/09/%E7%9D%80%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>为了使物体看起来更有立体感,可以对其使用作色,也就是说使物体表面”涂上”光线,有明暗变化.本章展示了最通用的具有启发式的作色方法.前两个将介绍Lambertian Shading Model和Phong Shading Model, 发明于1970年代,在大多数图形API中都可以使用.最后一个介绍 artistic shading Model,模拟了人类绘制图像的风格.</p><h1 id="Diffuse-Shading"><a href="#Diffuse-Shading" class="headerlink" title="Diffuse Shading"></a>Diffuse Shading</h1><p>许多物体的表面外观被粗略地描述为“哑光”，这表明该物体根本没有光泽。例如纸张、未打磨的木材和干燥、未打磨的石头。在很大程度上，这些物体表面的颜色不会随着视角的变化而变化。例如，如果你盯着一张纸上的一个特定的点，并且在移动的同时保持你的目光在这个点上，这个点上的颜色将保持相对不变。这样的哑光物体可以被认为是表现为朗伯反射体。本节讨论如何实现这样的着色.关键的一点是，本章中的所有公式都应该在世界坐标中求值，而不是在应用了透视变换的坐标中求值。否则，法线之间的角度将改变，着色将是不准确的.</p><h2 id="Lambertian-Shading-Model"><a href="#Lambertian-Shading-Model" class="headerlink" title="Lambertian Shading Model"></a>Lambertian Shading Model</h2><p>Lambertian object遵循<strong><em>Lambert’s cosine law</em></strong>，即表面的颜色c与表面法线与光源方向夹角的余弦成正比(Gouraud, 1971):<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/1.jpg" alt="alt"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c ∝ cosθ  </span><br><span class="line">c ∝ n·l</span><br></pre></td></tr></table></figure><br>其中n和l如上图所示。因此，表面颜色将根据表面法线与光方向之间夹角余弦而变化。注意，通常假设向量l不依赖于对象的位置。这个假设是说相对于物体大小光是“遥远的”。这样的光通常被称为方向光，因为它的位置仅由一个方向来指定。<br>通过改变光源的强度或物体表面的反射率，可以使表面变亮或变暗。漫反射系数cr是光被表面反射的因子。这个系数对于rgb三个颜色分量是不同的。因此不同材质物体的漫反射颜色是不同的.例如，如果一个表面反射的红色入射光比蓝色入射光多，那么它就是红色的。如果我们假设表面颜色与从表面反射的光成比例，改进以上公式,加入漫反射系数cr和光照强度cl<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c ∝ cr cl n·l</span><br></pre></td></tr></table></figure><br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/2.jpg" alt="alt"><br>以上公式存在一个问题,当物体表面法线与光照方向相反,点积为负,加入max函数来避免这种情况<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c ∝ cr cl max(0, n·l)   </span><br></pre></td></tr></table></figure></p><h2 id="Ambient-Shading"><a href="#Ambient-Shading" class="headerlink" title="Ambient Shading"></a>Ambient Shading</h2><p>漫反射着色的一个问题是，任何表面法线与光源法线相反的表面将是黑色的。在现实生活中，光被反射到各处，有些光从各个方向反射.解决这个问题的一种方法是使用几个光源。一个常见的技巧是在视角处放置一个昏暗的光源，这样所有可见的点都能收到一些光。另一种方法是使用双面照明。一种更常见的方法是添加一个环境光常量(Gouraud, 1971)。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= cr (ca + cl max (0, n · l))</span><br></pre></td></tr></table></figure></p><h1 id="Phong-Lighting-Model"><a href="#Phong-Lighting-Model" class="headerlink" title="Phong Lighting Model"></a>Phong Lighting Model</h1><p>仅仅有diffuse Shading无法体现物体的高光特性.Phong Lighting Model引入了高光的概念.高光随着视点的移动而在表面上移动。这意味着我们必须在光照方程中加入一个单位向量e，指向眼睛。如果你仔细观察高光，你会发现它们实际上是光的反射;有时这些反射是模糊的。这些高光的颜色是光的颜色.<br>定义观测向量e,光线的反射向量r.e与e之间的夹角越小则高光越强.因此 c = cl(e · r)<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/8.jpg" alt="alt"><br>以上方程存在两个问题:</p><ol><li>向量的点乘可能为负值,需要用max约束. c = cl max(e . r)</li><li>以上方程生成的高光区域比实际的要大得多,可以在不降低最大颜色的情况下通过提高幂来收窄它 c = clmax(0, e · r)^p<br>这里p被称冯氏指数;它是一个正数(Phong, 1975)。改变冯氏指数对高光辐射面积的影响如下图所示:<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/9.jpg" alt="alt"></li></ol><h2 id="计算方式一-求反射向量r"><a href="#计算方式一-求反射向量r" class="headerlink" title="计算方式一: 求反射向量r"></a>计算方式一: 求反射向量r</h2><p>为了实现方程，我们首先需要计算单位向量r。给定单位向量l和n, r为向量l关于n的反射,公式如下:<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/10.jpg" alt="alt"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = −l + 2(l · n)n</span><br></pre></td></tr></table></figure></p><h2 id="计算方式二-半程向量"><a href="#计算方式二-半程向量" class="headerlink" title="计算方式二: 半程向量"></a>计算方式二: 半程向量</h2><p><img src="/2022/03/09/%E7%9D%80%E8%89%B2/12.jpg" alt="alt"></p><h1 id="完整的Blinn-Phong-反射模型"><a href="#完整的Blinn-Phong-反射模型" class="headerlink" title="完整的Blinn-Phong 反射模型"></a>完整的Blinn-Phong 反射模型</h1><p><img src="/2022/03/09/%E7%9D%80%E8%89%B2/13.jpg" alt="alt"></p><h1 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h1><h2 id="Flat-Shading"><a href="#Flat-Shading" class="headerlink" title="Flat Shading"></a>Flat Shading</h2><p>利用三角形法线,每个三角形计算一次着色,通常会呈现为多面的外观,对于曲面物体表现力不是很好.<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/3.jpg" alt="alt"></p><h2 id="Gouraud-Shading"><a href="#Gouraud-Shading" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h2><p>每个三角形顶点计算一次着色,三角形内部像素通过重心坐标插值计算颜色.问题在于如何获取或计算顶点法线?<br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/4.jpg" alt="alt"></p><h3 id="定义逐顶点法线"><a href="#定义逐顶点法线" class="headerlink" title="定义逐顶点法线"></a>定义逐顶点法线</h3><p>可以通过各种启发式方法计算法线。最简单的方法是将共享每个顶点的三角形的法线求平均然后在顶点处使用这个平均法线。这个平均法线没有经过标准化，所以在使用它做着色之前需要把它转换成一个单位向量。</p><p><img src="/2022/03/09/%E7%9D%80%E8%89%B2/5.jpg" alt="alt"><br><img src="/2022/03/09/%E7%9D%80%E8%89%B2/6.jpg" alt="alt"></p><h2 id="Phong-Shading"><a href="#Phong-Shading" class="headerlink" title="Phong Shading"></a>Phong Shading</h2><p>首先计算每个顶点的法线,通过重心坐标插值计算三角形内部每个像素的法线,每个像素计算一次着色.性能最低但是效果最好.</p><h2 id="三种着色频率对比"><a href="#三种着色频率对比" class="headerlink" title="三种着色频率对比"></a>三种着色频率对比</h2><p><img src="/2022/03/09/%E7%9D%80%E8%89%B2/7.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Shading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号处理</title>
      <link href="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
      <url>/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><p>在图形学中,通常要处理些连续变量的函数:图片是你见过的第一个例子，但是当你继续探索图形学的时候，你会遇到很多类似的情况.就其本质而言,计算机无法直接表达连续的函数,必须使用有限的位数表达他们- <strong>采样(将函数的值离散的存储起来,在需要时进行重建).</strong><br>本章首先用数字音频的具体一维例子来总结采样和重构。然后，我们继续介绍在一维和二维的采样和重构基础上的基本数学和算法。最后，我们深入频域观点的细节，它为这些算法的行为提供了许多见解。</p><h2 id="数字音频-一维采样"><a href="#数字音频-一维采样" class="headerlink" title="数字音频: 一维采样"></a>数字音频: 一维采样</h2><p>尽管采样在电信领域已经应用了很多年,但随着数字音频的使用增加，1982年cd的推出是采样在消费者中的第一次大规模应用.<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.jpg" alt="alt"><br>在录音过程中，麦克风将空气中以压力波形式存在的声音转换成时变的电压，这相当于在麦克风所在的位置测量空气压力的变化。这种电信号需要以某种方式储存起来，以便在以后的某个时间播放，并发送到扬声器中，通过与电压同步移动膜片，将电压转换回压力波.<br>录制音频的过程中使用了采样技术, 模数转换器 analog-to-digital converter (A/D converter, or ADC)每秒钟数千次测量电压,生成容易被存储下来的数据流(例如记录在计算机硬盘中).<br>在回放时,数据流以适当的速率被读取,并被发送到数模转换器 digital-to-analog converter (D/A converter, or DAC),DAC根据它接收到的数字产生一个电压，并且如果我们取足够多的样本来表示电压的变化，所得到的电信号，都是相同的输入信号.<br>事实证明，每秒钟需要多少样本来完成一次良好的录制，取决于我们试图记录的声音有多高。一个可以很好录制弦乐低音或者鼓的采样率，应用于录制短笛或铙钹，就会产生奇怪的结果;但这些声音在较高的采样率下被录制得很好。为了避免这些采样不足的影响，数字音频记录器对ADC的输入进行滤波，去除可能导致问题的高频。<br>另一种问题出现在输出端。DAC产生的电压在新采样进入时发生变化，但在下一个采样进入前保持不变，产生阶梯型的波形。这些楼梯就像噪音一样，增加了一种高频的、依赖于信号的嗡嗡声。为了消除这种重建带来的问题，数字音频播放器过滤DAC的输出以平滑波形.</p><h2 id="采样偏差与失真"><a href="#采样偏差与失真" class="headerlink" title="采样偏差与失真"></a>采样偏差与失真</h2><p>数字音频记录链可以作为采样和重建过程的具体模型，发生在图形中。同样的欠采样和重构伪影也会发生在图像或图形中的其他采样信号上，解决方法是一样的:采样前进行滤波，重构时再进行滤波.<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.png" alt="alt"><br>上图显示了一个由过低的采样频率导致的走样具体例子。在这里，我们用两种不同的采样频率对一个简单的正弦波进行采样:顶部的高频采样和底部的低频采样。高频采样显然能够更好的还原信号,但是由低采样率产生的样本与低频正弦波的样本是无法区分的.<br>一旦采样完成，就无法区分两个信号——快正弦波和慢正弦波——哪个是原始信号，因此没有单一的方法可以在这两种情况下正确地重建信号。因为高频信号可以“假装”成低频信号，这种现象被称为失真。<br>在图形领域,失真经常表现为: </p><ul><li>摩尔纹(moire patterns)  </li><li>边缘锯齿</li></ul><p>采样和重构的基本问题可以简单地根据特征太小或太大来理解，但一些更定量的问题很难回答:</p><ul><li>多高的采样率能够还原重建结果?</li><li>什么样的滤波器适合于采样和重建?</li><li>为了避免失真,需要多大程度的平滑过渡?</li></ul><h2 id="卷积-Convolution"><a href="#卷积-Convolution" class="headerlink" title="卷积(Convolution)"></a>卷积(Convolution)</h2><p>在讨论采样和重建相关算法之前,首先需要明确相关的基础数学概念-<strong>卷积</strong>.卷积是一个简单的数学概念，它构建了采样、滤波和重构的算法基础.卷积是对函数的一种操作:它接受两个函数作为参数,生成一个新的函数.本书中采用星号(★)作为标记.对函数f和g应用卷积的结果为 f★g.<br>卷积即可以应用于连续函数,也可以应用于离散序列的函数. 它可以应用于定义在一维、二维或高维域上的函数(即具有一个、两个或多个参数的函数)。</p><h3 id="移动的平均数-平滑处理"><a href="#移动的平均数-平滑处理" class="headerlink" title="移动的平均数(平滑处理)"></a>移动的平均数(平滑处理)</h3><p>为了对卷积有一个基本概念上的认识，考虑使用移动平均来平滑一维函数的例子。为了得到任意点的平滑值，我们在每个方向上扩展距离r的范围内计算函数的平均值。距离r称为平滑操作的半径，是一个参数，控制平滑计算的采样范围.<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3.jpg" alt="alt"><br>对于离散函数或连续函数，我们可以用数学方法来表述这个概念。</p><ul><li>如果我们平滑一个连续函数g(x)，平均意味着在一个区间上对g积分，然后除以区间的长度:<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/4.jpg" alt="alt"></li><li>另一方面,如果要平滑处理一个离散函数a[i],平均意味着将一系列的a相加，然后除以数值的个数:<br><img src="/2022/03/06/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/5.jpg" alt="alt"><br><strong>移动平均线的概念是卷积的本质;唯一的区别是在卷积中移动平均是一个加权平均。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Signal Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学相关</title>
      <link href="/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学数学基础知识"><a href="#计算机图形学数学基础知识" class="headerlink" title="计算机图形学数学基础知识"></a>计算机图形学数学基础知识</h1><h2 id="集合与映射-Sets-and-Mappings"><a href="#集合与映射-Sets-and-Mappings" class="headerlink" title="集合与映射(Sets and Mappings)"></a>集合与映射(Sets and Mappings)</h2><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p><img src="/2022/03/01/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/1.jpg" alt="alt"></p><h3 id="对数-Logarithms"><a href="#对数-Logarithms" class="headerlink" title="对数(Logarithms)"></a>对数(Logarithms)</h3><p>时至今日，但对数在出现指数项方程的问题中经常有用。根据定义，每一个对数都有一个以a为底的对数</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphic </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphic </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - Context</title>
      <link href="/2021/11/22/Context/"/>
      <url>/2021/11/22/Context/</url>
      
        <content type="html"><![CDATA[<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>This solution means that you’d have to rewrite a special version of every existing function you want to use in a Maybe! This greatly limits the usefulness of tools such as Maybe. It turns out Haskell has a type class that solves this problem, called Functor.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>Maybe is a member of the Functor type class. The Functor type class requires only one definition: fmap.<br><img src="/2021/11/22/Context/1.jpg" alt="alt"><br>_<strong>fmap provides an adapter</strong>_, Notice that we’re using &lt;$&gt;, which is a synonym for fmap (except it’s a binary operator rather than a function._<strong>This ability to transform the types of values inside a Maybe is the true power of the Functor type class.</strong>_<br><img src="/2021/11/22/Context/2.jpg" alt="alt"></p><p>Though fmap is the official function name, in practice the binary operator &lt;$&gt; is used much more frequently<br><img src="/2021/11/22/Context/3.png" alt="alt"></p><h1 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h1><p>_<strong>the Applicative type class allows you to use functions that are inside a context, such as Maybe or IO, Functor is a superclass of Applicative.</strong>_<br><img src="/2021/11/22/Context/4.jpg" alt="alt"><br><img src="/2021/11/22/Context/5.jpg" alt="alt"></p><h2 id="The-pure-method"><a href="#The-pure-method" class="headerlink" title="The pure method"></a>The pure method</h2><p>The pure method is a useful helper function for taking an ordinary value(also function) or function and putting it into a context.<br><img src="/2021/11/22/Context/7.png" alt="alt"></p><h2 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;*&gt;"></a>&lt;*&gt;</h2><p><img src="/2021/11/22/Context/6.png" alt="alt"></p><h2 id="Containers-vs-contexts"><a href="#Containers-vs-contexts" class="headerlink" title="Containers vs. contexts"></a>Containers vs. contexts</h2><ol><li>Parameterized types that represent a container are types that represent a data structure.</li><li>When a type is a context, extra information is implied about the type, beyond its structure.</li></ol><h2 id="List-as-a-context"><a href="#List-as-a-context" class="headerlink" title="List as a context"></a>List as a context</h2><p>The List type is both a container and a context.List as a container is easy to understand. List is basically a chain of buckets of whatever type of data you want to hold. But List is a member of Applicative,so there must be a way to view List as a context.<br>_<strong>List as a context is that it describes nondeterministic computation.</strong>_</p><p><img src="/2021/11/22/Context/8.png" alt="alt"><br>when you add values in the context of a list,you’re adding together all possible values from the two contexts.</p><ol><li>A list as a container is a sequence of values that can hold any type. Each item in the list points to the next one or to the empty list.</li><li>A list as a context represents a set of possibilities. Think of a list as a context as being a single variable that can contain many possible values.</li></ol><h1 id="MONAD"><a href="#MONAD" class="headerlink" title="MONAD"></a>MONAD</h1><h2 id="The-Monad-type-class"><a href="#The-Monad-type-class" class="headerlink" title="The Monad type class"></a>The Monad type class</h2><p><img src="/2021/11/22/Context/10.jpg" alt="alt"></p><p><img src="/2021/11/22/Context/11.png" alt="alt"></p><h3 id="The-bind-operator-gt-gt"><a href="#The-bind-operator-gt-gt" class="headerlink" title="The bind operator: &gt;&gt;="></a>The bind operator: &gt;&gt;=</h3><p><img src="/2021/11/22/Context/9.png" alt="alt"><br>_<strong>As you can see, &gt;&gt;= allows you to chain together a function of a type (a -&gt; m b)</strong>_</p><h2 id="the-list-Monad"><a href="#the-list-Monad" class="headerlink" title="the list Monad"></a>the list Monad</h2><p>when you assign your list to a variable using &lt;-, you get to treat it as though it were a single value. The rest of this code looks like it’s operating on one candidate, and yet the final result is the same as applying your logic to every candidate in a list.<br><img src="/2021/11/22/Context/12.png" alt="alt"></p><h3 id="Building-lists-with-the-list-monad"><a href="#Building-lists-with-the-list-monad" class="headerlink" title="Building lists with the list monad"></a>Building lists with the list monad</h3><p><img src="/2021/11/22/Context/13.png" alt="alt"></p><h3 id="The-guard-function"><a href="#The-guard-function" class="headerlink" title="The guard function"></a>The guard function</h3><p>Again you could use filter, but when working with monads, you’d like to be able to reason about a value outside its context. In Control.Monad, a function called guard allows you to filter your values in a list. You have to import Control.Monad to use guard.<br><img src="/2021/11/22/Context/14.png" alt="alt"></p><h3 id="list-comprehensions"><a href="#list-comprehensions" class="headerlink" title="list comprehensions"></a>list comprehensions</h3><p><img src="/2021/11/22/Context/15.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell03 - IO</title>
      <link href="/2021/11/20/IO/"/>
      <url>/2021/11/20/IO/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-TYPES"><a href="#IO-TYPES" class="headerlink" title="IO TYPES"></a>IO TYPES</h1><p>Haskell has a special parameterized type called IO. Any value in an IO context must stay in this context. This prevents code that’s pure (meaning it upholds referential transparency and doesn’t change state) and code that’s necessarily impure from mixing.</p><h2 id="IO-types—dealing-with-an-impure-world"><a href="#IO-types—dealing-with-an-impure-world" class="headerlink" title="IO types—dealing with an impure world"></a>IO types—dealing with an impure world</h2><p>IO in Haskell is a parameterized type that’s similar to Maybe.The first thing they share in common is that they’re parameterized types of the same kind.The other thing that Maybe and IO have in common is that (unlike List or Map) they describe a context for their parameters rather than a container. The context for the IO type is that the value has come from an input/output operation.To keep Haskell code pure and predictable, you use the IO type to provide a context for data that may not behave the way all of the rest of your Haskell code does. IO actions aren’t functions.</p><h2 id="Examples-of-IO-actions"><a href="#Examples-of-IO-actions" class="headerlink" title="Examples of IO actions"></a>Examples of IO actions</h2><p>main doesn’t return any meaningful value; it simply performs an action. It turns out that main isn’t a function, because it breaks one of the fundamental rules of functions: it doesn’t return a value. Because of this, we refer to main as an IO action. IO actions work much like functions except they violate at least one of the three rules we established for functions early in the book. Some IO actions return no value, some take no input, and others don’t always return the same value given the same input.<br><img src="/2021/11/20/IO/1.png" alt="alt"></p><h2 id="Do-notation"><a href="#Do-notation" class="headerlink" title="Do-notation"></a>Do-notation</h2><p>This do-notation allows you to treat IO types as if they were regular types. This also explains why some variables use let and others use &lt;-. Variables assigned with &lt;- allow you to act as though a type IO a is just of type a. You use let statements whenever you create variables that aren’t IO types.</p><h3 id="lt"><a href="#lt" class="headerlink" title="&lt;-"></a>&lt;-</h3><p>Donotation allows you to assign an IO String variable by using &lt;-, to act like it’s an ordinary String, and then to pass it to functions that work with only regular Strings<br><img src="/2021/11/20/IO/2.png" alt="alt"></p><h1 id="LAZY-I-O"><a href="#LAZY-I-O" class="headerlink" title="LAZY I/O"></a>LAZY I/O</h1><h2 id="the-nonlazy-way"><a href="#the-nonlazy-way" class="headerlink" title="the nonlazy way"></a>the nonlazy way</h2><p><img src="/2021/11/20/IO/3.png" alt="alt"></p><p><img src="/2021/11/20/IO/4.png" alt="alt"></p><h2 id="lazy-way"><a href="#lazy-way" class="headerlink" title="lazy way"></a>lazy way</h2><p><img src="/2021/11/20/IO/5.png" alt="alt"></p><h3 id="do-notation-in-Maybe"><a href="#do-notation-in-Maybe" class="headerlink" title="do-notation in Maybe"></a>do-notation in Maybe</h3><p>IO can use do-notation because it’s a member of a powerful type class called Monad. We discuss Monad much more in unit 5. Do-notation has nothing to do with IO in particular and can be used by any member of Monad to perform computation in a context. </p><h1 id="TEXT-AND-UNICODE"><a href="#TEXT-AND-UNICODE" class="headerlink" title="TEXT AND UNICODE"></a>TEXT AND UNICODE</h1><h2 id="The-Text-type"><a href="#The-Text-type" class="headerlink" title="The Text type"></a>The Text type</h2><p>Unlike String, Text is implemented as an array under the hood. This makes many string operations faster and much more memory-efficient. Another major difference between Text and String is that Text doesn’t use lazy evaluation. Lazy evaluation proved to be helpful in the preceding lesson, but in many real-world cases it can lead to performance headaches. If you do need lazy text, you can use Data.Text.Lazy, which has the same interface as Data.Text.</p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell02 - types</title>
      <link href="/2021/11/18/types/"/>
      <url>/2021/11/18/types/</url>
      
        <content type="html"><![CDATA[<h1 id="01-TYPE-BASICS"><a href="#01-TYPE-BASICS" class="headerlink" title="01. TYPE BASICS"></a>01. TYPE BASICS</h1><p>in Haskell, you haven’t had to write down any information about the<br>type you’re using for any of your values. It turns out this is because Haskell has done it<br>for you! Haskell uses type inference to automatically determine the types of all values at<br>compile time based on the way they’re used! You don’t have to rely on Haskell to determine your types for you.</p><p><img src="/2021/11/18/types/1.png" alt="alt"></p><h2 id="list-tuple-function"><a href="#list-tuple-function" class="headerlink" title="list  tuple  function"></a>list  tuple  function</h2><p><img src="/2021/11/18/types/2.png" alt="alt"></p><h3 id="Functions-with-multiple-arguments"><a href="#Functions-with-multiple-arguments" class="headerlink" title="Functions with multiple arguments"></a>Functions with multiple arguments</h3><p>why are type signatures this way? The reason is that behind the scenes in Haskell, all functions take only one argument. By rewriting makeAddress by using a series of nested lambda functions.</p><p><img src="/2021/11/18/types/3.png" alt="alt"></p><h3 id="Types-for-first-class-functions"><a href="#Types-for-first-class-functions" class="headerlink" title="Types for first-class functions"></a>Types for first-class functions</h3><p>functions can take functions as arguments and return<br>functions as values. To write these type signatures, you write the individual function<br>values in parentheses.</p><p><img src="/2021/11/18/types/4.png" alt="alt"></p><h2 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h2><p> Haskell has type variables. Any lowercase letter in a type signature indicates that any type can be used in that place.<br> Type variables are literally variables for types. Type variables work exactly like regular<br>variables, but instead of representing a value, they represent a type. When you use a<br>function that has a type variable in its signature, you can imagine Haskell substituting<br>the variable that’s needed.</p><h1 id="02-CREATING-YOUR-OWN-TYPES"><a href="#02-CREATING-YOUR-OWN-TYPES" class="headerlink" title="02. CREATING YOUR OWN TYPES"></a>02. CREATING YOUR OWN TYPES</h1><h2 id="type-synonyms"><a href="#type-synonyms" class="headerlink" title="type synonyms"></a>type synonyms</h2><p>When you have two names for the same type, it’s referred to as a type synonym. Type synonyms are extremely useful, because they make reading type signatures much easier.<br>_<strong>In Haskell, you can create new type synonyms by using the type keyword.</strong>_</p><h2 id="Creating-new-types"><a href="#Creating-new-types" class="headerlink" title="Creating new types"></a>Creating new types</h2><h2 id="record-syntax"><a href="#record-syntax" class="headerlink" title="record syntax"></a>record syntax</h2><p>You can define data types such as Patient by using record syntax. Defining a new data type by using record syntax makes it much easier to understand which types represent<br>which properties of the data type.<br><img src="/2021/11/18/types/5.png" alt="alt"></p><h3 id="automatically-getters-and-setters"><a href="#automatically-getters-and-setters" class="headerlink" title="automatically getters and setters"></a>automatically getters and setters</h3><p>you don’t have to write your getters; each field in the record syntax automatically creates a function to access that value from the record.You can also set values in record syntax by passing the new value in curly brackets to<br>your data.<br><img src="/2021/11/18/types/6.png" alt="alt"></p><h1 id="03-TYPE-CLASSES"><a href="#03-TYPE-CLASSES" class="headerlink" title="03. TYPE CLASSES"></a>03. TYPE CLASSES</h1><p>Type classes in Haskell are a way of describing groups of types that all behave in the same way. If you’re familiar with<br>Java or C#, type classes may remind you of interfaces.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>definition of the type class is a list of functions that all members of the class must implement, along with the type signatures of<br>those functions. The family of functions that describe a number is +, -, *, negate, abs, and<br>signum (gives the sign of a number)<br><img src="/2021/11/18/types/7.jpg" alt="alt"></p><h2 id="The-benefits-of-type-classes"><a href="#The-benefits-of-type-classes" class="headerlink" title="The benefits of type classes"></a>The benefits of type classes</h2><p>So far in Haskell, each function you’ve defined works for only one specific set of types. Without type classes, you’d need a different name for each function that adds a different type of value. You do have type variables, but they’re too flexible.<br>_<strong>Type classes also allow you to define functions on a variety of types that you can’t even<br>think of</strong>_</p><h2 id="Defining-a-type-class"><a href="#Defining-a-type-class" class="headerlink" title="Defining a type class"></a>Defining a type class</h2><p><img src="/2021/11/18/types/8.jpg" alt="alt"></p><h2 id="Deriving-type-classes"><a href="#Deriving-type-classes" class="headerlink" title="Deriving type classes"></a>Deriving type classes</h2><p><img src="/2021/11/18/types/9.png" alt="alt"></p><h2 id="implement-type-class"><a href="#implement-type-class" class="headerlink" title="implement type class"></a>implement type class</h2><p><img src="/2021/11/18/types/10.png" alt="alt"></p><h2 id="Creating-types-with-newtype"><a href="#Creating-types-with-newtype" class="headerlink" title="Creating types with newtype"></a>Creating types with newtype</h2><p>When looking at our type definition for Name, you find an interesting case in which you’d like to use a type synonym, but need to define a data type in order to make your type an instance of a type class. Haskell has a preferred method of doing this: _<strong>using the newtype keyword.</strong>_ Here’s an example of the definition of Name using newtype.<br><img src="/2021/11/18/types/11.png" alt="alt"></p><h1 id="04-AlGEBRAIC-DATA-TYPES"><a href="#04-AlGEBRAIC-DATA-TYPES" class="headerlink" title="04. AlGEBRAIC DATA TYPES"></a>04. AlGEBRAIC DATA TYPES</h1><p>Algebraic data types are any types that can be made by combining other types. The key to understanding algebraic data types is knowing exactly how to combine other types. Thankfully, there are only two ways. You can combine multiple types with an and (for example, a name is a String and another String), or you can combine types with an or (for example, a Bool is a True data constructor or a False data constructor). Types that are made by combining other types with an and are called product types. Types combined using or are called sum types.</p><h2 id="product-type"><a href="#product-type" class="headerlink" title="product type"></a>product type</h2><p>Product types are created by combining two or more existing types with and, bundling two or more types together to define a new type. Nearly every programming language supports product types, even if not by that name.<br><img src="/2021/11/18/types/12.png" alt="alt"></p><h2 id="sum-type"><a href="#sum-type" class="headerlink" title="sum type"></a>sum type</h2><p>Sum types are a surprisingly powerful tool, given that they provide only the capability to combine two types with or. </p><h1 id="05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS"><a href="#05-DESIGN-BY-COMPOSITION—SEMIGROUPS-AND-MONOIDS" class="headerlink" title="05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS"></a>05. DESIGN BY COMPOSITION—SEMIGROUPS AND MONOIDS</h1><h2 id="combining-functions"><a href="#combining-functions" class="headerlink" title="combining functions"></a>combining functions</h2><p>combining functions:A special higher-order function that’s just a period (called compose) takes two functions as arguments.<br><img src="/2021/11/18/types/13.png" alt="alt"></p><h2 id="Combining-like-types-Semigroups"><a href="#Combining-like-types-Semigroups" class="headerlink" title="Combining like types: Semigroups"></a>Combining like types: Semigroups</h2><p>The Semigroup class has only one important method you need, the &lt;&gt; operator. You can think of &lt;&gt; as an operator for combining instances of the same type.<br><img src="/2021/11/18/types/14.png" alt="alt"><br>_<strong>This simple signature is the heart of the idea of composability; you can take two like<br>things and combine them to get a new thing of the same type.</strong>_</p><h2 id="Composing-with-identity-Monoids"><a href="#Composing-with-identity-Monoids" class="headerlink" title="Composing with identity: Monoids"></a>Composing with identity: Monoids</h2><p>Another type class that’s similar to Semigroup is Monoid. The only major difference between Semigroup and Monoid is that Monoid requires an identity element for the type. An identity element means that x &lt;&gt; id = x (and id &lt;&gt; x = x). _<strong>Having an identity element might seem like a small detail, but it greatly increases the power of a type by allowing you to use a fold function to easily combine lists of the same type.</strong>_<br><img src="/2021/11/18/types/15.png" alt="alt"></p><h3 id="mconcat"><a href="#mconcat" class="headerlink" title="mconcat"></a>mconcat</h3><p>_<strong>The mconcat method takes a list of Monoids and combines them, returning a single Monoid.</strong>_<br>The easiest way to see how powerful identity is, is to explore the final method in the definition of Monoid: mconcat. The only required definitions in Monoid are mempty and mappend. If you implement these two, you get mconcat for free.This is because the definition of mconcat relies only on foldr, mappend, and mempty. Here’s the definition of mconcat:<br><img src="/2021/11/18/types/16.png" alt="alt"></p><h3 id="Monoid-laws"><a href="#Monoid-laws" class="headerlink" title="Monoid laws"></a>Monoid laws</h3><ol><li>mappend mempty x is x</li><li>mappend x mempty is x</li><li>mappend x (mappend y z) = mappend (mappend x y) z</li><li>mconcat = foldr mappend mempty</li></ol><h1 id="06-PARAMETERIZED-TYPES"><a href="#06-PARAMETERIZED-TYPES" class="headerlink" title="06. PARAMETERIZED TYPES"></a>06. PARAMETERIZED TYPES</h1><p>If you’re familiar with type generics in languages such as C# and Java, parameterized types will initially seem similar. Like generics in C# and Java, parameterized types allow you to create “containers” that can hold other types.</p><h2 id="definition-1"><a href="#definition-1" class="headerlink" title="definition"></a>definition</h2><p><img src="/2021/11/18/types/17.png" alt="alt"></p><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>A list of type a is either Empty or the consing of the value a with another     list of type a.<br><img src="/2021/11/18/types/18.png" alt="alt"></p><h2 id="Types-with-more-than-one-parameter"><a href="#Types-with-more-than-one-parameter" class="headerlink" title="Types with more than one parameter"></a>Types with more than one parameter</h2><p>Just like functions, types can also take more than one argument. The important thing to remember is that more than one type parameter means the type can be a container for more than one type.</p><h3 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h3><p>Tuples are the most ubiquitous multiparameter type in Haskell. tuples use a built-in type constructor, ().you have to use () with one comma inside for every n – 1 items in the tuple. For example, if you want the definition of a 2-tuple, you’d type :info<br>(,) into GHCi. Here’s the built-in definition.<br><img src="/2021/11/18/types/19.png" alt="alt"></p><h3 id="Data-Map"><a href="#Data-Map" class="headerlink" title="Data.Map"></a>Data.Map</h3><p>Map allows you to look up values by using keys. In many other languages, this data type is called Dictionary. The type parameters of Map are the types of the keys and values. The most common way to build a Map is with the fromList function.<br><img src="/2021/11/18/types/20.png" alt="alt"><br><img src="/2021/11/18/types/21.png" alt="alt"></p><h2 id="Kinds-types-of-types"><a href="#Kinds-types-of-types" class="headerlink" title="Kinds: types of types"></a>Kinds: types of types</h2><p>The type of a type is called its kind. _<strong>The kind of a type indicates the number of parameters the type takes, which are expressed using an asterisk (<em>). Types that take no parameters have a kind of </em>, types that take one parameter have the kind <em> -&gt; </em>, types with two parameters have the kind <em> -&gt; </em> -&gt; *, and so forth.</strong>_</p><h1 id="07-Maybe"><a href="#07-Maybe" class="headerlink" title="07. Maybe"></a>07. Maybe</h1><h2 id="solving-missing-values-with-types"><a href="#solving-missing-values-with-types" class="headerlink" title="solving missing values with types"></a>solving missing values with types</h2><p>Maybe is a simple but powerful type. So far, all of our parameterized types have been viewed as containers. Maybe is different. _<strong>Maybe is best understood as a type in a context.The context in this case is that the type contained might be missing. Here’s its definition.</strong>_<br><img src="/2021/11/18/types/22.png" alt="alt"><br>When a function returns a value of the Maybe type, the program can’t use that value without dealing with the fact that the value<br>is wrapped in a Maybe. Missing values can never cause an error in Haskell because Maybe makes it impossible to forget that a value might be null. At the same time, the programmer never has to worry about this until absolutely necessary. </p><p>_<strong>The interesting thing here is that you didn’t even have to remove the organ from the Maybe context. Maybe implements Eq, so you can just compare two Maybe Organs.</strong>_</p><h2 id="isJust-and-isNothing"><a href="#isJust-and-isNothing" class="headerlink" title="isJust and isNothing"></a>isJust and isNothing</h2><p>The Data.Maybe module contains two functions, isJust and isNothing, that solve the general case of handling Just values. </p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell01 - Foundations of functional programming</title>
      <link href="/2021/11/16/Foundations-of-functional-programming/"/>
      <url>/2021/11/16/Foundations-of-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Functions"><a href="#01-Functions" class="headerlink" title="01. Functions"></a>01. Functions</h1><p>All functions in Haskell follow three rules that force them to behave like functions in<br>math:</p><ul><li>All functions must take an argument.</li><li>All functions must return a value.</li><li>Anytime a function is called with the same argument, it must return the same<br>value</li></ul><p>The third rule is part of the basic mathematical definition of a function. When the rule<br>that the same argument must always produce the same result is applied to function in a<br>programming language, it’s called referential transparency.</p><h1 id="02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE"><a href="#02-LAMBDA-FUNCTIONS-AND-LEXICAL-SCOPE" class="headerlink" title="02. LAMBDA FUNCTIONS AND LEXICAL SCOPE"></a>02. LAMBDA FUNCTIONS AND LEXICAL SCOPE</h1><h2 id="Lambda-functions"><a href="#Lambda-functions" class="headerlink" title="Lambda functions"></a>Lambda functions</h2><p>One of the most foundational concepts in functional programming is a function without<br>a name, called a lambda function (hence lambda calculus). Lambda functions are often<br>referred to using the lowercase Greek letter λ. Another common name for a lambda<br>function is an anonymous function.<br><img src="/2021/11/16/Foundations-of-functional-programming/1.png" alt="alt"></p><h2 id="Practical-lambda-functions-and-lexical-scope"><a href="#Practical-lambda-functions-and-lexical-scope" class="headerlink" title="Practical lambda functions and lexical scope"></a>Practical lambda functions and lexical scope</h2><p>IIFE works on exactly the same principles as our example of replacing a where statement. Whenever you create a new function, named or not, you<br>create a new scope, which is the context in which a variable is defined. When a variable is<br>used, the program looks at the nearest scope; if the definition of the variable isn’t there,<br>it goes to the next one up. This particular type of variable lookup is called lexical scope.<br>Both Haskell and JavaScript use lexical scoping, which is why IIFE and your lambda function variables behave in a similar fashion.</p><h1 id="03-FIRST-CLASS-FUNCTIONS"><a href="#03-FIRST-CLASS-FUNCTIONS" class="headerlink" title="03. FIRST-CLASS FUNCTIONS"></a>03. FIRST-CLASS FUNCTIONS</h1><p>The concept of first-class functions is that functions are no different from any other data<br>used in a program. Functions can be used as arguments and returned as values from<br>other functions. This is a deceptively powerful feature for a programming language to<br>have. It allows you to abstract out any repetitive computation from your code, and ultimately allows you to write functions that write other functions.</p><h1 id="04-LISTS"><a href="#04-LISTS" class="headerlink" title="04 LISTS"></a>04 LISTS</h1><p>Lists are the single most important data structure in functional programming. One of<br>the key reasons is that lists are inherently recursive. A list is either an empty list or an<br>element followed by another list</p><h2 id="head-tail"><a href="#head-tail" class="headerlink" title="head tail"></a>head tail</h2><p>When taking apart a list, the main pieces are the head, the tail.The head is just the first element in a list.The tail is the rest of the list left over, after the head<br><img src="/2021/11/16/Foundations-of-functional-programming/3.png" alt="alt"></p><p><img src="/2021/11/16/Foundations-of-functional-programming/4.png" alt="alt"></p><h2 id="cons"><a href="#cons" class="headerlink" title="cons(:)"></a>cons(:)</h2><p>To build a list, you need just one function and the infix operator (:),<br>which is called cons. you need to take a value and cons it with another list. The simplest way<br>to make a list is to cons a value with the empty list. _<strong>By definition, a list is always a<br>value consed with another list (which can also be an empty list)</strong>_<br>If you do want to combine two lists, you need to concatenate them by using ++</p><h2 id="lazy-evaluation"><a href="#lazy-evaluation" class="headerlink" title="lazy evaluation"></a>lazy evaluation</h2><p>Haskell uses a special form of evaluation called lazy evaluation. In lazy evaluation,<br>no code is evaluated until it’s needed.</p><h2 id="Common-functions-on-lists"><a href="#Common-functions-on-lists" class="headerlink" title="Common functions on lists"></a>Common functions on lists</h2><h3 id="The-operator"><a href="#The-operator" class="headerlink" title="The !! operator"></a>The !! operator</h3><p>If you want to access a particular element of a list by its index, you can use the !! operator. The !! operator takes a list and a number, returning the element at that location in<br>the list. _<strong>any infix operator (an operator that’s placed between two values, such as +) can also be used like a prefix function by wrapping it in parentheses</strong>_<br><img src="/2021/11/16/Foundations-of-functional-programming/5.png" alt="alt"></p><h4 id="partial-application"><a href="#partial-application" class="headerlink" title="partial application"></a>partial application</h4><p>_<strong>Using prefix notation can often make things such as partial application easier. Prefix<br>notation is also useful for using operators as arguments to other functions. You can still<br>use partial application with an infix operator; you just need to wrap the expression in<br>parentheses</strong>_</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>give the length of the list</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>reverse the list</p><h3 id="elem"><a href="#elem" class="headerlink" title="elem"></a>elem</h3><p>The elem function takes a value and a list and checks whether the value is in the list.elem is a function that you may want to treat as an infix operator for readability. _<strong>Any<br>binary function can be treated as an infix operator by wrapping it in back-quotes (`)</strong>_</p><h3 id="take-and-drop"><a href="#take-and-drop" class="headerlink" title="take and drop"></a>take and drop</h3><p>The take function takes a number and a list as arguments and then returns the first n elements of the list. f you ask for more values then a list has, take gives you what it can, with no error.</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>You use zip when you want to combine two lists into tuple pairs. The arguments to zip<br>are two lists. If one list happens to be longer, zip will stop whenever one of the two lists<br>is empty.</p><h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><p> cycle uses lazy evaluation to create an infinite list. Given a list, cycle repeats that list endlessly.<br><img src="/2021/11/16/Foundations-of-functional-programming/6.png" alt="alt"></p><h1 id="05-RECURSION-AND-PATTERN-MATCHING"><a href="#05-RECURSION-AND-PATTERN-MATCHING" class="headerlink" title="05 RECURSION AND PATTERN MATCHING"></a>05 RECURSION AND PATTERN MATCHING</h1><p>In general, something is recursive if it’s defined in terms of itself.</p><h2 id="Rules-from-Recursion"><a href="#Rules-from-Recursion" class="headerlink" title="Rules from Recursion"></a>Rules from Recursion</h2><ol><li>Identify the end goal(s).</li><li>Determine what happens when a goal is reached.</li><li>List all alternate possibilities.</li><li>Determine your “rinse and repeat” process.</li><li>Ensure that each alternative moves you toward your goal.</li></ol><h2 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h2><p>Haskell has an amazing feature called pattern matching<br>that allows you to peek at the values passed as arguments and behave accordingly.</p><ol><li>_<strong>Pattern matching, just like case, looks at the options in order</strong>_</li><li>_<strong>pattern matching is that it can look only at arguments, but it can’t do any computation on them when matching</strong>_</li><li>_<strong>it’s standard practice to use _ as a wildcard for values you don’t use</strong>_</li></ol><h2 id="Recursion-on-lists"><a href="#Recursion-on-lists" class="headerlink" title="Recursion on lists"></a>Recursion on lists</h2><h3 id="implements-built-in-length-take-cycle"><a href="#implements-built-in-length-take-cycle" class="headerlink" title="implements built-in length take cycle"></a>implements built-in length take cycle</h3><p><img src="/2021/11/16/Foundations-of-functional-programming/7.png" alt="alt"></p><h1 id="06-HIGHER-ORDER-FUNCTIONS"><a href="#06-HIGHER-ORDER-FUNCTIONS" class="headerlink" title="06 HIGHER-ORDER FUNCTIONS"></a>06 HIGHER-ORDER FUNCTIONS</h1><p>A higher-order function is technically any function that takes another function as an argument.<br>Typically, when higher-order functions are mentioned, a specific group of them comes<br>to mind, and nearly all of these are used to abstract away common patterns of recursion.<br>The main reason that you use first-class functions, and therefore have higher-order<br>functions, is so you can abstract out programming patterns</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>The map function takes another function and a list as arguments and applies that<br>function to each element in the list.</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>The filter function looks and behaves similarly to map, taking a function and a list as arguments and<br>returning a list. The difference is that the function passed to filter must be passed a<br>function that returns True or False. The filter function works by keeping only the elements of the list that pass the test</p><h2 id="foldl-foldr"><a href="#foldl-foldr" class="headerlink" title="foldl(foldr)"></a>foldl(foldr)</h2><p>The function foldl (the l stands for left) takes a list and reduces<br>it to a single value. The function takes three arguments: a binary function, an initial<br>value, and a list. The most common use of foldl is to sum a list.</p><h2 id="implements-map-filter-amp-foldl"><a href="#implements-map-filter-amp-foldl" class="headerlink" title="implements map filter &amp; foldl"></a>implements map filter &amp; foldl</h2><p><img src="/2021/11/16/Foundations-of-functional-programming/8.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function</title>
      <link href="/2021/11/02/function/"/>
      <url>/2021/11/02/function/</url>
      
        <content type="html"><![CDATA[<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="函数声明的两种方式"><a href="#函数声明的两种方式" class="headerlink" title="函数声明的两种方式"></a>函数声明的两种方式</h2><p><img src="/2021/11/02/function/1.png" alt="alt"></p><blockquote><p>如果使用函数重载，则只能使用第一种方式</p></blockquote><p><img src="/2021/11/02/function/2.png" alt="alt"></p><h2 id="参数注解-amp-返回类型注解"><a href="#参数注解-amp-返回类型注解" class="headerlink" title="参数注解 &amp; 返回类型注解"></a>参数注解 &amp; 返回类型注解</h2><h2 id="可选参数-amp-默认值参数"><a href="#可选参数-amp-默认值参数" class="headerlink" title="可选参数 &amp; 默认值参数"></a>可选参数 &amp; 默认值参数</h2>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>enum</title>
      <link href="/2021/11/01/enum/"/>
      <url>/2021/11/01/enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h1><p>当一个变量有几种可能的取值时,可以将它定义为枚举类型，</p><ol><li>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加</li><li>因此当我们把第一个值赋值后,后面也会根据第一个值进行累加</li><li>枚举类型的值其实也可以是字符串类型</li><li>字符串枚举可以和数字枚举混合使用</li></ol><h2 id="枚举的本质-amp-双向映射"><a href="#枚举的本质-amp-双向映射" class="headerlink" title="枚举的本质 &amp; 双向映射"></a>枚举的本质 &amp; 双向映射</h2><p>枚举具有双向映射的特性，所谓双向映射指的是通过key可以索引到value,同时通过value也可以索引到key.<br>原因就在编译后的 JavaScript把枚举类型构造成为了一个对象，而由于其特殊的构造，导致其拥有正反向同时映射的特性<br><img src="/2021/11/01/enum/1.png" alt="alt"></p><h2 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h2><p>枚举可以被 const 声明为常量,这样做的好处是，编译后的js代码中实际上是不存在枚举和枚举对象的，使用的是枚举的值，这是性能提升的一个方案。</p><blockquote><p>如果你非要 TypeScript 保留对象 Direction ,那么可以添加编译选项 —preserveConstEnums</p></blockquote><h2 id="联合枚举类型"><a href="#联合枚举类型" class="headerlink" title="联合枚举类型"></a>联合枚举类型</h2><p>将一个变量声明为枚举类型，可以认为声明了一个联合类型，联合类型的值对应枚举的值。<br><img src="/2021/11/01/enum/2.png" alt="alt"></p><h2 id="使用数字类型作为标志"><a href="#使用数字类型作为标志" class="headerlink" title="使用数字类型作为标志"></a>使用数字类型作为标志</h2><p><img src="/2021/11/01/enum/3.png" alt="alt"></p><h2 id="为枚举添加静态方法"><a href="#为枚举添加静态方法" class="headerlink" title="为枚举添加静态方法"></a>为枚举添加静态方法</h2><p>可以使用enum + namespace 的声明方式向枚举类型添加静态方法.如下例所示，我们将静态成员 isBusinessDay 添加到枚举上<br><img src="/2021/11/01/enum/4.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface</title>
      <link href="/2021/10/31/interface/"/>
      <url>/2021/10/31/interface/</url>
      
        <content type="html"><![CDATA[<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查,它有时被称做”鸭式辩型法”或”结构型子类型化”.<br>TypeScript里接口的作用就是为这些类型命名和为你的代码和第三方代码定义契约.<br><img src="/2021/10/31/interface/1.png" alt="alt"></p><h2 id="可选属性-amp-只读属性"><a href="#可选属性-amp-只读属性" class="headerlink" title="可选属性 &amp; 只读属性"></a>可选属性 &amp; 只读属性</h2><p><img src="/2021/10/31/interface/2.png" alt="alt"></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p><img src="/2021/10/31/interface/3.png" alt="alt"></p><h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>通过定义key和value的类型宽泛的描述接口”形状”.<br><img src="/2021/10/31/interface/4.png" alt="alt"></p><h4 id="所有成员都必须符合字符串的索引签名"><a href="#所有成员都必须符合字符串的索引签名" class="headerlink" title="所有成员都必须符合字符串的索引签名"></a>所有成员都必须符合字符串的索引签名</h4><p><img src="/2021/10/31/interface/5.png" alt="alt"></p><h4 id="使用一组有限的字符串字面量"><a href="#使用一组有限的字符串字面量" class="headerlink" title="使用一组有限的字符串字面量"></a>使用一组有限的字符串字面量</h4><p>一个索引签名可以通过映射类型来使索引字符串为联合类型中的一员<br><img src="/2021/10/31/interface/6.png" alt="alt"></p><h4 id="索引签名的嵌套"><a href="#索引签名的嵌套" class="headerlink" title="索引签名的嵌套"></a>索引签名的嵌套</h4><p>尽量不要使用这种把字符串索引签名与有效变量混合使用。如果属性名称中有拼写错误，这个错误不会被捕获到<br><img src="/2021/10/31/interface/8.png" alt="alt"></p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>基于现有接口实现一个新接口,添加部分额外属性,可以通过接口继承的方式,实现代码重用.<br><img src="/2021/10/31/interface/7.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeScript类型系统</title>
      <link href="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="typeScript类型系统"><a href="#typeScript类型系统" class="headerlink" title="typeScript类型系统"></a>typeScript类型系统</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>基本注解采用 <strong>:TypeAnnotation</strong>语法,在类型声明空间中可用的任何内容都可以用作类型注解</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 string、number、boolean 也可以被用作类型注解.</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/1.png" alt="alt"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>针对数组的类型注解有两种方式 <strong>:TypeAnnotation[]</strong> 或者 <strong>Array\<TypeAnnotation></TypeAnnotation></strong>,这两种方式是等价的<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/2.png" alt="alt"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>typeScript核心特性,合并众多类型声明至一个类型声明<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/3.png" alt="alt"></p><h3 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h3><p>内联类型能快速提供一个类型注解,不必为类型起单独的名称,然而,如果你发现需要多次使用相同的内联注解,应该把它重构为一个接口<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/4.png" alt="alt"></p><h3 id="联合类型-amp-交叉类型"><a href="#联合类型-amp-交叉类型" class="headerlink" title="联合类型 &amp; 交叉类型"></a>联合类型 &amp; 交叉类型</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型(|)"></a>联合类型(|)</h4><p>所期望的属性是众多类型之一,如字符串或字符串数组,本质上是类型的并集操作,这正是typeScript中联合类型的用途,使用 | 作标记.</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/5.png" alt="alt"></p><h4 id="交叉类型-amp"><a href="#交叉类型-amp" class="headerlink" title="交叉类型(&amp;)"></a>交叉类型(&amp;)</h4><p>在 JavaScript 中， extend 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/6.png" alt="alt"></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型和数组很相似,表示一个已知元素数量和类型的数组,各元素的类型不必相同.可以把元组看成严格版型的数组<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/7.png" alt="alt"><br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/8.png" alt="alt"></p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <strong>type SomeName = someValidTypeAnnotation</strong> 来创建别名：</p><p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/9.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core 文件系统</title>
      <link href="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-文件系统"><a href="#Asp-Net-Core-文件系统" class="headerlink" title="Asp.Net Core 文件系统"></a>Asp.Net Core 文件系统</h1><p>ASP.NET Core 具有很多针对文件读取的应用。比如我们倾向于采用JSON文件来定义配置，所以应用就会涉及针对配置文件读取。如果用户发送一个针对物理文件的HTTP请求，应用会根据指定的路径读取目标文件的内容并对请求予以响应。在一个ASP.NET Core MVC应用中，针对View的动态编译会涉及到根据预定义的路径映射关系来读取目标View文件。这些不同应用场景都会出现一个IFileProvider对象的身影，以此对象为核心的文件系统提供了统一的API来读取文件的内容并监控内容的改变。</p><h2 id="物理文件系统"><a href="#物理文件系统" class="headerlink" title="物理文件系统"></a>物理文件系统</h2><h3 id="IChangeToken"><a href="#IChangeToken" class="headerlink" title="IChangeToken"></a>IChangeToken</h3><p>由于IFileProvider提供了针对文件系统变换的监控功能，在.NET Core的世界里类似的功能大都利用一个IChangeToken对象来实现.从字面上理解的IChangeToken对象就是一个与某组监控数据关联的“令牌（Token）”，它能够在检测到数据改变的时候及时地对外发出一个通知。IChangeToken接口具有如下所示的三个成员。</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider1.jpg" alt="alt"></p><ul><li><p><strong>HasChanged</strong>:如果关联的数据发生改变，HasChanged属性将变成True.</p></li><li><p><strong>ActiveChangeCallbacks</strong>:它表示当数据发生变化时是否需要主动执行注册的回调操作.</p></li><li><p><strong>RegisterChangeCallback</strong>:注册一个在数据发生改变时可以自动执行的回调，该方法会以一个IDisposable对象的形式返回注册对象，所以我们应该在适当的时机调用其Dispose方法解除注册的回调.</p></li></ul><h3 id="IFileProvider"><a href="#IFileProvider" class="headerlink" title="IFileProvider"></a>IFileProvider</h3><p>IFileProvider的接口定义如下图:</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider2.jpg" alt="alt"></p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider3.jpg" alt="alt"></p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider4.jpg" alt="alt"></p><ul><li><p><strong>GetDirectoryContents</strong>:通过给定的路径遍历目录,返回一个由IFileInfo组成的集合.该接口有一个属性Exists,判断指定路径目录是否存在.</p></li><li><p><strong>IsDirectory</strong>:由GetDirectoryContents得到的集合中无论是目录还是文件,都会用IFileInfo来表示.判断是文件还是目录用属性IsDirectory来区分.</p></li><li><p><strong>GetFileInfo</strong>:获取指定路径下的文件.如果是目录或者不存在,则Exists属性返回false.</p></li><li><strong>Watch</strong>:监控指定文件的变化,如果产生变化,则调用注册的回调函数.如下图所示.</li></ul><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider5.jpg" alt="alt"></p><p>文件系统涉及的接口以及相互关系图.</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider6.jpg" alt="alt"></p><h3 id="物理文件系统-1"><a href="#物理文件系统-1" class="headerlink" title="物理文件系统"></a>物理文件系统</h3><p>物理文件系统涉及的接口以及相互关系图</p><p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider7.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务消费</title>
      <link href="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/"/>
      <url>/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务消费"><a href="#Asp-Net-Core-DI-服务消费" class="headerlink" title="Asp.Net Core DI-服务消费"></a>Asp.Net Core DI-服务消费</h1><p>本系列博客均来源于大内老A关于Asp.NET Core的解读,在此进基础上进行了提炼,方便日后查看学习.<br>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IServiceProvider的GetService方法，IServiceProvider就会根据对应的服务注册提供所需的服务实例。</p><h2 id="IServiceProvider"><a href="#IServiceProvider" class="headerlink" title="IServiceProvider"></a>IServiceProvider</h2><p>IServiceProvider由ServiceCollection的BuildServiceProvider方法来生成,ServiceProvider只包含一个方法GetService(Type serviceType).如下图:</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use1.jpg" alt="alt"><br>IserviceProvider包含其他一些扩展方法,可以方便通过不同方式不用应用场景返回实例.如下图:</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use2.jpg" alt="alt"></p><ul><li>GetService<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应实例,如果没有T对应的注册信息,返回null</T></li><li>GetServices<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应的多个实例</T></li><li>GetServices(this IServiceProvider provider, Type serviceType):传参的方式</li><li>GetRequiredService(this IServiceProvider provider, Type serviceType):如果指定服务类型的服务注册不存在,则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用者两个扩展方法</li></ul><h2 id="构造函数的选择"><a href="#构造函数的选择" class="headerlink" title="构造函数的选择"></a>构造函数的选择</h2><p>如果IServiceProvider对象试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，最终被选择出来的构造函数必须具备一个基本的条件：</p><ul><li>第一个原则:<strong>IServiceProvider能够提供构造函数的所有参数</strong>.</li><li>第二个原则: <strong>每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集</strong>.</li></ul><h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>对于DI框架体用的三种生命周期（Singleton、Scoped和Transient）来说，Singleton和Transient都具有明确的语义，但是Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由IServiceScopeFactory接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有如图3所示的“父子关系”。</p><p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有“父子关系”。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use3.jpg" alt="alt"></p><p>如上图所示的树形层次结构只是一种逻辑结构，从对象引用层面来开，通过某个IServiceScope包裹的IServiceProvider对象不需要知道自己的“父亲”是谁，它只关心作为根节点的IServiceProvider在哪里就可以了。下图从物理层面揭示了IServiceScope/IServiceProvider对象之间的关系，任何一个IServiceProvider对象都具有针对根容器的引用。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use4.jpg" alt="alt"></p><h2 id="三种生命周期模式"><a href="#三种生命周期模式" class="headerlink" title="三种生命周期模式"></a>三种生命周期模式</h2><ul><li><strong>Singleton</strong>:IServiceProvider创建的服务实例保存在作为根容器的IServiceProvider上，所有多个同根的IServiceProvider对象提供的针对同一类型的服务实例都是同一个对象.</li><li><strong>Scoped</strong>:IServiceProvider创建的服务实例由自己保存，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象.</li><li><strong>Transient</strong>:针对每一次服务提供请求,IServiceProvider总是创建一个新的实例.</li></ul><h2 id="ASP-NET-Core应用下的生命周期"><a href="#ASP-NET-Core应用下的生命周期" class="headerlink" title="ASP.NET Core应用下的生命周期"></a>ASP.NET Core应用下的生命周期</h2><p>DI框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如下图所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider，另一个类则是根据请求及时创建和释放的IServiceProvider，我们可以将它们分别称为Application ServiceProvider和Request ServiceProvider。</p><p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use5.jpg" alt="alt"></p><p>在ASP.NET Core应用初始化过程中，即请求管道构建过程中使用的服务实例都是由Application ServiceProvider提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个服务范围，该服务范围提供的Request ServiceProvider用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，上述的这个中间件会主动释放掉由它创建的服务范围。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI-服务注册</title>
      <link href="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-DI-服务注册"><a href="#Asp-Net-Core-DI-服务注册" class="headerlink" title="Asp.Net Core DI-服务注册"></a>Asp.Net Core DI-服务注册</h1><p>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。IServiceCollection实际上是包含了<strong>ServiceDescriptor</strong>对象的集合.</p><h2 id="ServiceDescriptor"><a href="#ServiceDescriptor" class="headerlink" title="ServiceDescriptor"></a>ServiceDescriptor</h2><p>IServiceCollection对象是一个存放服务注册信息的集合.在IServiceCollection/IServiceProvider为核心的DI框架中,与之对应的类型为ServiceDescriptor.</p><p>DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中.如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p>ServiceDescriptor共有5个属性,3个构造函数,如下所示:</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment1.jpg" alt="alt"></p><p>属性说明:</p><ul><li>ServiceType:注册的服务类型.往往是一个接口</li><li>ImplementationType:实现ServiceType接口的类</li><li>ImplementationInstance:已经实例化的对象</li><li>ImplementationFactory:提供对象的工厂方法.类型为Func<IServiceProvider,object></IServiceProvider,object></li><li>Lifetime:生命周期,枚举类型,对应有三个值,分别为:Singleton,Scoped,Transient</li></ul><p>构造函数说明:<br>ServiceDescriptor的三个属性(ImplementationType,ImplementationInstance,ImplementationFactory)体现了服务实例的三种提供方式，并对应着三个构造函数。</p><ul><li>ServiceDescriptor(Type serviceType,object instace):提供现有对象,该对象就是最终提供的服务实例.</li><li>ServiceDescriptor(Type serviceType,Type implementationType,ServiceLifetime lifetime):最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建.</li><li>ServiceDescriptor(Type serviceType, Func<IServiceProvider, object> factory, ServiceLifetime lifetime):IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例</IServiceProvider,></li></ul><h2 id="IServiceCollection"><a href="#IServiceCollection" class="headerlink" title="IServiceCollection"></a>IServiceCollection</h2><p>DI框架将服务注册(IServiceDescriptor)存储在一个通过IServiceCollection接口表示的集合之中.一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment2.jpg" alt="alt"></p><p>我们在应用启动的时候所做的服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程.考虑到服务注册是一个高频调用的操作,所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作.</p><p>DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中.如下所示的是针对Singleton模式的AddSingleton方法重载的定义,针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义.</p><p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment3.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core DI框架</title>
      <link href="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-NET-Core-DI框架概览"><a href="#Asp-NET-Core-DI框架概览" class="headerlink" title="Asp.NET Core DI框架概览"></a>Asp.NET Core DI框架概览</h1><p>毫不夸张地说,整个ASP.NET Core框架是建立在一个依赖注入框架之上的,它在应用启动时构建请求处理管道的过程中,以及利用该管道处理每个请求过程中使用到的服务对象均来源于DI容器.该DI容器不仅为ASP.NET Core框架提供必要的服务,同时作为了应用的服务提供者,依赖注入已经成为了ASP.NET Core应用基本的编程模式.</p><h2 id="服务的注册与消费"><a href="#服务的注册与消费" class="headerlink" title="服务的注册与消费"></a>服务的注册与消费</h2><p>ASP.NET Core中的依赖注入框架中,我们添加的服务注册被保存到通过 <strong>IServiceCollection</strong> 接口表示的集合之中,基于这个集合创建的DI容器体现为 <strong>IServiceProvider</strong>.</p><p>DI框架提供了生产实例的三种生命周期模式,分别为:</p><ul><li><strong>Singleton</strong>:整个应用程序生命周期内单例</li><li><strong>Scoped</strong>:单次服务请求内的单例</li><li><strong>Transient</strong>:每次获取均会产生新的对象</li></ul><p>DI框架注册服务时通常会使用三种方式,分别为:</p><ul><li>指定注册非服务类型和实现类型.</li><li>指定一个现有的服务实例.</li><li>指定一个创建服务实例的委托对象.</li></ul><p>当我们在进行服务注册时,可以为同一类型添加一个服务注册,也可以添加多个,实际上添加的所有服务注册都是有效的,在完成服务注册之后，我们调用IServiceCollection接口的扩展方法  <strong>BuildServiceProvider</strong>创建出代表DI容器的IServiceProvider对象,并利用它调用后者的<strong>GetService<T></T></strong>方法来提供相应的服务实例,总时会返回一个服务实例,这里采用了”后来居上”的原则,即总是采用最近添加的服务注册来创建服务实例.如果我们调用另一个扩展方法<strong>GetServices<T></T></strong>,它将利用返回所有服务注册提供的服务实例.如下所示的代码片段.</p><p><img src="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/DI1.jpg" alt="alt"></p><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p>IServiceProvider之间的层次结构造就了三种不同的生命周期模式：由于Singleton服务实例保存在作为根容器的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。Scoped服务实例被保存在当前IServiceProvider上，所以它只能在当前IServiceProvider对象的“服务范围”保证的单例的。没有实现IDisposable接口的Transient服务则采用“即用即取，用后即弃”的策略。</p><p>接下来我们通过简单的实例来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表DI容器的IServiceProvider对象之后，我们调用其CreateScope方法创建了两个所谓的“服务范围”，后者的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。</p><pre><code>//根节点的ServiceProvidervar root = new ServiceCollection()        .AddTransient&lt;IFoo, Foo&gt;()        .AddScoped&lt;IBar&gt;(_ =&gt; new Bar())        .AddSingleton&lt;IBaz, Baz&gt;()        .BuildServiceProvider();//子节点的ServiceProvidervar provider1 = root.CreateScope().ServiceProvider;var provider2 = root.CreateScope().ServiceProvider;void GetServices&lt;TService&gt;(IServiceProvider provider)&#123;    provider.GetService&lt;TService&gt;();    provider.GetService&lt;TService&gt;();&#125;GetServices&lt;IFoo&gt;(provider1);GetServices&lt;IBar&gt;(provider1);GetServices&lt;IBaz&gt;(provider1);Console.WriteLine();GetServices&lt;IFoo&gt;(provider2);GetServices&lt;IBar&gt;(provider2);GetServices&lt;IBaz&gt;(provider2);输出:Foo Foo Bar Baz     Foo Foo Bar</code></pre>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc模式对应的几种设计模式</title>
      <link href="/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/19/Ioc%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ioc原则对应的几种设计模式"><a href="#Ioc原则对应的几种设计模式" class="headerlink" title="Ioc原则对应的几种设计模式"></a>Ioc原则对应的几种设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IoC仅仅是一种设计原则,针对IoC的设计原则有多种设计模式,例如:模板方法,简单工厂,抽象工厂等.以下通过这三种设计模式阐述如何实现IoC设计原则的.</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据按照预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。</p><p>所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供一组相关的对象。</p><p>具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。</p><h2 id="依赖注入-DI容器"><a href="#依赖注入-DI容器" class="headerlink" title="依赖注入(DI容器)"></a>依赖注入(DI容器)</h2><p>DI:Dependency Injection.含义为依赖注入.DI是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。</p><p>在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供所需的每一个服务实例。<br>我们将这个被框架用来提供服务的容器称为“DI容器”.</p><p>从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。依赖注入主要有三种方式:[构造器注入]  [属性注入] [方法注入]</p><h3 id="Service-Locator"><a href="#Service-Locator" class="headerlink" title="Service Locator"></a>Service Locator</h3><p>假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器，那么我们可以采用如下两种方式(ServiceProvider和ServiceLocator)来定义这个服务类型Foo.</p><pre><code>public class Foo : IFoo&#123;    public IBar Bar &#123; get; &#125;    public IBaz Baz &#123; get; &#125;    //方式一:通过构造器注入,通过框架生成服务实例    public Foo(IBar bar, IBaz baz)    &#123;        Bar = bar;        Baz = baz;    &#125;      public async Task InvokeAsync()    &#123;        await Bar.InvokeAsync();        await Baz.InvokeAsync();    &#125;&#125;public class Foo : IFoo&#123;    public Cat Cat &#123; get; &#125;    public Foo(Cat cat) =&gt; Cat = cat;     public async Task InvokeAsync()    &#123;        //方式二:Service Locator,主动去获取服务实例        await Cat.GetService&lt;IBar&gt;().InvokeAsync();        await Cat.GetService&lt;IBaz&gt;().InvokeAsync();    &#125;&#125;</code></pre><p>以上两种方式虽然都解决了针对服务的解耦问题,但是第二种使用方式不能称之为”依赖注入”,而是一种被称为”Service Locator”的设计模式.Service Locator模式同样具有一个通过服务注册创建的全局容器来提供所需的服务实例,该容器被称为”Service Locator”.DI容器和Service Locator实际上是同一事物在不同设计模型的不同称谓罢了.DI容器和Service Locator之间的差异体现在 <strong>“被谁使用”</strong>.DI容器的使用者是框架自身,Service Locator的使用者是应用程序.一般情况下我们尽可能通过构造器注入的方式使用,尽量不要使用Service Locator模式.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.Net Core IoC</title>
      <link href="/2019/10/19/Asp.NetCoreIoC/"/>
      <url>/2019/10/19/Asp.NetCoreIoC/</url>
      
        <content type="html"><![CDATA[<h1 id="Asp-Net-Core-IOC模式"><a href="#Asp-Net-Core-IOC模式" class="headerlink" title="Asp.Net Core IOC模式"></a>Asp.Net Core IOC模式</h1><p>本系列文章来源于大内老A的博客,对博客内容进行了略微整理,方便自己以后查阅.</p><h2 id="IoC名词解释"><a href="#IoC名词解释" class="headerlink" title="IoC名词解释"></a>IoC名词解释</h2><p>IoC全名为Inverse of Control,含义为”控制倒置”,针对软件设计行业来说,IoC所谓的控制其实是”针对流程的控制”.控制权原来在应用程序,应用程序可以根据自己的场景定义流程,而IoC原则主张流程的控制权转移到框架中,由框架来定义流程的步骤,我们可以通过下图来说明控制权的转移过程.</p><p><img src="/2019/10/19/Asp.NetCoreIoC/IOC1.jpg" alt="alt"></p><h2 id="流程定制"><a href="#流程定制" class="headerlink" title="流程定制"></a>流程定制</h2><p>我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制.作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。</p><p>我们可以说得更加宽泛点。如下图所示我们将一个泛化的工作流程（A=&gt;B=&gt;C）被定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。 </p><p><img src="/2019/10/19/Asp.NetCoreIoC/IOC2.jpg" alt="alt"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一方面IoC对框架的流程进行了封装,消费者只需要执行,框架利用引擎驱动整个流程的运转,应用程序无须关心该工作流程的细节,只需要启动引擎即可.另一方面,框架会提供一系列的扩展点,应用程序则通过定义扩展的方式实现对流程某个环节的定制,在引擎启动前,应用程序将所需的扩展注册到框架中,一旦引擎被正常启动,这些注册的扩展会自动参与到整个流程的执行过程中.这样就实现了框架对流程的高度复用和扩展.</p>]]></content>
      
      
      <categories>
          
          <category> Asp.Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.Net Core </tag>
            
            <tag> IOC DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google开发者工具使用指南</title>
      <link href="/2019/09/18/google%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/09/18/google%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="google开发者工具使用指南"><a href="#google开发者工具使用指南" class="headerlink" title="google开发者工具使用指南"></a>google开发者工具使用指南</h1>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript学习笔记</title>
      <link href="/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/10/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h2><ul><li>ECMAScript:由ECMA-262定义,提供核心语言功能</li><li>文档对象模型(DOM):提供访问和操作网页内容的方法和接口</li><li>浏览器对象模型(BOM):提供与浏览器交互的方法和接口</li></ul><h2 id="变量-作用域和内存问题"><a href="#变量-作用域和内存问题" class="headerlink" title="变量 作用域和内存问题"></a>变量 作用域和内存问题</h2><p>JavaScript的变量与其他语言有很大区别.不存在定义某个变量必须要保存何种数据类型值的规则,变量的值以及数据类型可以在脚本的生命周期内改变.</p><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li><p>从一个变量向另一个变量赋值基本类型的值,会在变量对象上创建一个新值,然后把该值赋值带为新变量分配的位置上.</p></li><li><p>当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份跟放到为新变量分配的空间中,不同的是,这个值的副本实际上是一个指针.而这个指针指向存储在堆内存中的一个对象.</p></li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>Js中所有函数的参数都是按值传递的.不同的是,对于基本类型的值来说,被传递的值会复制给一个局部变量.对于引用类型的值,会把这个值在内存中的地址复制给一个局部变量.<strong>因此这个局部变量的变化会反映在函数的外部</strong>.</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>检测基本数据类型,通常使用typeof操作符,换句话说,typeof操作符是确定一个变量是字符串,数字,布尔值还是undefined的最佳工具.</li><li>检测引用类型,通常使用instanceof操作符.语法如下:<br><code>result = variable instanceof constructor</code></li></ul><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>JavaScript函数不介意传递进来多少个参数,也不在乎传进来参数是什么类型,即使定义的函数只接受两个参数,调用时也未必要传递两个参数,原因是JavaScript函数的参数在函数内部用一个arguments对象来表示.</p><ul><li><p>参数个数</p><p> 当实参比函数声明指定的形参要少,剩下的形参都将设置为undefined,通常会使用逻辑或(||)来判断参数是否有值来给变量设置默认值.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(x,y)&#123;</span><br><span class="line">    x = x||1;</span><br><span class="line">    y = y||2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(3);</span><br></pre></td></tr></table></figure></li><li><p>对象参数</p><p> 当函数中需要传递多个参数时,一般会使用对象参数的方式,通过键/值对的形式传递参数,这样参数的顺序就无关紧要了.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net 请求webservice接口</title>
      <link href="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="C-调用webservice接口"><a href="#C-调用webservice接口" class="headerlink" title="C#调用webservice接口"></a>C#调用webservice接口</h2><p>由于项目需要调用第三方的webservice接口,以前没有接触过webservice相关知识,故在此记录下来备忘.下边通过webservice天气预报接口为例.简单介绍下如何在.NET项目中调用外部webservice.</p><p>1.项目中添加”服务引用”.如下图:<br>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice1.jpg" alt="alt"></p><p>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice2.jpg" alt="alt"></p><p>  <img src="/2019/04/10/NET%E8%AE%BF%E9%97%AEwebservice%E6%8E%A5%E5%8F%A3/webservice3.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> .net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .net </tag>
            
            <tag> Webservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记整理</title>
      <link href="/2017/02/22/css/"/>
      <url>/2017/02/22/css/</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>css有三种样式嵌入方式，分别为内联，嵌入，外部引用，一般情况下优先级为内联样式表&gt;嵌入样式表&gt;外部样式表，前提是外部引用css文件在嵌入的前边，如果外部引用在嵌入的后边那么外部引用的优先级将高于嵌入的。简而言之，css优先级是以离标签的距离为依据的。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>取所有选择器所选择元素的并集，然后集中设置样式，语法为在每个选择器中间加上逗号，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1,selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>给所有选择器选中的标签中，相交的那部分标签设置属性。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1Selecotr2&#123;</span><br><span class="line">   属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：Selector1和selector2之间没人任何符号也没有空格。</em><br><span id="more"></span></p><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>给指定选择器后面紧跟的那个选择器中的标签设置属性，必须是第一个选择器后边紧跟的第一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1+Selector2&#123;</span><br><span class="line">  属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>给指定选择器后面的所有选择器选中的所有标签设置属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector1~Selector2&#123;</span><br><span class="line">  属性：值;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><p>selector1:first-child  选中selector1同级别中的第一个元素，如果是selector1对应的元素则选中，否则无法选中任何元素。<br>selector1:last-child 选中同级别中的最后一个标签，如果该标签是Selector1对应的元素，则选中,否则无法选中任何元素。<br>selector1:nth-child(n)选中同级别中的第N个元素，如果该元素是选择器1对应标签则选中<br>selector1:nth-last-child(n)倒数第N个。<br>selector1:only-child选中父元素中唯一的元素。</p><p>selector1:first-of-type 选中同级别中同类型的第一个元素<br>selector1:last-of-type  选中同级别中同类型的最后一个元素<br>selector1:nth-of-type(n) 取出同级别同类型的第N个元素，<br>selector1:nth-last-of-type(n) 同级别同类型倒数第N个元素<br>selector1:only-of-type 选中父元素中唯一类型的元素</p><p>selector1:nth-child(odd) 奇数选择器<br>selector1:nth-child(even) 偶数选择器<br>selector1:nth-child(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><p>selector1:nth-of-type(odd) 奇数选择器<br>selector1:nth-of-type(even) 偶数选择器<br>selector1:nth-of-type(xN+y) 周期选择器 x y的值可以自定义，N表示从0开始一直递增到元素的总数</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p><strong>[attribute]:</strong> 根据指定的属性名称找到对应的标签<br><strong>[attribute=value]:</strong>找到有指定属性，并且属性的取值等于value的标签，常见的应用场景用于区分input属性。例如：Input[type=text]<br><strong>[attribute^=value]:</strong>属性值以value开头的元素 CSS3( [attribute|=value] css2)<br><strong>[attribute$=value]:</strong>属性值以value结尾的<br><strong>[attribute*=value]:</strong>属性值包含value css3([attribute~=value] css2)</p><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1.继承性"></a>1.继承性</h3><p>给父元素设置一些属性，子元素以及后代元素都可以使用，这个我们称之为继承性。并不是所有的属性都可以集成，<strong>只有以color/font-/text-/line开头的属性才可以继承。</strong><br><strong>注意：</strong>CSS继承性中的特殊性：a标签的颜色及样式不可以继承;h标签的字体大小不能继承。<br><strong>应用：</strong>一般用于设置网页上的一些共性信息，例如网页的文字颜色，文字大小等内容，一般在body{}中进行统一设置</p><h3 id="2-层叠性"><a href="#2-层叠性" class="headerlink" title="2.层叠性"></a>2.层叠性</h3><p>在样式表现时，有可能会出现两个或更多的样式寻找同一元素，这就可能出现表现层的不确定性和样式冲突，CSS通过“层叠”给每个规则分配一个重要度。</p><h3 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3.优先级"></a>3.优先级</h3><p><strong>1&gt;</strong>     是否是直接选中（间接选中就是指继承）,如果是间接选中，那么谁离目标比较近就取谁的值。</p><p><strong>2&gt;</strong>     如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级层叠，具体优先级为:<strong>id&gt;class&gt;标签&gt;通配符(*)&gt;继承&gt;浏览器默认。</strong></p><p><strong>3&gt;</strong>     如果都是直接选中，并且都是同类型的选择器，那么谁写的靠后取谁的值。</p><p><strong>4&gt;</strong>     !important 用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级提升为最高，!important 只能用于直接选中，不能用于间接选中，!important的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">  属性:值!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5&gt;</strong>     <strong>优先级的权重</strong>:当多个选择器混合在一起使用时，可以通过计算权重来判断谁的优先级最高。权重的计算规则：首先计算选择器中有多少个id，id多的选择器优先级最高；如果id个数一样，那么再看类名的个数，类名多个优先级高；如果类名个数一样，那么标签名个数多的优先级高；如果都一样，那么谁的位置靠后，取谁的值。</p><h2 id="CSS属性值"><a href="#CSS属性值" class="headerlink" title="CSS属性值"></a>CSS属性值</h2><h3 id="1-文本属性"><a href="#1-文本属性" class="headerlink" title="1.文本属性"></a>1.文本属性</h3><h4 id="1-1-中文字间距-字母间距-单词间距"><a href="#1-1-中文字间距-字母间距-单词间距" class="headerlink" title="1.1 中文字间距 字母间距  单词间距"></a>1.1 中文字间距 字母间距  单词间距</h4><p>1）Letter-spacing用来设置中文字间距和字母间距。<br>2）word-spacing 用来设置英文单词的间距。</p><h4 id="1-2-text-align"><a href="#1-2-text-align" class="headerlink" title="1.2 text-align"></a>1.2 text-align</h4><p><code>text-align：center</code>可以设置块级元素内文本和图片的水平居中<br><strong>注：内联元素之间的间距是由于换行导致的。</strong></p><h4 id="1-3-font"><a href="#1-3-font" class="headerlink" title="1.3 font"></a>1.3 font</h4><h5 id="1-3-1-font字体大小单位"><a href="#1-3-1-font字体大小单位" class="headerlink" title="1.3.1 font字体大小单位"></a>1.3.1 font字体大小单位</h5><p>font属性简写至少要包含 font-family 和font-size属性。如：font：12px “微软雅黑”;<br>Em值的大小是以当前文档中font-size的大小为参考点的，果font-size为16px，则1em = 16px，如果font-size为20px则1em = 20px。<br>特殊情况：当给font-size取值以em为单位时，则此时计算的标准是以父元素font-size为基础的。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*css:*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  p&#123;font-size:14px&#125;</span><br><span class="line">  span&#123;font-size:0.8em;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html:*/</span><br><span class="line">  &lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-3-2-中文英文单独设置字体"><a href="#1-3-2-中文英文单独设置字体" class="headerlink" title="1.3.2 中文英文单独设置字体"></a>1.3.2 中文英文单独设置字体</h5><p>  中文字体里边都包含了英文，英文字体里边没有包含中文，也就是说中文字体可以处理英文，而英文字体不能处理中文，所以如果想要中英文分别单独设置字体，需要采用以下格式：<br>Font—family:”Times New Roman”,”微软雅黑”,将英文字体写在前边，中文字体写在后边作为备选方案。<br>常用字体 中文：宋体/黑体/微软雅黑 英文：Times New Roman / Arial</p><h4 id="1-4-文本垂直居中"><a href="#1-4-文本垂直居中" class="headerlink" title="1.4 文本垂直居中"></a>1.4 文本垂直居中</h4><p>文字在行高中默认是垂直居中的，我们经常将盒子的高度和行高设置一样，那么这样就可以保证单行文字在盒子中是垂直居中的，简而言之：要想单行文字在盒子中垂直居中，那么只需要设置line-height为盒子的height值即可。</p><h5 id="1-4-1-单行文本的垂直居中"><a href="#1-4-1-单行文本的垂直居中" class="headerlink" title="1.4.1 单行文本的垂直居中"></a>1.4.1 单行文本的垂直居中</h5><p>通过设置父元素的height和line-height高度一致来实现，(height该元素的高度，line-height：顾名思义，行高 指在文本中，行与行基线间的距离)，line-height与font-size的计算值之差，在css中称为行间距，分为两半，分别加到一个文本行内容的顶部和底部。</p><h5 id="1-4-2-多行文本及图片的垂直居中"><a href="#1-4-2-多行文本及图片的垂直居中" class="headerlink" title="1.4.2 多行文本及图片的垂直居中"></a>1.4.2 多行文本及图片的垂直居中</h5><p><strong>方法一：</strong><br>使用插入 table  (包括tbody、tr、td)标签，同时设置 vertical-align：middle。<br>css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*Html*/</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;看我是否可以居中。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    height:300px;</span><br><span class="line">    background:#ccc;</span><br><span class="line">    display:table-cell;/*IE8以上及Chrome、Firefox*/</span><br><span class="line">    vertical-align:middle;/*IE8以上及Chrome、Firefox*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-文本在容器中自动换行"><a href="#1-5-文本在容器中自动换行" class="headerlink" title="1.5 文本在容器中自动换行"></a>1.5 文本在容器中自动换行</h4><p><code>word-break:break-all;</code> 例如div宽200px，它的内容就会到200px自动换行，如果该行末端有个英文单词很长（congratulation等），它会把单词截断，变成该行末端为conra(congratulation的前端部分)，下一行为tulation（conguatulation）的后端部分了。</p><p> <code>word-wrap:break-word;</code> 例子与上面一样，但区别就是它会把congratulation整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断掉的。</p><h3 id="2-background"><a href="#2-background" class="headerlink" title="2. background"></a>2. background</h3><p><code>background-image:url();</code>设置元素背景图片</p><p><code>background-repeat</code>: repeat(默认) repeat-x repeat-y no-repeat</p><p><code>background-position:</code>水平方向 垂直方向;有两种取值方式，分别为具体的方位名词和像素如下：<br>具体的方位名词：水平方向(left center right),垂直方向(top center bottom)<br>具体的像素:浏览器的XY坐标系，X轴向右为正，Y轴向下为正。</p><p><code>background-attachment:fixed</code>(不会随着滚动条滚动)、 scroll(默认取值)</p><p><strong>背景属性缩写的格式:background:background-color  background-image  background-repeat background-attachment  Backgroud-position</strong></p><h3 id="3-CSS-Reset"><a href="#3-CSS-Reset" class="headerlink" title="3.CSS Reset"></a>3.CSS Reset</h3><p>在实际项目开发中我们经常需要清空浏览器给元素设置的默认值，常见的比如margin padding等，在百度中查找YUI CSS Reset或者输入网址:<br><strong><a href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css</a></strong><br>复制其中的内容，粘贴进我们项目的reset.css文件即可。</p><h3 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h3><h4 id="4-1-box-sizing"><a href="#4-1-box-sizing" class="headerlink" title="4.1 box-sizing"></a>4.1 box-sizing</h4><p>盒子元素的宽度 = border-left+padding-left+content-width+padding-right+border-right<br>盒子元素的高度 =border-top+padding-top+content-height+padding-bottom+border-bottom<br>因此假如一个DIV的初始大小为100px*100px，那么加入border或者padding会改变盒子元素自身的大小，从而影响整个网页的布局，如果需要盒子的宽高保持不变，那么需要相应的减少内容的大小，我们可以通过设置属性：<br><code>box-sizing:border-box;</code>,让其自动适应，保持宽高不变。</p><h4 id="4-2-margin"><a href="#4-2-margin" class="headerlink" title="4.2 margin"></a>4.2 margin</h4><p>Margin穿透现象：如果两个盒子是嵌套关系，那么设置内部盒子的margin-top值，外部盒子的margin-top值会被改变，这种情况我们称之为margin穿透现象。解决办法有两种：<br><strong>1)</strong>  给外边的盒子设置边框。<br><strong>2)</strong>     控制嵌套关系盒子之间的距离，首先应该考虑外边盒子的padding属性，其次考虑内层盒子的margin属性。<br><strong>3)</strong>  <code>overflow:hidden;</code></p><h4 id="4-3-块级元素水平居中"><a href="#4-3-块级元素水平居中" class="headerlink" title="4.3 块级元素水平居中"></a>4.3 块级元素水平居中</h4><p>在嵌套关系的盒子中，我们可以通过设置内层盒子的<code>margin:0 auto;</code>让内层盒子在外边的盒子水平居中，margin的auto取值只对水平方向上有效，对垂直方向上是无效的。</p><h3 id="5-浮动流"><a href="#5-浮动流" class="headerlink" title="5.浮动流"></a>5.浮动流</h3><p><strong>1&gt;</strong> 浮动流不区分 块级元素/行内元素/行内块级元素，无论块级元素/行内元素/行内块级元素都可以水平排版。<br><strong>2&gt;</strong> <strong>浮动流中无论块级元素/行内元素/行内块级元素都可以设置宽高。</strong><br><strong>3&gt;</strong> <strong>当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。</strong><br><strong>4&gt;</strong>设置浮动后，盒子的margin属性不会失效。<br><strong>5&gt;</strong> 浮动元素贴靠现象<br>如果父元素的宽度能够显示所有浮动元素, 那么浮动的元素会并排显示; 如果父元素的宽度不能显示所有浮动元素, 那么会从最后一个元开始往前贴靠, 如果贴靠了前面所有浮动元素之后都不能显示, 最终会贴靠到父元素的左边或者右边。<br><strong>6&gt;</strong>浮动元素字围现象<br>浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象。</p><h3 id="6-清除浮动"><a href="#6-清除浮动" class="headerlink" title="6.清除浮动"></a>6.清除浮动</h3><p><strong>方式一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box1::after&#123;</span><br><span class="line">  Content:&quot;&quot;</span><br><span class="line">  Display:block;</span><br><span class="line">  Height:0;</span><br><span class="line">  Visibility:hidden;</span><br><span class="line">  Clear:both;</span><br><span class="line">&#125;</span><br><span class="line">/*这种方式在IE6中显示不正常，需要加入额外的属性*/</span><br><span class="line">.box1&#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><pre><code>overflow:hidden;</code></pre><p><strong>注：Overflow:hidden属性的作用有以下几点：</strong><br>        <strong>1.</strong>将超出标签范围的内容才减掉。<br>        <strong>2.</strong>清除浮动。内部盒子浮动后，外部盒子的高度无法被撑起，会缩成一条，这时候对父元素使用clear：both是无法清除浮动的影响的，需要设置overflow：hidden才行。<br>       <strong>3</strong>.外部盒子设置overflow：hidden；保证了内部盒子在设置了margin-top属性后外部盒子的margin-top不会发生变化。</p><h3 id="7-定位流"><a href="#7-定位流" class="headerlink" title="7.定位流"></a>7.定位流</h3><p>定位流分为：相对定位、绝对定位、固定定位、静态定位四种类型。</p><h4 id="7-1-相对定位"><a href="#7-1-相对定位" class="headerlink" title="7.1 相对定位"></a>7.1 相对定位</h4><p>相对定位就是相对于自己以前在标准路中的位置作为参考点进行移动，语法如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position：relative；</span><br><span class="line">Top:</span><br><span class="line">Bottom:</span><br><span class="line">Left:</span><br><span class="line">Right:</span><br></pre></td></tr></table></figure><br><strong>1&gt;</strong>    相对定位不会脱离标准流，会继续在标准流中占用一份空间。<br><strong>2&gt;</strong>在相对定位中同一个方向上的定位属性只能使用一个。<br><strong>3&gt;</strong>    由于相对定位是不脱离标准流的，所以相对定位中区分块级 行内 行内块级元素。<br><strong>4&gt;</strong>给设置相对定位的元素设置margin属性，是给元素以前的位置设置margin，并不是给定位之后的元素设置margin。</p><h4 id="7-2-绝对定位"><a href="#7-2-绝对定位" class="headerlink" title="7.2 绝对定位"></a>7.2 绝对定位</h4><p><strong>1&gt;</strong>绝对定位的元素是脱离标准流的<br><strong>2&gt;</strong>绝对定位中是不区分行内 块级 行内块级元素<br><strong>3&gt;</strong>参考点：默认情况下所有的绝对定位元素，无论是否有祖先元素，对会以body 作为参考点；<br>  &nbsp;  &nbsp; &nbsp;      a. 如果一个绝对定位有祖先元素，并且这个祖先元素也是定位流，并且这个定位流只能是：绝对定位、相对定位、固定定位。那么这个绝对定位的元素会以这个祖先元素作为参考点。<br>   &nbsp;  &nbsp; &nbsp;      b. 如果绝对定位有多个祖先元素，并且多个祖先元素均为定位流，那么这个绝对定位的元素会以离他最近的元素为参考点。<br><strong>4&gt;</strong>如果一个绝对定位的元素以body为参考点，其实是以网页首屏宽度为参考点，而不是以整个网页的宽度和高度为参考点。<br><strong>5&gt;</strong> 绝对定位的元素会忽略祖先元素的padding值。</p><h4 id="7-3-子绝父相"><a href="#7-3-子绝父相" class="headerlink" title="7.3 子绝父相"></a>7.3 子绝父相</h4><p>这是通常情况下设置绝对定位元素的方式，将要设置绝对定位元素的父元素设置为相对定位，然后自身设置为绝对定位，那么久会以父元素作为参照点进行偏移，俗称“子绝父相”.<br>如何让绝对定位的元素在父元素中水平居中，只需要设置绝对定位元素的left：50%，然后再设置绝对定位的元素margin-left，负的元素宽度的一半px; </p><h4 id="7-4-不定宽块级元素水平居中"><a href="#7-4-不定宽块级元素水平居中" class="headerlink" title="7.4 不定宽块级元素水平居中"></a>7.4 不定宽块级元素水平居中</h4><p>通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*Html代码*/</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">/*css代码*/</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    left:50%</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container ul&#123;</span><br><span class="line">    list-style:none;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    </span><br><span class="line">    position:relative;</span><br><span class="line">    left:-50%;</span><br><span class="line">&#125;</span><br><span class="line">.container li&#123;float:left;display:inline;margin-right:8px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-3-固定定位"><a href="#7-3-固定定位" class="headerlink" title="7.3 固定定位"></a>7.3 固定定位</h4><p> 固定定位：可以让某个盒子不随着网页滚动条而滚动。<br>固定定位的元素是脱离标准流的，不会占用标准流的空间，固定定位和绝对定位一样不区分行内/块级 /行内块级元素。<br><strong>注：IE6不支持position：fixed.</strong></p><h4 id="7-4-z-index"><a href="#7-4-z-index" class="headerlink" title="7.4 z-index"></a>7.4 z-index</h4><p>默认情况下，所有设置了position属性的元素都有一个Z-index属性，默认取值为0，z-index属性的作用是专门用于控制定位流元素的覆盖关系的。</p><p>1&gt;默认情况下定位流的元素会盖住标准流的元素。<br>2&gt;定位里的元素后面编写的会盖住前面编写的元素。<br>3&gt;如果定位流的元素设置了z-index属性，那么谁的z-index属性大，谁就显示在上面。</p><p><strong>从父现象：</strong><br>如果两个元素的父元素都没有设置z-index属性，那么谁的z-index属性大就显示在上面</p><p>如果两个元素的父元素设置了z-index属性，那么他们自身的z-index属性将失效。</p><h4 id="7-5-隐形改变display类型"><a href="#7-5-隐形改变display类型" class="headerlink" title="7.5 隐形改变display类型"></a>7.5 隐形改变display类型</h4><p>当元素设置一下两个句之一：</p><ol><li>position:ablsolute</li><li>float:left或right<br>简单来说，只要html代码中出现以上两句之一，元素的display显示类型就自动变为display：inline-block的方式，当然就可以设置元素的width和height了，<strong>且默认宽度不占满父元素</strong>。</li></ol><h3 id="8-a标签伪类选择器"><a href="#8-a标签伪类选择器" class="headerlink" title="8 .a标签伪类选择器"></a>8 .a标签伪类选择器</h3><p>:link 修改从未被访问过状态下的样式<br>:visited 修改被访问过的状态下的样式<br>:active 修改鼠标长按状态下的样式<br>:hover 修改鼠标悬停在a标签上的状态</p><p>注意点：a标签的伪类选择器一起出现，那么有严格的顺序要求，必须按照这个顺序：<br><strong><em>link  visited  hover  active</em></strong></p><h3 id="9-CSS3圆角"><a href="#9-CSS3圆角" class="headerlink" title="9.CSS3圆角"></a>9.CSS3圆角</h3><p>Border-radius是向元素添加圆角边框。使用方式：<br><code>Border-radius:10px;</code>   /<em>所有角都使用半径为10px的圆角</em>/<br><code>Border-radius:5px 4px 3px 2px;</code>四个半径值分别对应左上、右上、右下、左下</p><p><strong>1.实心上半圆</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:50px;/*是width的一半*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实心圆</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:100px;/*与width设置一致*/</span><br><span class="line">    width:100px;</span><br><span class="line">    background:#9da;</span><br><span class="line">    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="10-盒子边框阴影"><a href="#10-盒子边框阴影" class="headerlink" title="10.盒子边框阴影"></a>10.盒子边框阴影</h3><p>Box-shadow是向盒子添加阴影，支持添加一个或多个，如果需要添加多个阴影只需要用逗号隔开即可。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box-shadow:X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</span><br></pre></td></tr></table></figure><p><strong>X轴偏移量：</strong> 必选参数，值可以正负，正值表示向右偏移，负值向左<br><strong>Y轴偏移量：</strong> 必选参数，值可以正负，正值表示向下偏移，负值向上。<br><strong>阴影模糊半径：</strong> 可选参数，值只能为正，如果值为0，代表阴影没有模糊效果。<br><strong>阴影扩展半径：</strong> 可选参数，值可以为正负，越大阴影面积越大。<br><strong>投射方式：</strong> 其中投影方式默认为外阴影方式，可以设置为inset让其显示为内部阴影。</p><h3 id="11-实现双列布局一列固定宽度，另外一列自适应的方式。"><a href="#11-实现双列布局一列固定宽度，另外一列自适应的方式。" class="headerlink" title="11. 实现双列布局一列固定宽度，另外一列自适应的方式。"></a>11. 实现双列布局一列固定宽度，另外一列自适应的方式。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*HTML*/</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*CSS*/</span><br><span class="line">.main&#123;</span><br><span class="line">width:100%;</span><br><span class="line">height:300px;</span><br><span class="line">background:darkred;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left&#123;</span><br><span class="line"> width:200px;</span><br><span class="line"> height:300px;</span><br><span class="line"> background:blue;</span><br><span class="line"> position:absolute;</span><br><span class="line"> left:0px;</span><br><span class="line"> top:0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right&#123;</span><br><span class="line">margin-left:210px;</span><br><span class="line">height:300px;</span><br><span class="line">background:orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html学习笔记整理</title>
      <link href="/2017/02/22/html/"/>
      <url>/2017/02/22/html/</url>
      
        <content type="html"><![CDATA[<h2 id="引用标签"><a href="#引用标签" class="headerlink" title="引用标签"></a>引用标签</h2><p>引用标签会自动对其中的内容加入双引号，有单行文本和长段文本两种方式：</p><pre><code>&lt;q&gt;引用标签&lt;/q&gt; //适用单行文本&lt;blockquote&gt;引用标签&lt;/blockquote&gt; //长段文本</code></pre><h2 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h2><p>在html中输入多个空格是不起作用的，并且换行也会被当做一个空格来看待，如果需要多个空格请使用实体字符，如:<code>&amp;nbsp;</code></p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><pre><code>&lt;address&gt;地址&lt;/address&gt; //显示地址</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>&lt;code&gt;代码&lt;/code&gt;  //显示程序代码&lt;pre&gt;大段代码&lt;/pre&gt; //显示大段代码</code></pre><h2 id="表格摘要"><a href="#表格摘要" class="headerlink" title="表格摘要"></a>表格摘要</h2><p>  摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：</p><pre><code>&lt;table summary=&quot;表格简介文本&quot;&gt;&lt;/table&gt;</code></pre><h2 id="使用mailto在网页中连接Email地址"><a href="#使用mailto在网页中连接Email地址" class="headerlink" title="使用mailto在网页中连接Email地址"></a>使用mailto在网页中连接Email地址</h2><pre><code>&lt;a href=&quot;mailto:yy@imooc.com?subject=&#39;观了不起的盖茨比有感&#39;&amp;body=&#39;你好，对此评论有些想法&#39;&quot;&gt;发送邮件给我&lt;/a&gt;</code></pre><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>用于绑定input在用户点击label标签的文字后即可聚焦input，有两种绑定方式。<br><strong>方式一:</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">     &lt;label for=”account”&gt;账号&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text”  id=”account”/&gt;</span><br><span class="line">     &lt;label for=”pwd”&gt;密码&lt;/label&gt;</span><br><span class="line">     &lt;input type=”text” id=”pwd”&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p><strong>方式二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot; &quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  账号:&lt;input type=”text”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  密码:&lt;input type=”password”/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="HTML5-DTD文档类型声明"><a href="#HTML5-DTD文档类型声明" class="headerlink" title="HTML5 DTD文档类型声明"></a>HTML5 DTD文档类型声明</h2><pre><code>&lt;!DOCTYPE html&gt; //必须位于html文档的第一行</code></pre><span id="more"></span><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p><strong>width:</strong>设置图片的宽度</p><p><strong>height：</strong>设置图片的高度</p><p><em>注： 如果img标签没有指定需要显示的图片的宽高，那么系统会按照图片默认的宽高来显示。想要保持img图片原图的宽高比，只需要设置img宽度和高度其中之一，另外一个属性会根据原图的宽高比自动计算得出。</em></p><p><strong>title:</strong>当鼠标悬停在图片上时，弹出的描述狂中显示的内容。</p><p><strong>alt(alternate):</strong>当需要显示的图片找不到时，显示的替代的文字内容。</p><h2 id="br"><a href="#br" class="headerlink" title="br"></a>br</h2><p>&nbsp;&nbsp;&nbsp;br标签用于换行，多个br标签可以连续使用，使用了多少个br标签就会换多少行，由于html的作用就是给文本添加语义，而br标签的语义是不另起一个段落换行，而在企业开发中一般情况下需要换行都是因为需要另起一个段落，所以在企业开发中很少使用br标签，换行另起段落一般用P标签。</p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p> base标签专门用来统一指定当前网页中所有的a标签的打开方式,base标签必须写在head标签之间,格式为：</p><pre><code>&lt;base target=”_blank”&gt;               //必须位于head之间</code></pre><p><em>注：如果即在base中指定了target又在a标签中指定了target，那么浏览器会按照a标签中指定方式的来执行。</em></p><h3 id="假链接"><a href="#假链接" class="headerlink" title="假链接"></a>假链接</h3><p>为a标签的href属性分配一个#或者JavaScript，以实现特定的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#”&gt;返回顶部&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”javascript:”&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>锚点是文档中某行的一个记号，类似于书签，用于链接到文档中的某个位置。当定义了锚点后，我们可以创建直接跳至该锚点（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 创建锚点需要以下几个步骤：<br>1) 给需要定位的目标标签添加一个ID属性。<br>2) 告诉a标签你需要转到的目标标签。<br>3) 格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”#target”&gt;跳转到目标&lt;/a&gt;</span><br><span class="line">&lt;h1 id=”target”&gt;我是目标&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><em>注：使用这种方式跳转是没有过渡动画的，一下就跳转到了指定位置  a标签除了可以跳转到当前界面的指定位置，还可以直接跳转到其他界面的指定位置。</em></p><h2 id="定义列表-dl-definition-list"><a href="#定义列表-dl-definition-list" class="headerlink" title="定义列表 dl(definition list)"></a>定义列表 dl(definition list)</h2><p>常用于网站底部的信息、图文混排等。格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;   //definition title 定义列表中的标题</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;  //definition description 定义列表标题的描述</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格摘要-1"><a href="#表格摘要-1" class="headerlink" title="表格摘要"></a>表格摘要</h3><p>摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法表示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table summary=”表格简介文本”&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure></p><h3 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h3><p>表格标题永远处于表格的水平中心位置，语法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;caption&gt;</span><br><span class="line">     &lt;h2&gt;表格标题&lt;/h2&gt;</span><br><span class="line">  &lt;/caption&gt;                 //表格标题</span><br><span class="line">  &lt;thead&gt;&lt;/thead&gt;            //表格头</span><br><span class="line">  &lt;tbody&gt;&lt;/tbody&gt;            //表格内容体</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="细线表格"><a href="#细线表格" class="headerlink" title="细线表格"></a>细线表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  Table&#123;</span><br><span class="line">Padding:0.1px;</span><br><span class="line">Background-Color:steelblue;  //定义边框的颜色</span><br><span class="line">Width:650px;</span><br><span class="line">Height:40px;</span><br><span class="line">Font:16px “微软雅黑”;</span><br><span class="line">Text-align:center;</span><br><span class="line">  &#125;</span><br><span class="line">  Table tr&#123;</span><br><span class="line">    Background-Color:white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h2><p>给input输入框绑定待选项列表，格式如下：<br>先定义一个datalist列表项，给它分配一个唯一的ID “cars”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;datalist  id=”cars”&gt;</span><br><span class="line">    &lt;option&gt;奔驰&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;；路虎&lt;/option&gt;</span><br><span class="line">&lt;option&gt;Jeep&lt;/option&gt;</span><br><span class="line">&lt;option&gt;劳斯莱斯&lt;/option&gt;</span><br><span class="line">&lt;option&gt;宝马&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure><p>然后给输入框添加一个属性list，值填写刚才定义列表的id值”cars”。<br>请输入你的车型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=”text” list=”cars”/&gt;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>可以通过给option标签添加一个selected属性来制定列表的默认选中项;可以给option进行分组，使用optgroup label标签的名字显示了分组的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line"> &lt;optgroup label=”北京”&gt;</span><br><span class="line"> &lt;option&gt;西城区&lt;/option&gt;</span><br><span class="line"> &lt;option selected=”selected”&gt;朝阳区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;通州区&lt;/option&gt;</span><br><span class="line"> &lt;/optgroup&gt;</span><br><span class="line"> &lt;optgroup label=”广州&gt;</span><br><span class="line"> &lt;option&gt;天河区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;越秀区&lt;/option&gt;</span><br><span class="line"> &lt;option&gt;黄浦区&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="textArea"><a href="#textArea" class="headerlink" title="textArea"></a>textArea</h2><p>Textarea通过css的属性resize:none可以禁止用户自由拉伸textarea</p><h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p><strong>src:</strong>用于告诉video标签需要播放的视频地址。<br><strong>autoplay：</strong>用于告诉video标签是否需要自动播放视频 autoplay = “autoplay”。<br><strong>controls:</strong> 用于告诉video标签是否显示控制条 controls = “controls”。<br><strong>poster:</strong> 用于设置视频在播放之前，显示的图片。<br><strong>loop:</strong> 一般用于广告视频，用于告诉video标签播放完毕后是否需要循环播放。Loop = “loop”。<br><strong>preload:</strong> 预加载视频，但是需要注意preload和autoplay相冲。<br><strong>muted:</strong> 静音   muted = “muted”。<br><strong>width/height：</strong>二者只设置一个，保持视频的宽高比</p><p>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式，但是显然所有浏览器都通过video标签播放视频有一个前提条件，那就是浏览器必须支持H5，可以通过一个JS框架叫做<strong>html5demia</strong>来实现兼容。</p><p>video的第二种格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">&lt;source src=”video/1.webm” type=”video/webm”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/2.mp4” type=”video/mp4”&gt;&lt;/source&gt;</span><br><span class="line">&lt;source src=”video/3.ogg” type=”video/ogg”&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="marquee"><a href="#marquee" class="headerlink" title="marquee"></a>marquee</h2><p>Marquee标签虽然不是w3c标准的标签，，但是各大浏览器对其支持很好。Marquee标签是一个内联块级元素，主要用于实现类似于跑马灯的效果。格式为：</p><pre><code>&lt;marquee&gt;内容&lt;/marquee&gt;</code></pre><p><strong>direction(left right up down):</strong> 设置内容滚动的方向<br><strong>scrollamount：</strong>设置滚动的速度，值越大越快<br><strong>loop：</strong>设置滚动次数，默认为-1，也就是无限滚动<br><strong>behavior：</strong>设置滚动类型，slide，滚动到边界即停止，alternate，滚动到边界即弹回。</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2017/02/09/blog/"/>
      <url>/2017/02/09/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="http://i1.piimg.com/567571/f63d2030ab646842.png" alt><br><a href="hexo.io">Hexo</a>是一个快捷、简单、功能强大的个人博客框架，使用Node.js下载与安装，上百个文件仅需几秒就可以安装完毕;Hexo的页面使用Markdown语法，简洁高效;通过简单的命令即可发布到网站，支持发布到GitHub Pages Heroku和其他站点;同时Hexo拥有丰富强大的插件系统，可以根据个人需要进行安装。本文主要针对技术开发人员如何快速的搭建Hexo博客做一个详尽的教程，也是对自己在搭建博客的过程中遇到的问题进行总结，避免以后的小伙伴踩坑。本文从五个方面进行讲解，分别为：</p><ul><li>环境部署</li><li>HEXO安装与常用命令</li><li>个性化设置</li><li>HEXO部署Github</li><li><p>定制化个性域名</p><span id="more"></span><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h2 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1.Node.js"></a>1.Node.js</h2><p>首先我们需要安装Node.js，点击进入<a href="https://nodejs.org/en/">node.js官网</a>，按照通用的安装方式下载安装即可。Node.js主要用于生成静态界面。</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><p>这里说的git实则是为了使用git指令，我们的git使用一般有两种方式，一种是图形化界面（GUI），另一种是通过命令行，我们这里要使用的是后者，点击<a href="http://git-scm.com/downloads">这里</a>进入git的下载网站下载git的安装包。作用：把本地的hexo内容提交到github上去.</p><h2 id="3-GitHub配置"><a href="#3-GitHub配置" class="headerlink" title="3.GitHub配置"></a>3.GitHub配置</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>如果你没有GitHub账号，请到<a href="https://github.com/">这里</a>进行注册申请，详细注册过程略。</p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p>点击右上角的”+”选择New respository 建立新仓库，如图：<br><img src="http://p1.bqimg.com/567571/b85d00d61646ce19.png" alt><br>接下来需要配置仓库信息，如图：<br><img src="http://p1.bpimg.com/567571/8ddca7070ac1d6d3.png" alt><br>这里我们需要填写Repository name，注意这里的命名规范，如果我们要把这个仓库作为我们的个人博客，必须遵照以下规范命名：<strong>github用户名.github.io</strong>,点击Create repository即可。</p><h3 id="生成添加秘钥"><a href="#生成添加秘钥" class="headerlink" title="生成添加秘钥"></a>生成添加秘钥</h3><p>本机生成秘钥是为了方便以后更新博客不用每次都输入用户名密码，这个根据个人需要，不是必须操作。<br>在终端输入：</p><p>  $ ssh-keygen -t rsa -C “Github的注册邮箱地址”<br>待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，这两个文件位于：<br><img src="http://p1.bpimg.com/567571/ab706a277d27e1cd.png" alt><br>这个目录下，用文本编辑器(notepad++ 、Sublime Text)打开id_rsa.pub这个文件,全选复制里边的内容，然后打开<a href="https://github.com/settings/ssh">网址</a>,如图:<br><img src="http://i1.piimg.com/567571/15b94723da693034.png" alt></p></li></ul><p>点击 New SSH key:<br><img src="http://i1.piimg.com/567571/efd23501f3d72f7b.png" alt><br>Title随便起个名字，将刚才复制的内容粘贴进Key中，然后点击Add SSH Key，这样生成的秘钥就添加完毕了，在今后更新博客，不必每次都输入用户名密码验证登录。</p><h3 id="为Hexo安装Git插件"><a href="#为Hexo安装Git插件" class="headerlink" title="为Hexo安装Git插件"></a>为Hexo安装Git插件</h3><p>安装 hexo-deployer-git，否则会报 ERROR Deployer not found: git 的错误。</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>至此，环境全部配置完毕，接下来我们讲Hexo的安装，目录结构与常用命令。</p><h1 id="Hexo安装与常用命令"><a href="#Hexo安装与常用命令" class="headerlink" title="Hexo安装与常用命令"></a>Hexo安装与常用命令</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。执行如下命令安装Hexo：<br>定位blog安装位置：</p><pre><code>$ cd 文件夹路径$ npm install hexo-cli -g</code></pre><p>安装好hexo以后，在终端输入：</p><pre><code>$ hexo</code></pre><p>若出现下图，说明Hexo安装成功：<br><img src="http://i1.piimg.com/567571/fe00cc2a41c9c40b.png" alt></p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><pre><code>$ hexo init //初始化博客$ npm install //node.js的命令，根据博客的dependencies配置安装所有的依赖包</code></pre><p>完成后我们可以看到Blog文件夹下的文件结构是这样的：<br><img src="http://p1.bqimg.com/567571/cf1c9ba7e9372f95.png" alt></p><h3 id="主目录结构："><a href="#主目录结构：" class="headerlink" title="主目录结构："></a>主目录结构：</h3><pre><code>主目录1  ├── .deploy       #需要部署的文件2  ├── node_modules  #Hexo插件3  ├── public        #生成的静态网页文件4  ├── scaffolds     #模板5  ├── source        #博客正文和其他源文件，CNAME也放这里6  | ├── _drafts     #草稿7  | ├── _posts      #文章8  ├── themes        #主题9  ├── _config.yml   #全局配置文件10 └── package.json</code></pre><p>我们经常需要操作的目录为source &gt; _post(文章目录),themes(主题目录),config.yml(全局配置文件)。</p><h3 id="主题目录结构："><a href="#主题目录结构：" class="headerlink" title="主题目录结构："></a>主题目录结构：</h3><pre><code>主目录1  ├── languages          #国际化2  |   ├── default.yml    #默认3  |   └── zh-CN.yml      #中文4  ├── layout             #布局5  |   ├── _partial       #局部的布局6  |   └── _widget        #小挂件的布局7  ├── script             #js脚本8  ├── source             #源代码文件9  |   ├── css            #CSS10 |   |   ├── _base      #基础CSS11 |   |   ├── _partial   #局部CSS12 |   |   ├── fonts      #字体13 |   |   ├── images     #图片14 |   |   └── style.styl #style.css15 |   ├── fancybox       #fancybox16 |   └── js             #js17 ├── _config.yml        #主题配置文件18 └── README.md          #主题介绍</code></pre><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><pre><code>$ npm install hexo-cli -g           //安装Hexo$ hexo init                         //初始化博客$ npm install                       //安装依赖包$ hexo server                       //本地启动$ npm update hexo -g                //升级 $ hexo new &quot;文件名&quot;                  //新建文章$ hexo p                            //发布$ hexo generate                     //生成静态文件$ hexo generate -watch              //监视文件变动$ hexo deploy                       //部署$ hexo d -g                         //同上$ hexo g -d                         //同上$ hexo new page &quot;pageName&quot;          //新建页面</code></pre><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><h2 id="配置博客信息"><a href="#配置博客信息" class="headerlink" title="配置博客信息"></a>配置博客信息</h2><p>博客初始化完毕后，我们需要对博客做一些详细的配置信息，以及个性化设置，主要设置的内容有：博客信息，语言、时区、主题样式、博客目录结构、部署设置(deploy)、插件等。</p><h3 id="全局配置文件-config-yml"><a href="#全局配置文件-config-yml" class="headerlink" title="全局配置文件_config.yml"></a>全局配置文件_config.yml</h3><p>使用sublime Text打开根目录下的config.yml文件，首先我们要对站点信息进行设置:</p><h4 id="网站信息："><a href="#网站信息：" class="headerlink" title="网站信息："></a>网站信息：</h4><pre><code># Site        //站点信息title :       //博客名称subtilte:     //副标题description:  //站点描述信息ahthor:       //作者language:     //语言(zh-CN) *重要timezone:     //时区(Asia/Shanghai) *重要</code></pre><p><strong>注意：填写每一项内容时,:后边都要留一个空格再填写内容。</strong></p><h4 id="分页设置："><a href="#分页设置：" class="headerlink" title="分页设置："></a>分页设置：</h4><pre><code># Pagination## Set per_page to 0 to disable paginationper_page:5     //每页显示文章数pagination_dir: page</code></pre><h4 id="主题设置："><a href="#主题设置：" class="headerlink" title="主题设置："></a>主题设置：</h4><pre><code>#  Extensions## Plugins:https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next        //主题名称</code></pre><h4 id="部署设置："><a href="#部署设置：" class="headerlink" title="部署设置："></a>部署设置：</h4><pre><code>deploy:type: git          //类型repo:              //Github仓库地址branch: master     //项目分支，默认使用主分支即master</code></pre><h2 id="设置个性化主题"><a href="#设置个性化主题" class="headerlink" title="设置个性化主题"></a>设置个性化主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>首先找到我们喜欢的<a href="https://hexo.io/themes/">主题</a>，本篇文章以Next主题为例，将终端定位到Blog根目录，将Next主题从github clone到本地。</p><pre><code>$ cd:d/Blog $ git clone https://github.com/iissnan/hexo-theme-next themes/next   </code></pre><p>稍等片刻，Next主题会自动下载到Blog &gt;themes文件夹下。</p><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改config.yml全局配置文件，找到theme字节，修改值为：next</p><pre><code>theme: next</code></pre><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><h4 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h4><p>打开theme &gt; next &gt;_config.yml，定位到menu,hexo博客框架默认有/home 、/archives、/tags三个一级页面。如果我们要增加其他的页面需要对这里的配置文件进行修改。</p><pre><code>menu：  home: /                          //主页(默认打开)  #categories: /categories         //分类  #about: /about                   //关于  archives: /archives              //文章(默认打开)  tags: /tags                      //标签(默认打开)  #sitemap: /sitemap.xml           //站点地图  #commonweal: /404.html           //公益404</code></pre><p>我们需要增加哪个页面只需要把前边的#注释去掉即可。然后在终端中新建刚才添加的页面</p><pre><code>hexo new page &quot;categories&quot;          //这里用categories举例</code></pre><p>编辑站点的source/categories/index.md，添加</p><pre><code>---title: categoriesdate: 2017-02-09 17:52:11type: &quot;categories&quot;             //添加类型comments: false                //禁用评论---</code></pre><p>保存后<code>hexo s</code>,打开<a href="http://localhost:4000/查看效果。">http://localhost:4000/查看效果。</a></p><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>打开themes &gt;next &gt;languages 找到zh-Hans.yml，重命名为zh-CN.yml,或者将全局配置文件_config.yml的languages设置为zh-Hans也可以。</p><h4 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h4><p>定位到menu_icons,这里储存了页面使用的图标信息，Next主题采用了FontAwesome的图标，直接使用FontAwesome的图标名称即可调用对应的图标文件,关于FontAwesome的详细信息点击<a href="http://fontawesome.io/icons/">这里</a>，选择自己喜欢的图标复制名称粘贴即可。</p><pre><code>menu_icons:                    //目录图标配置enable: true                   //是否启用 #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home                    //主页 about: user                   //关于 categories: th                //分类 schedule: calendar            //进度 tags: tags                    //标签 archives: archive             //文章 sitemap: sitemap              //站点地图 commonweal: heartbeat</code></pre><h4 id="Scheme设置"><a href="#Scheme设置" class="headerlink" title="Scheme设置"></a>Scheme设置</h4><pre><code># Scheme Setting# ---------------------------------------------------------------# Schemes#scheme: Muse scheme: Mist#scheme: Pisces</code></pre><p>Next主题提供了三种样式，分别为Muse Mist Pisces，将样式前的#注释去掉即可启用该主题，同时只能启用一个。</p><h4 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h4><p>定位到social_icons，修改配置信息。</p><h4 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h4><p>定位倒sidebar，可以设置侧边栏的显示位置(左右),显示方式等。</p><h4 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h4><p>首先将我们的头像图片copy到themses &gt; next &gt; source &gt;images文件夹下，然后打开next主题下的_config.yml文件，定位到avatar。</p><pre><code>avatar: /images/头像文件名</code></pre><h1 id="Hexo部署GitHub"><a href="#Hexo部署GitHub" class="headerlink" title="Hexo部署GitHub"></a>Hexo部署GitHub</h1>]]></content>
      
      
      <categories>
          
          <category> Blog建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2017/02/08/hello-world/"/>
      <url>/2017/02/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>终于创建好了自己的HEXO博客，这是我的第一篇文章，以后要坚持记录!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
