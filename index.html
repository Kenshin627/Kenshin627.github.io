<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>KenShin</title>
  <meta name="author" content="KenShin">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KenShin"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.4.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">KenShin</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>Love Coding Love Life<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Keep and carry on.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/10/31/interface/" >interface</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-10-31  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1>
	
	</div>
  <a type="button" href="/2021/10/31/interface/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2021/10/31/typeScript类型系统/" >typeScript类型系统</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2021-10-31  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="typeScript类型系统"><a href="#typeScript类型系统" class="headerlink" title="typeScript类型系统"></a>typeScript类型系统</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>基本注解采用 <strong>:TypeAnnotation</strong>语法,在类型声明空间中可用的任何内容都可以用作类型注解</p>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 string、number、boolean 也可以被用作类型注解.</p>
<p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/1.png" alt="alt"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>针对数组的类型注解有两种方式 <strong>:TypeAnnotation[]</strong> 或者 <strong>Array&lt;TypeAnnotation&gt;</strong>,这两种方式是等价的<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/2.png" alt="alt"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>typeScript核心特性,合并众多类型声明至一个类型声明<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/3.png" alt="alt"></p>
<h3 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h3><p>内联类型能快速提供一个类型注解,不必为类型起单独的名称,然而,如果你发现需要多次使用相同的内联注解,应该把它重构为一个接口<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/4.png" alt="alt"></p>
<h3 id="联合类型-amp-交叉类型"><a href="#联合类型-amp-交叉类型" class="headerlink" title="联合类型 &amp; 交叉类型"></a>联合类型 &amp; 交叉类型</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型(|)"></a>联合类型(|)</h4><p>所期望的属性是众多类型之一,如字符串或字符串数组,本质上是类型的并集操作,这正是typeScript中联合类型的用途,使用 | 作标记.</p>
<p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/5.png" alt="alt"></p>
<h4 id="交叉类型-amp"><a href="#交叉类型-amp" class="headerlink" title="交叉类型(&amp;)"></a>交叉类型(&amp;)</h4><p>在 JavaScript 中， extend 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/6.png" alt="alt"></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型和数组很相似,表示一个已知元素数量和类型的数组,各元素的类型不必相同.可以把元组看成严格版型的数组<br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/7.png" alt="alt"><br><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/8.png" alt="alt"></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <strong>type SomeName = someValidTypeAnnotation</strong> 来创建别名：</p>
<p><img src="/2021/10/31/typeScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/9.png" alt="alt"></p>

	
	</div>
  <a type="button" href="/2021/10/31/typeScript类型系统/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/11/05/Asp-Net-Core-文件系统/" >Asp.Net Core 文件系统</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-11-05  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Asp-Net-Core-文件系统"><a href="#Asp-Net-Core-文件系统" class="headerlink" title="Asp.Net Core 文件系统"></a>Asp.Net Core 文件系统</h1><p>ASP.NET Core 具有很多针对文件读取的应用。比如我们倾向于采用JSON文件来定义配置，所以应用就会涉及针对配置文件读取。如果用户发送一个针对物理文件的HTTP请求，应用会根据指定的路径读取目标文件的内容并对请求予以响应。在一个ASP.NET Core MVC应用中，针对View的动态编译会涉及到根据预定义的路径映射关系来读取目标View文件。这些不同应用场景都会出现一个IFileProvider对象的身影，以此对象为核心的文件系统提供了统一的API来读取文件的内容并监控内容的改变。</p>
<h2 id="物理文件系统"><a href="#物理文件系统" class="headerlink" title="物理文件系统"></a>物理文件系统</h2><h3 id="IChangeToken"><a href="#IChangeToken" class="headerlink" title="IChangeToken"></a>IChangeToken</h3><p>由于IFileProvider提供了针对文件系统变换的监控功能，在.NET Core的世界里类似的功能大都利用一个IChangeToken对象来实现.从字面上理解的IChangeToken对象就是一个与某组监控数据关联的“令牌（Token）”，它能够在检测到数据改变的时候及时地对外发出一个通知。IChangeToken接口具有如下所示的三个成员。</p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider1.jpg" alt="alt"></p>
<ul>
<li><p><strong>HasChanged</strong>:如果关联的数据发生改变，HasChanged属性将变成True.</p>
</li>
<li><p><strong>ActiveChangeCallbacks</strong>:它表示当数据发生变化时是否需要主动执行注册的回调操作.</p>
</li>
<li><p><strong>RegisterChangeCallback</strong>:注册一个在数据发生改变时可以自动执行的回调，该方法会以一个IDisposable对象的形式返回注册对象，所以我们应该在适当的时机调用其Dispose方法解除注册的回调.</p>
</li>
</ul>
<h3 id="IFileProvider"><a href="#IFileProvider" class="headerlink" title="IFileProvider"></a>IFileProvider</h3><p>IFileProvider的接口定义如下图:</p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider2.jpg" alt="alt"></p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider3.jpg" alt="alt"></p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider4.jpg" alt="alt"></p>
<ul>
<li><p><strong>GetDirectoryContents</strong>:通过给定的路径遍历目录,返回一个由IFileInfo组成的集合.该接口有一个属性Exists,判断指定路径目录是否存在.</p>
</li>
<li><p><strong>IsDirectory</strong>:由GetDirectoryContents得到的集合中无论是目录还是文件,都会用IFileInfo来表示.判断是文件还是目录用属性IsDirectory来区分.</p>
</li>
<li><p><strong>GetFileInfo</strong>:获取指定路径下的文件.如果是目录或者不存在,则Exists属性返回false.</p>
</li>
<li><p><strong>Watch</strong>:监控指定文件的变化,如果产生变化,则调用注册的回调函数.如下图所示.</p>
</li>
</ul>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider5.jpg" alt="alt"></p>
<p>文件系统涉及的接口以及相互关系图.</p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider6.jpg" alt="alt"></p>
<h3 id="物理文件系统-1"><a href="#物理文件系统-1" class="headerlink" title="物理文件系统"></a>物理文件系统</h3><p>物理文件系统涉及的接口以及相互关系图</p>
<p><img src="/2019/11/05/Asp-Net-Core-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/IFileProvider7.jpg" alt="alt"></p>

	
	</div>
  <a type="button" href="/2019/11/05/Asp-Net-Core-文件系统/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/10/21/ASP-NET-Core-DI-服务消费/" >Asp.Net Core DI-服务消费</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-10-21  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Asp-Net-Core-DI-服务消费"><a href="#Asp-Net-Core-DI-服务消费" class="headerlink" title="Asp.Net Core DI-服务消费"></a>Asp.Net Core DI-服务消费</h1><p>本系列博客均来源于大内老A关于Asp.NET Core的解读,在此进基础上进行了提炼,方便日后查看学习.<br>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IServiceProvider的GetService方法，IServiceProvider就会根据对应的服务注册提供所需的服务实例。</p>
<h2 id="IServiceProvider"><a href="#IServiceProvider" class="headerlink" title="IServiceProvider"></a>IServiceProvider</h2><p>IServiceProvider由ServiceCollection的BuildServiceProvider方法来生成,ServiceProvider只包含一个方法GetService(Type serviceType).如下图:</p>
<p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use1.jpg" alt="alt"><br>IserviceProvider包含其他一些扩展方法,可以方便通过不同方式不用应用场景返回实例.如下图:</p>
<p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use2.jpg" alt="alt"></p>
<ul>
<li>GetService<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应实例,如果没有T对应的注册信息,返回null</T></li>
<li>GetServices<T>(this IServiceProvider provider):通过提供泛型类型T,返回对应的多个实例</T></li>
<li> GetServices(this IServiceProvider provider, Type serviceType):传参的方式</li>
<li>GetRequiredService(this IServiceProvider provider, Type serviceType):如果指定服务类型的服务注册不存在,则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用者两个扩展方法</li>
</ul>
<h2 id="构造函数的选择"><a href="#构造函数的选择" class="headerlink" title="构造函数的选择"></a>构造函数的选择</h2><p>如果IServiceProvider对象试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，最终被选择出来的构造函数必须具备一个基本的条件：</p>
<ul>
<li>第一个原则:<strong>IServiceProvider能够提供构造函数的所有参数</strong>.</li>
<li>第二个原则: <strong>每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集</strong>.</li>
</ul>
<h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>对于DI框架体用的三种生命周期（Singleton、Scoped和Transient）来说，Singleton和Transient都具有明确的语义，但是Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由IServiceScopeFactory接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。</p>
<p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有如图3所示的“父子关系”。</p>
<p>任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），后者同样具有提供服务实例的能力，它与当前IServiceProvider具在逻辑上具有“父子关系”。</p>
<p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use3.jpg" alt="alt"></p>
<p>如上图所示的树形层次结构只是一种逻辑结构，从对象引用层面来开，通过某个IServiceScope包裹的IServiceProvider对象不需要知道自己的“父亲”是谁，它只关心作为根节点的IServiceProvider在哪里就可以了。下图从物理层面揭示了IServiceScope/IServiceProvider对象之间的关系，任何一个IServiceProvider对象都具有针对根容器的引用。</p>
<p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use4.jpg" alt="alt"></p>
<h2 id="三种生命周期模式"><a href="#三种生命周期模式" class="headerlink" title="三种生命周期模式"></a>三种生命周期模式</h2><ul>
<li><strong>Singleton</strong>:IServiceProvider创建的服务实例保存在作为根容器的IServiceProvider上，所有多个同根的IServiceProvider对象提供的针对同一类型的服务实例都是同一个对象.</li>
<li><strong>Scoped</strong>:IServiceProvider创建的服务实例由自己保存，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象.</li>
<li><strong>Transient</strong>:针对每一次服务提供请求,IServiceProvider总是创建一个新的实例.</li>
</ul>
<h2 id="ASP-NET-Core应用下的生命周期"><a href="#ASP-NET-Core应用下的生命周期" class="headerlink" title="ASP.NET Core应用下的生命周期"></a>ASP.NET Core应用下的生命周期</h2><p>DI框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如下图所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider，另一个类则是根据请求及时创建和释放的IServiceProvider，我们可以将它们分别称为Application ServiceProvider和Request ServiceProvider。</p>
<p><img src="/2019/10/21/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9/Use5.jpg" alt="alt"></p>
<p>在ASP.NET Core应用初始化过程中，即请求管道构建过程中使用的服务实例都是由Application ServiceProvider提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个服务范围，该服务范围提供的Request ServiceProvider用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，上述的这个中间件会主动释放掉由它创建的服务范围。</p>

	
	</div>
  <a type="button" href="/2019/10/21/ASP-NET-Core-DI-服务消费/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/10/20/ASP-NET-Core-DI-服务注册/" >Asp.Net Core DI-服务注册</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-10-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Asp-Net-Core-DI-服务注册"><a href="#Asp-Net-Core-DI-服务注册" class="headerlink" title="Asp.Net Core DI-服务注册"></a>Asp.Net Core DI-服务注册</h1><p>包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。IServiceCollection实际上是包含了<strong>ServiceDescriptor</strong>对象的集合.</p>
<h2 id="ServiceDescriptor"><a href="#ServiceDescriptor" class="headerlink" title="ServiceDescriptor"></a>ServiceDescriptor</h2><p>IServiceCollection对象是一个存放服务注册信息的集合.在IServiceCollection/IServiceProvider为核心的DI框架中,与之对应的类型为ServiceDescriptor.</p>
<p>DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中.如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p>
<p>ServiceDescriptor共有5个属性,3个构造函数,如下所示:</p>
<p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment1.jpg" alt="alt"></p>
<p>属性说明:</p>
<ul>
<li>ServiceType:注册的服务类型.往往是一个接口</li>
<li>ImplementationType:实现ServiceType接口的类</li>
<li>ImplementationInstance:已经实例化的对象</li>
<li>ImplementationFactory:提供对象的工厂方法.类型为Func&lt;IServiceProvider,object&gt;</li>
<li>Lifetime:生命周期,枚举类型,对应有三个值,分别为:Singleton,Scoped,Transient</li>
</ul>
<p>构造函数说明:<br>ServiceDescriptor的三个属性(ImplementationType,ImplementationInstance,ImplementationFactory)体现了服务实例的三种提供方式，并对应着三个构造函数。</p>
<ul>
<li>ServiceDescriptor(Type serviceType,object instace):提供现有对象,该对象就是最终提供的服务实例.</li>
<li>ServiceDescriptor(Type serviceType,Type implementationType,ServiceLifetime lifetime):最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建.</li>
<li>ServiceDescriptor(Type serviceType, Func&lt;IServiceProvider, object&gt; factory, ServiceLifetime lifetime):IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例</li>
</ul>
<h2 id="IServiceCollection"><a href="#IServiceCollection" class="headerlink" title="IServiceCollection"></a>IServiceCollection</h2><p>DI框架将服务注册(IServiceDescriptor)存储在一个通过IServiceCollection接口表示的集合之中.一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表.在默认情况下我们使用的是实现该接口的ServiceCollection类型.</p>
<p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment2.jpg" alt="alt"></p>
<p>我们在应用启动的时候所做的服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程.考虑到服务注册是一个高频调用的操作,所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作.</p>
<p>DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中.如下所示的是针对Singleton模式的AddSingleton方法重载的定义,针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义.</p>
<p><img src="/2019/10/20/ASP-NET-Core-DI-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/Enrollment3.jpg" alt="alt"></p>

	
	</div>
  <a type="button" href="/2019/10/20/ASP-NET-Core-DI-服务注册/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/10/19/Asp-Net-Core-DI框架/" >Asp.Net Core DI框架</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-10-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Asp-NET-Core-DI框架概览"><a href="#Asp-NET-Core-DI框架概览" class="headerlink" title="Asp.NET Core DI框架概览"></a>Asp.NET Core DI框架概览</h1><p>毫不夸张地说,整个ASP.NET Core框架是建立在一个依赖注入框架之上的,它在应用启动时构建请求处理管道的过程中,以及利用该管道处理每个请求过程中使用到的服务对象均来源于DI容器.该DI容器不仅为ASP.NET Core框架提供必要的服务,同时作为了应用的服务提供者,依赖注入已经成为了ASP.NET Core应用基本的编程模式.</p>
<h2 id="服务的注册与消费"><a href="#服务的注册与消费" class="headerlink" title="服务的注册与消费"></a>服务的注册与消费</h2><p>ASP.NET Core中的依赖注入框架中,我们添加的服务注册被保存到通过 <strong>IServiceCollection</strong> 接口表示的集合之中,基于这个集合创建的DI容器体现为 <strong>IServiceProvider</strong>.</p>
<p>DI框架提供了生产实例的三种生命周期模式,分别为:</p>
<ul>
<li><strong>Singleton</strong>:整个应用程序生命周期内单例</li>
<li><strong>Scoped</strong>:单次服务请求内的单例</li>
<li><strong>Transient</strong>:每次获取均会产生新的对象</li>
</ul>
<p>DI框架注册服务时通常会使用三种方式,分别为:</p>
<ul>
<li>指定注册非服务类型和实现类型.</li>
<li>指定一个现有的服务实例.</li>
<li>指定一个创建服务实例的委托对象.</li>
</ul>
<p>当我们在进行服务注册时,可以为同一类型添加一个服务注册,也可以添加多个,实际上添加的所有服务注册都是有效的,在完成服务注册之后，我们调用IServiceCollection接口的扩展方法  <strong>BuildServiceProvider</strong>创建出代表DI容器的IServiceProvider对象,并利用它调用后者的<strong>GetService<T><strong>方法来提供相应的服务实例,总时会返回一个服务实例,这里采用了”后来居上”的原则,即总是采用最近添加的服务注册来创建服务实例.如果我们调用另一个扩展方法</strong>GetServices<T></T></T></strong>,它将利用返回所有服务注册提供的服务实例.如下所示的代码片段.</p>
<p><img src="/2019/10/19/Asp-Net-Core-DI%E6%A1%86%E6%9E%B6/DI1.jpg" alt="alt"></p>
<h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p>IServiceProvider之间的层次结构造就了三种不同的生命周期模式：由于Singleton服务实例保存在作为根容器的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。Scoped服务实例被保存在当前IServiceProvider上，所以它只能在当前IServiceProvider对象的“服务范围”保证的单例的。没有实现IDisposable接口的Transient服务则采用“即用即取，用后即弃”的策略。</p>
<p>接下来我们通过简单的实例来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表DI容器的IServiceProvider对象之后，我们调用其CreateScope方法创建了两个所谓的“服务范围”，后者的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。</p>
<pre><code>//根节点的ServiceProvider
var root = new ServiceCollection()
        .AddTransient&lt;IFoo, Foo&gt;()
        .AddScoped&lt;IBar&gt;(_ =&gt; new Bar())
        .AddSingleton&lt;IBaz, Baz&gt;()
        .BuildServiceProvider();

//子节点的ServiceProvider
var provider1 = root.CreateScope().ServiceProvider;
var provider2 = root.CreateScope().ServiceProvider;

void GetServices&lt;TService&gt;(IServiceProvider provider)
&#123;
    provider.GetService&lt;TService&gt;();
    provider.GetService&lt;TService&gt;();
&#125;

GetServices&lt;IFoo&gt;(provider1);
GetServices&lt;IBar&gt;(provider1);
GetServices&lt;IBaz&gt;(provider1);
Console.WriteLine();
GetServices&lt;IFoo&gt;(provider2);
GetServices&lt;IBar&gt;(provider2);
GetServices&lt;IBaz&gt;(provider2);

输出:Foo Foo Bar Baz
     Foo Foo Bar
</code></pre>

	
	</div>
  <a type="button" href="/2019/10/19/Asp-Net-Core-DI框架/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/10/19/Ioc模式对应的几种设计模式/" >Ioc模式对应的几种设计模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-10-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Ioc原则对应的几种设计模式"><a href="#Ioc原则对应的几种设计模式" class="headerlink" title="Ioc原则对应的几种设计模式"></a>Ioc原则对应的几种设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IoC仅仅是一种设计原则,针对IoC的设计原则有多种设计模式,例如:模板方法,简单工厂,抽象工厂等.以下通过这三种设计模式阐述如何实现IoC设计原则的.</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据按照预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。</p>
<p>所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供一组相关的对象。</p>
<p>具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。</p>
<h2 id="依赖注入-DI容器"><a href="#依赖注入-DI容器" class="headerlink" title="依赖注入(DI容器)"></a>依赖注入(DI容器)</h2><p>DI:Dependency Injection.含义为依赖注入.DI是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。</p>
<p>在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供所需的每一个服务实例。<br>我们将这个被框架用来提供服务的容器称为“DI容器”.</p>
<p>从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。依赖注入主要有三种方式:[构造器注入]  [属性注入] [方法注入]</p>
<h3 id="Service-Locator"><a href="#Service-Locator" class="headerlink" title="Service Locator"></a>Service Locator</h3><p>假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器，那么我们可以采用如下两种方式(ServiceProvider和ServiceLocator)来定义这个服务类型Foo.</p>
<pre><code>public class Foo : IFoo
&#123;
    public IBar Bar &#123; get; &#125;
    public IBaz Baz &#123; get; &#125;
    //方式一:通过构造器注入,通过框架生成服务实例
    public Foo(IBar bar, IBaz baz)
    &#123;
        Bar = bar;
        Baz = baz;
    &#125;  
    public async Task InvokeAsync()
    &#123;
        await Bar.InvokeAsync();
        await Baz.InvokeAsync();
    &#125;
&#125;

public class Foo : IFoo
&#123;
    public Cat Cat &#123; get; &#125;
    public Foo(Cat cat) =&gt; Cat = cat; 
    public async Task InvokeAsync()
    &#123;
        //方式二:Service Locator,主动去获取服务实例
        await Cat.GetService&lt;IBar&gt;().InvokeAsync();
        await Cat.GetService&lt;IBaz&gt;().InvokeAsync();
    &#125;
&#125;
</code></pre>
<p>以上两种方式虽然都解决了针对服务的解耦问题,但是第二种使用方式不能称之为”依赖注入”,而是一种被称为”Service Locator”的设计模式.Service Locator模式同样具有一个通过服务注册创建的全局容器来提供所需的服务实例,该容器被称为”Service Locator”.DI容器和Service Locator实际上是同一事物在不同设计模型的不同称谓罢了.DI容器和Service Locator之间的差异体现在 <strong>“被谁使用”</strong>.DI容器的使用者是框架自身,Service Locator的使用者是应用程序.一般情况下我们尽可能通过构造器注入的方式使用,尽量不要使用Service Locator模式.</p>

	
	</div>
  <a type="button" href="/2019/10/19/Ioc模式对应的几种设计模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/10/19/Asp.NetCoreIoC/" >Asp.Net Core IoC</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-10-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="Asp-Net-Core-IOC模式"><a href="#Asp-Net-Core-IOC模式" class="headerlink" title="Asp.Net Core IOC模式"></a>Asp.Net Core IOC模式</h1><p>本系列文章来源于大内老A的博客,对博客内容进行了略微整理,方便自己以后查阅.</p>
<h2 id="IoC名词解释"><a href="#IoC名词解释" class="headerlink" title="IoC名词解释"></a>IoC名词解释</h2><p>IoC全名为Inverse of Control,含义为”控制倒置”,针对软件设计行业来说,IoC所谓的控制其实是”针对流程的控制”.控制权原来在应用程序,应用程序可以根据自己的场景定义流程,而IoC原则主张流程的控制权转移到框架中,由框架来定义流程的步骤,我们可以通过下图来说明控制权的转移过程.</p>
<p><img src="/2019/10/19/Asp.NetCoreIoC/IOC1.jpg" alt="alt"></p>
<h2 id="流程定制"><a href="#流程定制" class="headerlink" title="流程定制"></a>流程定制</h2><p>我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制.作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。</p>
<p>我们可以说得更加宽泛点。如下图所示我们将一个泛化的工作流程（A=&gt;B=&gt;C）被定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。 </p>
<p><img src="/2019/10/19/Asp.NetCoreIoC/IOC2.jpg" alt="alt"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一方面IoC对框架的流程进行了封装,消费者只需要执行,框架利用引擎驱动整个流程的运转,应用程序无须关心该工作流程的细节,只需要启动引擎即可.另一方面,框架会提供一系列的扩展点,应用程序则通过定义扩展的方式实现对流程某个环节的定制,在引擎启动前,应用程序将所需的扩展注册到框架中,一旦引擎被正常启动,这些注册的扩展会自动参与到整个流程的执行过程中.这样就实现了框架对流程的高度复用和扩展.</p>

	
	</div>
  <a type="button" href="/2019/10/19/Asp.NetCoreIoC/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/09/18/google开发者工具使用指南/" >google开发者工具使用指南</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-09-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="google开发者工具使用指南"><a href="#google开发者工具使用指南" class="headerlink" title="google开发者工具使用指南"></a>google开发者工具使用指南</h1>
	
	</div>
  <a type="button" href="/2019/09/18/google开发者工具使用指南/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/04/10/javaScript学习笔记/" >javaScript学习笔记</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-04-10  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h2><ul>
<li>ECMAScript:由ECMA-262定义,提供核心语言功能</li>
<li>文档对象模型(DOM):提供访问和操作网页内容的方法和接口</li>
<li>浏览器对象模型(BOM):提供与浏览器交互的方法和接口</li>
</ul>
<h2 id="变量-作用域和内存问题"><a href="#变量-作用域和内存问题" class="headerlink" title="变量 作用域和内存问题"></a>变量 作用域和内存问题</h2><p>JavaScript的变量与其他语言有很大区别.不存在定义某个变量必须要保存何种数据类型值的规则,变量的值以及数据类型可以在脚本的生命周期内改变.</p>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul>
<li><p>从一个变量向另一个变量赋值基本类型的值,会在变量对象上创建一个新值,然后把该值赋值带为新变量分配的位置上.</p>
</li>
<li><p>当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份跟放到为新变量分配的空间中,不同的是,这个值的副本实际上是一个指针.而这个指针指向存储在堆内存中的一个对象.</p>
</li>
</ul>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>Js中所有函数的参数都是按值传递的.不同的是,对于基本类型的值来说,被传递的值会复制给一个局部变量.对于引用类型的值,会把这个值在内存中的地址复制给一个局部变量.<strong>因此这个局部变量的变化会反映在函数的外部</strong>.</p>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul>
<li>检测基本数据类型,通常使用typeof操作符,换句话说,typeof操作符是确定一个变量是字符串,数字,布尔值还是undefined的最佳工具.</li>
<li>检测引用类型,通常使用instanceof操作符.语法如下:<br><code>result = variable instanceof constructor</code></li>
</ul>
<h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>JavaScript函数不介意传递进来多少个参数,也不在乎传进来参数是什么类型,即使定义的函数只接受两个参数,调用时也未必要传递两个参数,原因是JavaScript函数的参数在函数内部用一个arguments对象来表示.</p>
<ul>
<li><p>参数个数</p>
<p> 当实参比函数声明指定的形参要少,剩下的形参都将设置为undefined,通常会使用逻辑或(||)来判断参数是否有值来给变量设置默认值.</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(x,y)&#123;</span><br><span class="line">    x = x||1;</span><br><span class="line">    y = y||2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(3);</span><br></pre></td></tr></table></figure></li>
<li><p>对象参数</p>
<p> 当函数中需要传递多个参数时,一般会使用对象参数的方式,通过键/值对的形式传递参数,这样参数的顺序就无关紧要了.</p>
</li>
</ul>

	
	</div>
  <a type="button" href="/2019/04/10/javaScript学习笔记/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/net/">.net<span>1</span></a></li>
		
			<li><a href="/categories/Asp-Net-Core/">Asp.Net Core<span>6</span></a></li>
		
			<li><a href="/categories/Blog建站/">Blog建站<span>1</span></a></li>
		
			<li><a href="/categories/CSS/">CSS<span>1</span></a></li>
		
			<li><a href="/categories/Html/">Html<span>1</span></a></li>
		
			<li><a href="/categories/typeScript/">typeScript<span>2</span></a></li>
		
			<li><a href="/categories/Html/前端/">前端<span>1</span></a></li>
		
			<li><a href="/categories/CSS/前端/">前端<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/web/">web<span>1</span></a></li>
		
			<li><a href="/tags/Hexo/">Hexo<span>1</span></a></li>
		
			<li><a href="/tags/typeScript/">typeScript<span>2</span></a></li>
		
			<li><a href="/tags/Blog/">Blog<span>1</span></a></li>
		
			<li><a href="/tags/前端/">前端<span>2</span></a></li>
		
			<li><a href="/tags/Asp-Net-Core/">Asp.Net Core<span>6</span></a></li>
		
			<li><a href="/tags/html/">html<span>1</span></a></li>
		
			<li><a href="/tags/IOC-DI/">IOC DI<span>5</span></a></li>
		
			<li><a href="/tags/CSS/">CSS<span>1</span></a></li>
		
			<li><a href="/tags/Webservice/">Webservice<span>1</span></a></li>
		
			<li><a href="/tags/设计模式/">设计模式<span>1</span></a></li>
		
			<li><a href="/tags/基础/">基础<span>3</span></a></li>
		
			<li><a href="/tags/net/">.net<span>1</span></a></li>
		
			<li><a href="/tags/javaScript/">javaScript<span>1</span></a></li>
		
			<li><a href="/tags/GitHub/">GitHub<span>1</span></a></li>
		
			<li><a href="/tags/文件系统/">文件系统<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2021/10/31/interface/" ><i class="fa fa-file-o"></i>interface</a>
      </li>
    
      <li>
        <a href="/2021/10/31/typeScript类型系统/" ><i class="fa fa-file-o"></i>typeScript类型系统</a>
      </li>
    
      <li>
        <a href="/2019/11/05/Asp-Net-Core-文件系统/" ><i class="fa fa-file-o"></i>Asp.Net Core 文件系统</a>
      </li>
    
      <li>
        <a href="/2019/10/21/ASP-NET-Core-DI-服务消费/" ><i class="fa fa-file-o"></i>Asp.Net Core DI-服务消费</a>
      </li>
    
      <li>
        <a href="/2019/10/20/ASP-NET-Core-DI-服务注册/" ><i class="fa fa-file-o"></i>Asp.Net Core DI-服务注册</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/blackshow" title="My Github account." target="_blank">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2021 KenShin
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
