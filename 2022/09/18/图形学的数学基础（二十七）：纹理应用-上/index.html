<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="图形学的数学基础（二十七）：纹理应用(上)在计算机图形学中，纹理贴图是使用图像、函数或其他数据源来改变物体表面外观的技术。例如，可以将一幅砖墙的彩色图像应用到一个多边形上，而不用对砖墙的几何形状进行确表示。通过这种方式将图像和物体表面结合起来，可以在建模、存储空间和速度方面节省很多资源。当然纹理不仅仅用于改变物体表面漫反射颜色,纹理本质上是一个数据集,可以用来存储任何我们需要的顶点数据,因此在方方">
<meta property="og:type" content="article">
<meta property="og:title" content="图形学的数学基础（二十七）：纹理应用(上)">
<meta property="og:url" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/index.html">
<meta property="og:site_name" content="Pixel World">
<meta property="og:description" content="图形学的数学基础（二十七）：纹理应用(上)在计算机图形学中，纹理贴图是使用图像、函数或其他数据源来改变物体表面外观的技术。例如，可以将一幅砖墙的彩色图像应用到一个多边形上，而不用对砖墙的几何形状进行确表示。通过这种方式将图像和物体表面结合起来，可以在建模、存储空间和速度方面节省很多资源。当然纹理不仅仅用于改变物体表面漫反射颜色,纹理本质上是一个数据集,可以用来存储任何我们需要的顶点数据,因此在方方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/15.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/2.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/1.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/3.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/4.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/5.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/6.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/7.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/8.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/9.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/10.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/11.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/12.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/13.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/14.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/15.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/16.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/17.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/18.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/19.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/20.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/22.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/21.png">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/24.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/25.jpg">
<meta property="og:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/26.jpg">
<meta property="article:published_time" content="2022-09-18T02:13:47.000Z">
<meta property="article:modified_time" content="2022-09-20T02:13:46.827Z">
<meta property="article:author" content="KenShin">
<meta property="article:tag" content="Math">
<meta property="article:tag" content="Computer Graphic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/15.png">

<link rel="canonical" href="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>图形学的数学基础（二十七）：纹理应用(上) | Pixel World</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pixel World</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">it's better be burning out than to fade away.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="KenShin">
      <meta itemprop="description" content="it's better be burning out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pixel World">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图形学的数学基础（二十七）：纹理应用(上)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 10:13:47" itemprop="dateCreated datePublished" datetime="2022-09-18T10:13:47+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 10:13:46" itemprop="dateModified" datetime="2022-09-20T10:13:46+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Graphic/" itemprop="url" rel="index"><span itemprop="name">Computer Graphic</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Graphic/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Graphic/Math/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机图形学的数学基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="图形学的数学基础（二十七）：纹理应用-上"><a href="#图形学的数学基础（二十七）：纹理应用-上" class="headerlink" title="图形学的数学基础（二十七）：纹理应用(上)"></a>图形学的数学基础（二十七）：纹理应用(上)</h1><p>在计算机图形学中，纹理贴图是使用图像、函数或其他数据源来改变物体表面外观的技术。例如，可以将一幅砖墙的彩色图像应用到一个多边形上，而不用对砖墙的几何形状进行确表示。通过这种方式将图像和物体表面结合起来，可以在建模、存储空间和速度方面节省很多资源。当然纹理不仅仅用于改变物体表面漫反射颜色,<strong>纹理本质上是一个数据集</strong>,可以用来存储任何我们需要的顶点数据,因此在方方面面得到了广泛的应用.本文将介绍MaterialMap、AlphaMap、BumpMap、NormalMap、ReliefMap、DisplacementMap、ParallaxMap、TexturedLight、ShadowMap、EnvironmentMap。<br>我们将以上纹理贴图的应用划分为6个大类：</p>
<ul>
<li>控制着色信息</li>
<li>控制片元透明度</li>
<li>改变顶点法线</li>
<li>改变表面结构</li>
<li>阴影贴图</li>
<li>环境贴图</li>
</ul>
<h2 id="控制着色信息"><a href="#控制着色信息" class="headerlink" title="控制着色信息"></a>控制着色信息</h2><p>根据$Blinn-phong\;Model$可知，物体表面着色信息有以下因子来控制：</p>
<p><img src="15.png" alt="blinn-phong"></p>
<p>$L = L_a+L_d+L_s = K_aE_a + K_d\dfrac{E}{r^2}max(0, \hat{n}\cdot\hat{l}) + K_s\dfrac{E}{r^2}max(0, \hat{n}\cdot\hat{h})^p$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>$K_a$</td>
<td>物体表面环境光吸收率</td>
</tr>
<tr>
<td>$E_a$</td>
<td>环境光强度</td>
</tr>
<tr>
<td>$\dfrac{E}{r^2}$</td>
<td>到达物体表面的光线</td>
</tr>
<tr>
<td>$K_d$</td>
<td>漫反射系数</td>
</tr>
<tr>
<td>$\hat{n}$</td>
<td>着色点法线</td>
</tr>
<tr>
<td>$\hat{l}$</td>
<td>光线单位矢量</td>
</tr>
<tr>
<td>$K_s$</td>
<td>高光系数</td>
</tr>
<tr>
<td>$p$</td>
<td>高光衰减因子</td>
</tr>
</tbody>
</table>
</div>
<p>可以看到有许多可以调节的参数来控制着色点的着色表现。虽然可以赋予顶点更多的属性来改变这些参数，但是要做到亚三角形的细节，就需要使用各种纹理，<strong>对每个片元的着色参数进行调节</strong>，这些纹理映射方法统称为材质映射（$Material\;Map$）。</p>
<p>最简单的就是漫反射映射，将纹理采样得到的值直接用于$K_d$项，很直观也很简单，这里不做过多赘述。</p>
<p><img src="2.png" alt="漫反射贴图"></p>
<p>此外还可以改变镜面反射系数，如粗糙度（决定高光衰减）和高管反射系数。</p>
<p><img src="1.jpg" alt="漫反射贴图"></p>
<h2 id="控制片元透明度"><a href="#控制片元透明度" class="headerlink" title="控制片元透明度"></a>控制片元透明度</h2><p>纹理都是矩形的，但当我们要实现各种贴画（$decal$）或者镂空（$cutout$）效果时，往往不想让纹理贴满整个表面，也就是说一些地方的透明度为0，这时候$alphaMap$就登场了。</p>
<p><img src="3.png" alt="漫反射贴图"></p>
<p>所以不需要把片元当作半透明进行混合，而是进行透明度测试 (Alpha Test)，将透明度小于阈值的 texel 认为是完全透明，直接抛弃片元，否则为完全不透明，测试完成后，再用 z-buffer 算法进行对所有完全不透明片元进行混合。透明度测试的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(texture.a &lt; alphaThreshold)  discard</span><br></pre></td></tr></table></figure>
<p>但是透明度测试在使用$mipmap$时会存在问题：如下图，第0级纹理连续四个texel的透明度为 [0.0, 1.0, 1.0, 0.0]，第1级纹理就为 [0.5, 0.5]，假设我们设定alphaThreshold为0.75，可知第0级纹理有1.5/4通过测试，但是在第一级纹理中，所有的纹素的值都变成了0.5， 0.5 &lt; 0.75所以，所有像素都被抛弃。</p>
<p><img src="4.png" alt="漫反射贴图"></p>
<p>于是在不同的$mipmap$纹理等级中，经过透明度测试留下来的像素占比也不一样，因为高等级纹理是对低等级纹理的范围平均，因此随着levelD的增大，纹素值会趋于平均化，之前在阈值之上的值，被平均化以后很有可能到阈值线之下，因此被抛弃的像素就越来越多：</p>
<p><img src="5.jpg" alt="漫反射贴图"></p>
<p>我们来看一个例子，如下图所示，当相机距离树较近时，看起来一切正常：</p>
<p><img src="6.png" alt="漫反射贴图"></p>
<p>当相机拉远后，树叶消失了一部分（由于mimmap均值化后，导致被抛弃像素占比增加）：</p>
<p><img src="7.png" alt="漫反射贴图"></p>
<p>当相机拉远到相当一段距离后，发现树叶消失的更多：</p>
<p><img src="8.png" alt="漫反射贴图"></p>
<p>一般解决办法有两个：</p>
<ol>
<li>手动调节每级mipmap透明度，或者在shader中根据纹理等级d对透明度缩放</li>
<li>限制d的最大值</li>
</ol>
<p>但这两种方法都只能是近似，不能很好解决问题，出现这个 问题的关键在于：不同 $mipmap$，用同样的透明度阈值会得到不同的 Coverage(代表测试留存的像素比例)</p>
<p>Castano提出了一种：保证coverage一致的情况下，自适应确定透明度阈值，并对原透明度缩放调整的方法。</p>
<p><img src="9.png" alt="漫反射贴图"></p>
<p>经过这种特殊处理后，我们发现远处的树木表现恢复正常了。</p>
<p><img src="10.png" alt="漫反射贴图"></p>
<p><img src="11.png" alt="漫反射贴图"></p>
<p>另外在对RGBA值进行线性插值时，要注意把alpha分量预乘到RGB分量，再进行插值：</p>
<p><img src="12.png" alt="漫反射贴图"></p>
<p>比较实际的情况是：希望插值的结果偏向于不透明那边颜色的色调，所以通常而言，预乘后插值会比较合理。</p>
<h2 id="凹凸贴图（-BumpMapping-）"><a href="#凹凸贴图（-BumpMapping-）" class="headerlink" title="凹凸贴图（$BumpMapping$）"></a>凹凸贴图（$BumpMapping$）</h2><p>用于改变表面片元法线的技术统称为凹凸贴图($BumpMapping$),凹凸贴图把各像素法线相关的信息存于一张Texture中，各像素的的法线通过这张纹理采样得到，使用采样得到的法线代替片元自身的法线进行着色光照计算，会看到凹凸不平的效果，是一种欺骗眼睛的效果。凹凸贴图思想最早由图形学大牛Jim Blinn提出，后来的Normal Mapping，Parrallax Mapping，Parallax Occulision Mapping，Relief Mapping，均是基于同样的思想，只是考虑的越来越全面，效果越来越逼真。</p>
<h3 id="存储法线的几种方式"><a href="#存储法线的几种方式" class="headerlink" title="存储法线的几种方式"></a>存储法线的几种方式</h3><h4 id="heightMap"><a href="#heightMap" class="headerlink" title="$heightMap$"></a>$heightMap$</h4><p><img src="13.jpg" alt="漫反射贴图"></p>
<p>$heightMap$存储的是表面的相对高度，该高度的变化实际上表现了物体表面凹凸不平的特质，但是高度值不能直接用来计算光照，必须先将其转换为法线，再通过法线计算光照，这就是$heightMap$的核心原理。但是有个问题是，我们如何通过高度值计算出法线呢?</p>
<p><img src="14.jpg" alt="漫反射贴图"></p>
<p>要计算P点的法线，可以先求p点的切线，而切线正是函数曲线在p点的导数。</p>
<p>先拿二维的情况举例，点p的原始法线为$(0, 1)$，假设$h$为高度函数，根据差分近似求出点p的导数为：</p>
<p><img src="15.jpg" alt="漫反射贴图"></p>
<p>$dp = c * (h(p + 1) - h(p))$</p>
<p>点p的切线矢量为：</p>
<p>$tangent(p) = (1, dp) = (1, c * (h(p + 1) - h(p)))$</p>
<p>将切线逆时针旋转90°，得到p点扰动后的法线。</p>
<p>$normal(p) = \begin{bmatrix}<br>    0&amp;-1\\<br>    1&amp;0<br>\end{bmatrix}tangent(p) = \begin{bmatrix}<br>    0&amp;-1\\<br>    1&amp;0<br>\end{bmatrix}\begin{bmatrix}<br>1\\<br>dp<br>\end{bmatrix} = \begin{bmatrix}<br>    -dp\\<br>    1<br>\end{bmatrix} = \begin{bmatrix}<br>    -(c∗(h(p+1)−h(p)))\\<br>    1<br>\end{bmatrix}$</p>
<p>注：上述推导中$c$为常数，表示法线被扰动影响大小的因子。</p>
<p>将上述推导到三维过程，只需要计算uv两个方向的梯度，剩下的和二维一致，计算切线，逆时针旋转90°计算法线。</p>
<ul>
<li>原始法线$n(p) = (0,0,1)$</li>
<li>分别计算nv两个方向上的梯度：<ul>
<li>$\dfrac{dp}{du} = c_1 *(h(u + 1)- h(u))$</li>
<li>$\dfrac{dp}{dv} = c_2 * (h(v + 1)- h(v))$</li>
</ul>
</li>
<li>被扰动后的法线： $normal(p) = \begin{bmatrix}<br>  \dfrac{-d_p}{d_u}\\<br>  \dfrac{-d_p}{d_v}\\<br>  1<br>\end{bmatrix}.normalized()$</li>
</ul>
<p><strong>注：所有计算出的法线都是在切线空间下的，需要乘以$TBN$矩阵转换到世界空间！</strong></p>
<h4 id="BumpMapping"><a href="#BumpMapping" class="headerlink" title="$BumpMapping$"></a>$BumpMapping$</h4><p>原始的凹凸贴图技术，由jim Blinn提出，后续的凹凸贴图技术都是基于其思想改进的。想法很简单，纹理贴图上每个像素点存储两个信息，一个是$u$方向的偏移矢量，一个是$v$方向上的偏移矢量。这样原始法线加上这两个矢量后自然得到了扰动后的法线。</p>
<p><img src="16.jpg" alt="漫反射贴图"></p>
<h4 id="NormalMap"><a href="#NormalMap" class="headerlink" title="$NormalMap$"></a>$NormalMap$</h4><p>我们知道Texture上可以存储三维的颜色作为漫反射系数，自然也可以存储法线向量的信息，利用$(u,v)$坐标查询每个点的法线向量，而不是用原始模型的法线信息，这就是$normalMap$。</p>
<p>明白了Normal Maps的原理之后，有一点重要的是，如何在存储这些法线信息呢？一种可选方案是存储对象空间下法线信息，这样在做完纹理查询后乘以世界空间矩阵直接就可以用了，但是不好的一点是，当对象空间发生变化时，那么该法线向量就不再正确了。更通用的做法是存储切线空间下的法线向量。</p>
<p>对象空间和切线空间法线贴图对比：</p>
<p><img src="17.jpg" alt="漫反射贴图"></p>
<p>显然切线空间的存储方式更加灵活，不受制于种种限制，但是要付出的相应代价就是需要比较复杂的空间转换过程。</p>
<p>应用法线贴图后的渲染结果。</p>
<p><img src="18.jpg" alt="漫反射贴图"></p>
<p>一张图解释三种凹凸贴图的区别：</p>
<p><img src="19.png" alt="漫反射贴图"></p>
<h5 id="TBN空间"><a href="#TBN空间" class="headerlink" title="TBN空间"></a>TBN空间</h5><p><img src="20.jpg" alt="漫反射贴图"></p>
<p>切线空间定义于每一个顶点之中，是由切线（$Tangent$），副切线（$BiTangent$），顶点法线（$Normal$）以模型顶点为中心的坐标空间。$normalMap$中的法向量在切空间中表示，其中法向量总是大致指向正z方向。切线空间是一个三角形表面的局部空间:法线相对于单个三角形的局部参考系。把它想象成法向量的局部空间;它们都是指向正z方向的不管最终变换的方向是什么。使用一个特定的矩阵，我们可以将这个局部切线空间的法向量转换为世界或视图坐标，并将它们沿最终映射曲面的方向定向。这个矩阵就是$TBN$矩阵。接下来将详细推导$TBN$矩阵的构造过程。</p>
<p><img src="22.jpg" alt="漫反射贴图"></p>
<p>只需要下面两个步骤即可得到规范化的$TBN$矩阵。</p>
<p><img src="21.png" alt="漫反射贴图"></p>
<p>$E_1 = \triangle{U_1}T + \triangle{V_1}B$</p>
<p>$E_2 = \triangle{U_2}T + \triangle{V_2}B$</p>
<p>该公式的数学意义是，如何将一个点从uv空间映射到三维空间，其中TB作为基矢量，以uv空间中u和v的增长作为控制参数，假设三角形中存在一点p，则$\vec{AP} = u(p) <em> \vec{B} + v(p) </em> \vec{B}$,<strong>点p可以表示为以TB为基矢量的uv空间，TB轴的线性组合。</strong></p>
<p>根据以上公式可以快速的推导出TB：</p>
<p>$\vec{T} = \dfrac{\triangle{V_1}E_2 - \triangle{V_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$</p>
<p>$\vec{B} = \dfrac{-\triangle{U_1}E_2 + \triangle{U_2}E_1}{\triangle{V_1}\triangle{U_2} - \triangle{V_2}\triangle{U_1}}$</p>
<p>目前给出的TB还是不是真正的切线与副切线，需要正交化后得到$TBN$矩阵:</p>
<p>$\vec{t}_⊥ = normalized(\vec{t} - (\vec{t}\cdot\vec{n})\vec{n})$</p>
<p>$\vec{b}_⊥ = normalized(\vec{b} - (\vec{b}\cdot\vec{n})\vec{n} - (\vec{b}\cdot\vec{t}_⊥)\vec{t}_⊥)$</p>
<p>其中n是建模软件中规定的顶点法线，可以看到n在正交化过程中不会受到影响，该过程是对TB向量进行方向的调整以及长度的归一化。TB在此过程后会相互垂直，此时将不再一定与UV方向保持相同。特别的，当调整顶点法线后，TB平面甚至将与三维空间中的三角形平面不同,也就是说归正交化后的$TBN$矩阵，$TB$轴将不再与$uv$相等，$uv$是正交化前的$TB$轴。</p>
<p>通过正交化后的$Tangent(T),Bitangent(B),Normal(N)$可以推导出$TBN$矩阵：</p>
<p>$TBN = \begin{bmatrix}<br>    T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}$</p>
<p>$normalMap$中存储的法线信息是基于$TBN$空间的，而光照计算需要所有的参数在同一空间下，以上计算出的$TBN$矩阵就是用于实现将$TBN$空间中定义的法线转换到世界空间。</p>
<p>$Normal_{world} = \begin{bmatrix}<br>     T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}Normal_{tbn}$</p>
<p>根据矩阵的逆的性质，$TBN$矩阵的逆矩阵可以用来将矢量从世界空间转换到$TBN$空间中，而$TBN$矩阵是正交化过的，根据正交矩阵的特殊性质（正交矩阵的逆等于其转置），可以轻松求得$TBN$的逆矩阵:</p>
<p>$TBN^{-1} = TBN^T = \begin{bmatrix}<br>    T_x&amp;B_x&amp;N_x\\<br>    T_y&amp;B_y&amp;N_y\\<br>    T_z&amp;B_z&amp;N_z\\<br>\end{bmatrix}$</p>
<p>$Vector_{tbn} = \begin{bmatrix}<br>    T_x&amp;T_y&amp;T_z\\<br>    B_x&amp;B_y&amp;B_z\\<br>    N_x&amp;N_y&amp;N_z\\<br>\end{bmatrix}Vector_{world}$</p>
<h5 id="利用法线贴图的信息计算模型光照"><a href="#利用法线贴图的信息计算模型光照" class="headerlink" title="利用法线贴图的信息计算模型光照"></a>利用法线贴图的信息计算模型光照</h5><p>首先是纹理采样拿到当前像素点存储的值，如果纹理贴图是经过压缩的，需要计算（补全）三个通道值，然后将每个通道的数值范围从$[0,255]$映射到$[-1, 1]$。要做基于法线的光照计算，需要保证所有的参数（法线 光照方向 观测方向等）都在同一空间下。实现方式有两种:</p>
<ol>
<li>直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li>
<li>使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li>
</ol>
<p>更常用的做法是采取第二种方式，将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为lightPos和viewPos不是每个fragment运行都要改变，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在像素着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个像素着色器都不一样。</p>
<p>所以现在不是把TBN矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。这也是为什么这种方法是一种更好的实现方式的原因。以下是shader代码；</p>
<p><strong>vertexShader</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line">layout (location = 1) in vec3 aNormal;</span><br><span class="line">layout (location = 2) in vec2 aTexCoords;</span><br><span class="line">layout (location = 3) in vec3 aTangent;</span><br><span class="line">layout (location = 4) in vec3 aBitangent;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vs_out.FragPos = vec3(model * vec4(aPos, 1.0));   </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">    </span><br><span class="line">    mat3 normalMatrix = transpose(inverse(mat3(model)));</span><br><span class="line">    vec3 T = normalize(normalMatrix * aTangent);</span><br><span class="line">    vec3 N = normalize(normalMatrix * aNormal);</span><br><span class="line">    T = normalize(T - dot(T, N) * N);</span><br><span class="line">    vec3 B = cross(N, T);</span><br><span class="line">    </span><br><span class="line">    mat3 TBN = transpose(mat3(T, B, N));    </span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * vs_out.FragPos;</span><br><span class="line">        </span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fragmentShader</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseMap;</span><br><span class="line">uniform sampler2D normalMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;           </span><br><span class="line">     // obtain normal from normal map in range [0,1]</span><br><span class="line">    vec3 normal = texture(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    // transform normal vector to range [-1,1]</span><br><span class="line">    normal = normalize(normal * 2.0 - 1.0);  // this normal is in tangent space</span><br><span class="line">   </span><br><span class="line">    // get diffuse color</span><br><span class="line">    vec3 color = texture(diffuseMap, fs_in.TexCoords).rgb;</span><br><span class="line">    // ambient</span><br><span class="line">    vec3 ambient = 0.1 * color;</span><br><span class="line">    // diffuse</span><br><span class="line">    vec3 lightDir = normalize(fs_in.TangentLightPos - fs_in.TangentFragPos);</span><br><span class="line">    float diff = max(dot(lightDir, normal), 0.0);</span><br><span class="line">    vec3 diffuse = diff * color;</span><br><span class="line">    // specular</span><br><span class="line">    vec3 viewDir = normalize(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    vec3 halfwayDir = normalize(lightDir + viewDir);  </span><br><span class="line">    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);</span><br><span class="line"></span><br><span class="line">    vec3 specular = vec3(0.2) * spec;</span><br><span class="line">    FragColor = vec4(ambient + diffuse + specular, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$normalMap$为什么都是偏蓝色的？</p>
<p>法线贴图是增加细节用的，因此在以原顶点法线为z轴的切线空间中，其（r，g，b）中肯定仍然是以b分量为重，故法线向量的值基本在（0，0，1）左右，经过-1到1映射到0-1在贴图存储的过程，贴图颜色变为（0.5，0.5，1），反映到颜色上自然是常见的法线贴图颜色了。</p>
<p>$normalMap$压缩</p>
<p> 我们通常会把法线贴图归一化成一个3元向量n（x,y,z）来表示，常识上来看，因为这个n是归一化的，所以用两个向量（x,y）已经可以表示这个3元向量了，可以减少数据存储，压缩我们的贴图量。</p>
<ul>
<li>只保留两个颜色通道<ul>
<li>因为normal是归一化向量，其大小为1；又因为切线空间的法线z方向总是正方向，所以可以只存x和y就可以用勾股定理计算出z值（因为正方向所以取正值）。所以只保存rg两个通道。</li>
<li>但是如果只有一个通道那贴图压缩质量更好。所以只用g通道，并将r通道的值存入alpha透明通道。</li>
</ul>
</li>
</ul>
<h5 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h5><p>你可能会问为什么不简单地把法线看作向量。为什么要将他们区别对待呢?在前几章中，我们已经学习了使用矩阵乘法来变换点和向量。法线的问题是，当矩阵对法线进行均匀缩放时，这样做没问题。但是现在让我们考虑一下将非均匀缩放应用到一个物体上的情况。让我们(在2D中)画一条经过点a =(0,1,0)和点B=(1,0,0)的直线，然后从原点到坐标(1,1,0)再画一条直线，你会发现这条直线垂直于我们的平面。假设(1,1,0)是$AB$的法线.</p>
<p><img src="24.jpg" alt="漫反射贴图"></p>
<p>现在假设我们使用以下矩阵对平面应用非均匀缩放:</p>
<p>$\textbf{M} = \begin{bmatrix}<br>    2&amp;0&amp;0&amp;0\\<br>    0&amp;1&amp;0&amp;0\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p>
<p><img src="25.jpg" alt="漫反射贴图"></p>
<p>在对$AB$和$\vec{N}$应用同样的变换矩阵$M$后,我们发现之前垂直的两条线不再垂直了,这也从侧面说明,对法线直接应用Model矩阵结果是错误的。<strong>实际上变换法线不能直接应用和变换顶点相同的矩阵M，而需要应用其逆矩阵的转置。</strong></p>
<p>$\vec{N^丶} = \textbf{M}^{-1T}\vec{N}$</p>
<p>在进行数学推导之前，先让我们从直觉上进行解释。首先法线代表方向，是一个矢量，因此平移矩阵不会对其产生影响，因为矢量的w分量为0，换句话说对于一个4x4的矩阵M，我们可以忽略第四行和第四列，只考虑左上角3x3的部分（缩放和旋转）。我们将3x3的矩阵分解为两部分看待，分别为旋转和缩放。我们都知道旋转矩阵是正交矩阵，而正交矩阵的逆等于其转置，因此对于旋转矩阵$R$来说：</p>
<p>$R^T =R^{-1}$</p>
<p>$R = R^{-1T}$</p>
<p><strong>旋转矩阵逆矩阵的转置等于其自身。</strong></p>
<p>对于缩放的部分，缩放矩阵的转置等于其自身，缩放矩阵的逆可以很容易的通过其缩放因子计算：</p>
<p>$M^{-1T} = \begin{bmatrix}<br>    1/2&amp;0&amp;0&amp;0\\<br>    0&amp;1&amp;0&amp;0\\<br>    0&amp;0&amp;1&amp;0\\<br>    0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}$</p>
<p>对上图中的$\vec{N}$应用该矩阵：</p>
<p><img src="26.jpg" alt="漫反射贴图"></p>
<p>数学推导：<br>首先澄清几个概念，</p>
<ul>
<li>两个正交向量的点积等于0</li>
<li>两个向量的点积可以写成1x3和3x1矩阵乘积的形式</li>
<li>如果两个向量点乘结果为0，则对应的矩阵乘积形式结果也为0</li>
</ul>
<p>$\textbf{v}\cdot\textbf{n} = \begin{bmatrix}<br>    v_x&amp;v_y&amp;v_z<br>\end{bmatrix}\begin{bmatrix}<br>    n_x\\<br>    n_y\\<br>    n_z\\<br>\end{bmatrix} = \textbf{v} * \textbf{n}^T = 0$</p>
<p>$\textbf{v}\cdot\textbf{n} = \textbf{v} <em> \textbf{n}^T = v_x</em>n_x + v_y<em>n_y + v_z</em>n_z$</p>
<p>$\textbf{v}<em>\textbf{n}^T = \textbf{v}</em> M <em> M^{-1} </em> \textbf{n}^T$</p>
<p>根据矩阵转置的性质：$(AB)^T = B^TA^T$可以推导出：</p>
<p>$\textbf{v}<em>\textbf{n}^T = (\textbf{v}</em> M)<em>(\textbf{n}</em>M^{-1T})^T$</p>
<p>注意观察以上表达式，我们注意到等号右侧第一个括号内的$\textbf{v}*M$,实际上是原始顶点$v$在经过矩阵M变换后得到的$v^丶$:</p>
<p>$\textbf{v}^丶 = \textbf{v}*M$</p>
<p>我们知道两个向量在经过变换后仍然得保持垂直，因此：</p>
<p>$\textbf{v}<em>\textbf{n}^T = \textbf{v}^丶</em>\textbf{n}^{丶T} = 0$</p>
<p>因此，等号右侧的第二部分$(\textbf{n}*M^{-1T})^T$可以重写为：</p>
<p>$\textbf{n}^{丶T} = (\textbf{n}*M^{-1T})^T$</p>
<p>$\textbf{n}^丶 = \textbf{n}*M^{-1T}$</p>
<p>也就是说$\textbf{n}$只有经过$M^{-1T}$变换后才能<strong>成为</strong>$\textbf{n}^丶$，才能做到变换后依然和$v^丶$垂直。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/261667233">用一篇文章理解法线变换、切线空间、法线贴图</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139593847">切线空间（Tangent Space）完全解析</a></p>
<p><a href>RealTime Rendering</a></p>
<p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">learningOpenGL</a></p>
<p><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101</a></p>
<p><a target="_blank" rel="noopener" href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry/transforming-normals">scratchapixel</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Math/" rel="tag"># Math</a>
              <a href="/tags/Computer-Graphic/" rel="tag"># Computer Graphic</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/15/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/" rel="prev" title="图形学的数学基础（二十六）：纹理映射">
      <i class="fa fa-chevron-left"></i> 图形学的数学基础（二十六）：纹理映射
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/20/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8B/" rel="next" title="图形学的数学基础（二十七）：纹理应用(下)">
      图形学的数学基础（二十七）：纹理应用(下) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%B9%E7%90%86%E5%BA%94%E7%94%A8-%E4%B8%8A"><span class="nav-number">1.</span> <span class="nav-text">图形学的数学基础（二十七）：纹理应用(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%9D%80%E8%89%B2%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.</span> <span class="nav-text">控制着色信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%89%87%E5%85%83%E9%80%8F%E6%98%8E%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">控制片元透明度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE%EF%BC%88-BumpMapping-%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">凹凸贴图（$BumpMapping$）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%B3%95%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">存储法线的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#heightMap"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">$heightMap$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BumpMapping"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">$BumpMapping$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NormalMap"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">$NormalMap$</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TBN%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">TBN空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B%E5%85%89%E7%85%A7"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">利用法线贴图的信息计算模型光照</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%95%E7%BA%BF%E5%8F%98%E6%8D%A2"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">法线变换</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.4.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KenShin"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">KenShin</p>
  <div class="site-description" itemprop="description">it's better be burning out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Kenshin627" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Kenshin627" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/kenshin20207@163.com" title="E-Mail → kenshin20207@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KenShin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="true"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
